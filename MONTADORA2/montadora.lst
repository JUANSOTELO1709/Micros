CCS PCM C Compiler, Version 5.025, 63725               05-ene.-23 09:20

               Filename:   C:\Users\juand\Desktop\MONTADORA2\montadora.lst

               ROM used:   2791 words (34%)
                           Largest free fragment is 2048
               RAM used:   64 (17%) at main() level
                           90 (24%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
....................  
....................  
.................... #include <16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  BCF    0A.0
000D:  BCF    0A.1
000E:  BCF    0A.2
000F:  ADDWF  02,F
0010:  RETLW  31
0011:  RETLW  32
0012:  RETLW  33
0013:  RETLW  41
0014:  RETLW  34
0015:  RETLW  35
0016:  RETLW  36
0017:  RETLW  42
0018:  RETLW  37
0019:  RETLW  38
001A:  RETLW  39
001B:  RETLW  43
001C:  RETLW  2A
001D:  RETLW  30
001E:  RETLW  23
001F:  RETLW  44
0020:  DATA 0C,00
0021:  DATA E2,3A
0022:  DATA 65,37
0023:  DATA 20,32
0024:  DATA E9,30
0025:  DATA 20,00
0026:  DATA E3,37
0027:  DATA 6E,3A
0028:  DATA 00,01
0029:  DATA D4,32
002A:  DATA 6D,38
002B:  DATA 3A,00
002C:  DATA D0,37
002D:  DATA F3,34
002E:  DATA E3,34
002F:  DATA 6F,37
0030:  DATA 3A,00
0031:  DATA 33,1A
0032:  DATA AD,19
0033:  DATA 35,00
0034:  DATA 33,1B
0035:  DATA AD,19
0036:  DATA 37,00
0037:  DATA 33,1C
0038:  DATA AD,19
0039:  DATA 39,00
003A:  DATA 50,39
003B:  DATA E5,39
003C:  DATA E9,37
003D:  DATA EE,32
003E:  DATA A0,11
003F:  DATA 20,38
0040:  DATA 61,39
0041:  DATA 61,10
0042:  DATA F4,32
0043:  DATA 6D,38
0044:  DATA 00,01
0045:  DATA C2,2A
0046:  DATA D3,21
0047:  DATA 41,27
0048:  DATA C4,27
0049:  DATA 00,01
004A:  DATA C2,2A
004B:  DATA D3,21
004C:  DATA 41,27
004D:  DATA C4,27
004E:  DATA 00,01
004F:  DATA 33,1B
0050:  DATA AD,19
0051:  DATA 37,00
0052:  DATA F0,37
0053:  DATA F3,34
0054:  DATA E3,34
0055:  DATA 6F,37
0056:  DATA 20,1A
0057:  DATA 00,01
0058:  DATA 49,27
0059:  DATA 47,29
005A:  DATA C5,29
005B:  DATA 45,10
005C:  DATA 47,29
005D:  DATA 41,22
005E:  DATA CF,29
005F:  DATA 00,01
0060:  DATA 33,10
0061:  DATA E4,34
0062:  DATA E7,34
0063:  DATA F4,37
0064:  DATA 73,00
*
01DE:  MOVF   0B,W
01DF:  MOVWF  57
01E0:  BCF    0B.7
01E1:  BSF    03.5
01E2:  BSF    03.6
01E3:  BSF    0C.7
01E4:  BSF    0C.0
01E5:  NOP
01E6:  NOP
01E7:  BCF    03.5
01E8:  BCF    03.6
01E9:  BTFSC  57.7
01EA:  BSF    0B.7
01EB:  BSF    03.6
01EC:  MOVF   0C,W
01ED:  ANDLW  7F
01EE:  BTFSC  03.2
01EF:  GOTO   232
01F0:  BCF    03.6
01F1:  MOVWF  57
01F2:  BSF    03.6
01F3:  MOVF   0D,W
01F4:  BCF    03.6
01F5:  MOVWF  58
01F6:  BSF    03.6
01F7:  MOVF   0F,W
01F8:  BCF    03.6
01F9:  MOVWF  59
01FA:  MOVF   57,W
01FB:  MOVWF  68
01FC:  CALL   1B1
01FD:  MOVF   58,W
01FE:  BSF    03.6
01FF:  MOVWF  0D
0200:  BCF    03.6
0201:  MOVF   59,W
0202:  BSF    03.6
0203:  MOVWF  0F
0204:  BCF    03.6
0205:  MOVF   0B,W
0206:  MOVWF  5A
0207:  BCF    0B.7
0208:  BSF    03.5
0209:  BSF    03.6
020A:  BSF    0C.7
020B:  BSF    0C.0
020C:  NOP
020D:  NOP
020E:  BCF    03.5
020F:  BCF    03.6
0210:  BTFSC  5A.7
0211:  BSF    0B.7
0212:  BSF    03.6
0213:  RLF    0C,W
0214:  RLF    0E,W
0215:  ANDLW  7F
0216:  BTFSC  03.2
0217:  GOTO   232
0218:  BCF    03.6
0219:  MOVWF  57
021A:  BSF    03.6
021B:  MOVF   0D,W
021C:  BCF    03.6
021D:  MOVWF  58
021E:  BSF    03.6
021F:  MOVF   0F,W
0220:  BCF    03.6
0221:  MOVWF  59
0222:  MOVF   57,W
0223:  MOVWF  68
0224:  CALL   1B1
0225:  MOVF   58,W
0226:  BSF    03.6
0227:  MOVWF  0D
0228:  BCF    03.6
0229:  MOVF   59,W
022A:  BSF    03.6
022B:  MOVWF  0F
022C:  INCF   0D,F
022D:  BTFSC  03.2
022E:  INCF   0F,F
022F:  BCF    03.6
0230:  GOTO   1DE
0231:  BSF    03.6
0232:  BCF    03.6
0233:  RETURN
0234:  MOVF   57,W
0235:  ANDLW  07
0236:  MOVWF  77
0237:  RRF    57,W
0238:  MOVWF  78
0239:  RRF    78,F
023A:  RRF    78,F
023B:  MOVLW  1F
023C:  ANDWF  78,F
023D:  MOVF   78,W
023E:  ADDWF  58,W
023F:  MOVWF  04
0240:  BCF    03.7
0241:  BTFSC  59.0
0242:  BSF    03.7
0243:  MOVF   00,W
0244:  MOVWF  78
0245:  INCF   77,F
0246:  GOTO   248
0247:  RRF    78,F
0248:  DECFSZ 77,F
0249:  GOTO   247
024A:  RETURN
*
02C0:  MOVLW  8E
02C1:  MOVWF  77
02C2:  MOVF   5C,W
02C3:  MOVWF  78
02C4:  MOVF   5B,W
02C5:  MOVWF  79
02C6:  CLRF   7A
02C7:  MOVF   78,F
02C8:  BTFSS  03.2
02C9:  GOTO   2D4
02CA:  MOVF   79,W
02CB:  MOVWF  78
02CC:  CLRF   79
02CD:  MOVLW  08
02CE:  SUBWF  77,F
02CF:  MOVF   78,F
02D0:  BTFSS  03.2
02D1:  GOTO   2D4
02D2:  CLRF   77
02D3:  GOTO   2DC
02D4:  BCF    03.0
02D5:  BTFSC  78.7
02D6:  GOTO   2DB
02D7:  RLF    79,F
02D8:  RLF    78,F
02D9:  DECF   77,F
02DA:  GOTO   2D4
02DB:  BCF    78.7
*
02F3:  MOVLW  80
02F4:  BTFSC  03.1
02F5:  XORWF  64,F
02F6:  CLRF   69
02F7:  CLRF   6A
02F8:  MOVF   60,W
02F9:  MOVWF  68
02FA:  MOVF   64,W
02FB:  XORWF  68,F
02FC:  MOVF   5F,W
02FD:  BTFSC  03.2
02FE:  GOTO   3E3
02FF:  MOVWF  67
0300:  MOVWF  77
0301:  MOVF   63,W
0302:  BTFSC  03.2
0303:  GOTO   3EC
0304:  SUBWF  67,F
0305:  BTFSC  03.2
0306:  GOTO   388
0307:  BTFSS  03.0
0308:  GOTO   346
0309:  MOVF   64,W
030A:  MOVWF  6D
030B:  BSF    6D.7
030C:  MOVF   65,W
030D:  MOVWF  6C
030E:  MOVF   66,W
030F:  MOVWF  6B
0310:  CLRF   6A
0311:  BCF    03.0
0312:  RRF    6D,F
0313:  RRF    6C,F
0314:  RRF    6B,F
0315:  RRF    6A,F
0316:  DECFSZ 67,F
0317:  GOTO   310
0318:  BTFSS  68.7
0319:  GOTO   31D
031A:  BSF    69.0
031B:  GOTO   400
031C:  BCF    69.0
031D:  BCF    67.0
031E:  BSF    69.4
031F:  MOVLW  62
0320:  MOVWF  04
0321:  BCF    03.7
0322:  GOTO   415
0323:  BCF    69.4
0324:  BTFSC  68.7
0325:  GOTO   330
0326:  BTFSS  67.0
0327:  GOTO   33B
0328:  RRF    6D,F
0329:  RRF    6C,F
032A:  RRF    6B,F
032B:  RRF    6A,F
032C:  INCF   77,F
032D:  BTFSC  03.2
032E:  GOTO   3FB
032F:  GOTO   33B
0330:  BTFSC  6D.7
0331:  GOTO   33E
0332:  BCF    03.0
0333:  RLF    6A,F
0334:  RLF    6B,F
0335:  RLF    6C,F
0336:  RLF    6D,F
0337:  DECF   77,F
0338:  BTFSC  03.2
0339:  GOTO   3FB
033A:  GOTO   330
033B:  BSF    69.6
033C:  GOTO   3A8
033D:  BCF    69.6
033E:  MOVF   60,W
033F:  MOVWF  68
0340:  BTFSS  68.7
0341:  GOTO   344
0342:  BSF    6D.7
0343:  GOTO   3F4
0344:  BCF    6D.7
0345:  GOTO   3F4
0346:  MOVF   63,W
0347:  MOVWF  67
0348:  MOVWF  77
0349:  MOVF   5F,W
034A:  SUBWF  67,F
034B:  MOVF   60,W
034C:  MOVWF  6D
034D:  BSF    6D.7
034E:  MOVF   61,W
034F:  MOVWF  6C
0350:  MOVF   62,W
0351:  MOVWF  6B
0352:  CLRF   6A
0353:  BCF    03.0
0354:  RRF    6D,F
0355:  RRF    6C,F
0356:  RRF    6B,F
0357:  RRF    6A,F
0358:  DECFSZ 67,F
0359:  GOTO   352
035A:  BTFSS  68.7
035B:  GOTO   35F
035C:  BSF    69.1
035D:  GOTO   400
035E:  BCF    69.1
035F:  BCF    67.0
0360:  BSF    69.5
0361:  MOVLW  66
0362:  MOVWF  04
0363:  BCF    03.7
0364:  GOTO   415
0365:  BCF    69.5
0366:  BTFSC  68.7
0367:  GOTO   372
0368:  BTFSS  67.0
0369:  GOTO   37D
036A:  RRF    6D,F
036B:  RRF    6C,F
036C:  RRF    6B,F
036D:  RRF    6A,F
036E:  INCF   77,F
036F:  BTFSC  03.2
0370:  GOTO   3FB
0371:  GOTO   37D
0372:  BTFSC  6D.7
0373:  GOTO   380
0374:  BCF    03.0
0375:  RLF    6A,F
0376:  RLF    6B,F
0377:  RLF    6C,F
0378:  RLF    6D,F
0379:  DECF   77,F
037A:  BTFSC  03.2
037B:  GOTO   3FB
037C:  GOTO   372
037D:  BSF    69.7
037E:  GOTO   3A8
037F:  BCF    69.7
0380:  MOVF   64,W
0381:  MOVWF  68
0382:  BTFSS  68.7
0383:  GOTO   386
0384:  BSF    6D.7
0385:  GOTO   3F4
0386:  BCF    6D.7
0387:  GOTO   3F4
0388:  MOVF   64,W
0389:  MOVWF  6D
038A:  BSF    6D.7
038B:  MOVF   65,W
038C:  MOVWF  6C
038D:  MOVF   66,W
038E:  MOVWF  6B
038F:  BTFSS  68.7
0390:  GOTO   395
0391:  BCF    6D.7
0392:  BSF    69.2
0393:  GOTO   400
0394:  BCF    69.2
0395:  CLRF   6A
0396:  BCF    67.0
0397:  MOVLW  62
0398:  MOVWF  04
0399:  BCF    03.7
039A:  GOTO   415
039B:  BTFSC  68.7
039C:  GOTO   3BE
039D:  MOVF   60,W
039E:  MOVWF  68
039F:  BTFSS  67.0
03A0:  GOTO   3A8
03A1:  RRF    6D,F
03A2:  RRF    6C,F
03A3:  RRF    6B,F
03A4:  RRF    6A,F
03A5:  INCF   77,F
03A6:  BTFSC  03.2
03A7:  GOTO   3FB
03A8:  BTFSS  6A.7
03A9:  GOTO   3B9
03AA:  INCF   6B,F
03AB:  BTFSS  03.2
03AC:  GOTO   3B9
03AD:  INCF   6C,F
03AE:  BTFSS  03.2
03AF:  GOTO   3B9
03B0:  INCF   6D,F
03B1:  BTFSS  03.2
03B2:  GOTO   3B9
03B3:  RRF    6D,F
03B4:  RRF    6C,F
03B5:  RRF    6B,F
03B6:  INCF   77,F
03B7:  BTFSC  03.2
03B8:  GOTO   3FB
03B9:  BTFSC  69.6
03BA:  GOTO   33D
03BB:  BTFSC  69.7
03BC:  GOTO   37F
03BD:  GOTO   3DD
03BE:  MOVLW  80
03BF:  XORWF  6D,F
03C0:  BTFSS  6D.7
03C1:  GOTO   3C6
03C2:  GOTO   400
03C3:  MOVF   64,W
03C4:  MOVWF  68
03C5:  GOTO   3D3
03C6:  MOVF   60,W
03C7:  MOVWF  68
03C8:  MOVF   6D,F
03C9:  BTFSS  03.2
03CA:  GOTO   3D3
03CB:  MOVF   6C,F
03CC:  BTFSS  03.2
03CD:  GOTO   3D3
03CE:  MOVF   6B,F
03CF:  BTFSS  03.2
03D0:  GOTO   3D3
03D1:  CLRF   77
03D2:  GOTO   3F4
03D3:  BTFSC  6D.7
03D4:  GOTO   3DD
03D5:  BCF    03.0
03D6:  RLF    6A,F
03D7:  RLF    6B,F
03D8:  RLF    6C,F
03D9:  RLF    6D,F
03DA:  DECFSZ 77,F
03DB:  GOTO   3D3
03DC:  GOTO   3FB
03DD:  BTFSS  68.7
03DE:  GOTO   3E1
03DF:  BSF    6D.7
03E0:  GOTO   3F4
03E1:  BCF    6D.7
03E2:  GOTO   3F4
03E3:  MOVF   63,W
03E4:  MOVWF  77
03E5:  MOVF   64,W
03E6:  MOVWF  6D
03E7:  MOVF   65,W
03E8:  MOVWF  6C
03E9:  MOVF   66,W
03EA:  MOVWF  6B
03EB:  GOTO   3F4
03EC:  MOVF   5F,W
03ED:  MOVWF  77
03EE:  MOVF   60,W
03EF:  MOVWF  6D
03F0:  MOVF   61,W
03F1:  MOVWF  6C
03F2:  MOVF   62,W
03F3:  MOVWF  6B
03F4:  MOVF   6D,W
03F5:  MOVWF  78
03F6:  MOVF   6C,W
03F7:  MOVWF  79
03F8:  MOVF   6B,W
03F9:  MOVWF  7A
03FA:  GOTO   433
03FB:  CLRF   77
03FC:  CLRF   78
03FD:  CLRF   79
03FE:  CLRF   7A
03FF:  GOTO   433
0400:  CLRF   6A
0401:  COMF   6B,F
0402:  COMF   6C,F
0403:  COMF   6D,F
0404:  COMF   6A,F
0405:  INCF   6A,F
0406:  BTFSS  03.2
0407:  GOTO   40E
0408:  INCF   6B,F
0409:  BTFSS  03.2
040A:  GOTO   40E
040B:  INCF   6C,F
040C:  BTFSC  03.2
040D:  INCF   6D,F
040E:  BTFSC  69.0
040F:  GOTO   31C
0410:  BTFSC  69.1
0411:  GOTO   35E
0412:  BTFSC  69.2
0413:  GOTO   394
0414:  GOTO   3C3
0415:  MOVF   00,W
0416:  ADDWF  6B,F
0417:  BTFSS  03.0
0418:  GOTO   41F
0419:  INCF   6C,F
041A:  BTFSS  03.2
041B:  GOTO   41F
041C:  INCF   6D,F
041D:  BTFSC  03.2
041E:  BSF    67.0
041F:  DECF   04,F
0420:  MOVF   00,W
0421:  ADDWF  6C,F
0422:  BTFSS  03.0
0423:  GOTO   427
0424:  INCF   6D,F
0425:  BTFSC  03.2
0426:  BSF    67.0
0427:  DECF   04,F
0428:  MOVF   00,W
0429:  BTFSS  00.7
042A:  XORLW  80
042B:  ADDWF  6D,F
042C:  BTFSC  03.0
042D:  BSF    67.0
042E:  BTFSC  69.4
042F:  GOTO   323
0430:  BTFSC  69.5
0431:  GOTO   365
0432:  GOTO   39B
*
044B:  MOVF   5F,W
044C:  BTFSC  03.2
044D:  GOTO   510
044E:  MOVWF  6B
044F:  MOVF   63,W
0450:  BTFSC  03.2
0451:  GOTO   510
0452:  SUBWF  6B,F
0453:  BTFSS  03.0
0454:  GOTO   45A
0455:  MOVLW  7F
0456:  ADDWF  6B,F
0457:  BTFSC  03.0
0458:  GOTO   510
0459:  GOTO   460
045A:  MOVLW  81
045B:  SUBWF  6B,F
045C:  BTFSS  03.0
045D:  GOTO   510
045E:  BTFSC  03.2
045F:  GOTO   510
0460:  MOVF   6B,W
0461:  MOVWF  77
0462:  CLRF   78
0463:  CLRF   79
0464:  CLRF   7A
0465:  CLRF   6A
0466:  MOVF   60,W
0467:  MOVWF  69
0468:  BSF    69.7
0469:  MOVF   61,W
046A:  MOVWF  68
046B:  MOVF   62,W
046C:  MOVWF  67
046D:  MOVLW  19
046E:  MOVWF  6B
046F:  MOVF   66,W
0470:  SUBWF  67,F
0471:  BTFSC  03.0
0472:  GOTO   483
0473:  MOVLW  01
0474:  SUBWF  68,F
0475:  BTFSC  03.0
0476:  GOTO   483
0477:  SUBWF  69,F
0478:  BTFSC  03.0
0479:  GOTO   483
047A:  SUBWF  6A,F
047B:  BTFSC  03.0
047C:  GOTO   483
047D:  INCF   6A,F
047E:  INCF   69,F
047F:  INCF   68,F
0480:  MOVF   66,W
0481:  ADDWF  67,F
0482:  GOTO   4B5
0483:  MOVF   65,W
0484:  SUBWF  68,F
0485:  BTFSC  03.0
0486:  GOTO   49E
0487:  MOVLW  01
0488:  SUBWF  69,F
0489:  BTFSC  03.0
048A:  GOTO   49E
048B:  SUBWF  6A,F
048C:  BTFSC  03.0
048D:  GOTO   49E
048E:  INCF   6A,F
048F:  INCF   69,F
0490:  MOVF   65,W
0491:  ADDWF  68,F
0492:  MOVF   66,W
0493:  ADDWF  67,F
0494:  BTFSS  03.0
0495:  GOTO   4B5
0496:  INCF   68,F
0497:  BTFSS  03.2
0498:  GOTO   4B5
0499:  INCF   69,F
049A:  BTFSS  03.2
049B:  GOTO   4B5
049C:  INCF   6A,F
049D:  GOTO   4B5
049E:  MOVF   64,W
049F:  IORLW  80
04A0:  SUBWF  69,F
04A1:  BTFSC  03.0
04A2:  GOTO   4B4
04A3:  MOVLW  01
04A4:  SUBWF  6A,F
04A5:  BTFSC  03.0
04A6:  GOTO   4B4
04A7:  INCF   6A,F
04A8:  MOVF   64,W
04A9:  IORLW  80
04AA:  ADDWF  69,F
04AB:  MOVF   65,W
04AC:  ADDWF  68,F
04AD:  BTFSS  03.0
04AE:  GOTO   492
04AF:  INCF   69,F
04B0:  BTFSS  03.2
04B1:  GOTO   492
04B2:  INCF   6A,F
04B3:  GOTO   492
04B4:  BSF    7A.0
04B5:  DECFSZ 6B,F
04B6:  GOTO   4B8
04B7:  GOTO   4C3
04B8:  BCF    03.0
04B9:  RLF    67,F
04BA:  RLF    68,F
04BB:  RLF    69,F
04BC:  RLF    6A,F
04BD:  BCF    03.0
04BE:  RLF    7A,F
04BF:  RLF    79,F
04C0:  RLF    78,F
04C1:  RLF    6C,F
04C2:  GOTO   46F
04C3:  BTFSS  6C.0
04C4:  GOTO   4CB
04C5:  BCF    03.0
04C6:  RRF    78,F
04C7:  RRF    79,F
04C8:  RRF    7A,F
04C9:  RRF    6C,F
04CA:  GOTO   4CE
04CB:  DECF   77,F
04CC:  BTFSC  03.2
04CD:  GOTO   510
04CE:  BTFSC  6C.7
04CF:  GOTO   4F7
04D0:  BCF    03.0
04D1:  RLF    67,F
04D2:  RLF    68,F
04D3:  RLF    69,F
04D4:  RLF    6A,F
04D5:  MOVF   66,W
04D6:  SUBWF  67,F
04D7:  BTFSC  03.0
04D8:  GOTO   4E3
04D9:  MOVLW  01
04DA:  SUBWF  68,F
04DB:  BTFSC  03.0
04DC:  GOTO   4E3
04DD:  SUBWF  69,F
04DE:  BTFSC  03.0
04DF:  GOTO   4E3
04E0:  SUBWF  6A,F
04E1:  BTFSS  03.0
04E2:  GOTO   506
04E3:  MOVF   65,W
04E4:  SUBWF  68,F
04E5:  BTFSC  03.0
04E6:  GOTO   4EE
04E7:  MOVLW  01
04E8:  SUBWF  69,F
04E9:  BTFSC  03.0
04EA:  GOTO   4EE
04EB:  SUBWF  6A,F
04EC:  BTFSS  03.0
04ED:  GOTO   506
04EE:  MOVF   64,W
04EF:  IORLW  80
04F0:  SUBWF  69,F
04F1:  BTFSC  03.0
04F2:  GOTO   4F7
04F3:  MOVLW  01
04F4:  SUBWF  6A,F
04F5:  BTFSS  03.0
04F6:  GOTO   506
04F7:  INCF   7A,F
04F8:  BTFSS  03.2
04F9:  GOTO   506
04FA:  INCF   79,F
04FB:  BTFSS  03.2
04FC:  GOTO   506
04FD:  INCF   78,F
04FE:  BTFSS  03.2
04FF:  GOTO   506
0500:  INCF   77,F
0501:  BTFSC  03.2
0502:  GOTO   510
0503:  RRF    78,F
0504:  RRF    79,F
0505:  RRF    7A,F
0506:  MOVF   60,W
0507:  MOVWF  6B
0508:  MOVF   64,W
0509:  XORWF  6B,F
050A:  BTFSS  6B.7
050B:  GOTO   50E
050C:  BSF    78.7
050D:  GOTO   514
050E:  BCF    78.7
050F:  GOTO   514
0510:  CLRF   77
0511:  CLRF   78
0512:  CLRF   79
0513:  CLRF   7A
*
0517:  BTFSC  03.1
0518:  GOTO   51C
0519:  MOVLW  70
051A:  MOVWF  04
051B:  BCF    03.7
051C:  CLRF   77
051D:  CLRF   78
051E:  CLRF   79
051F:  CLRF   7A
0520:  CLRF   70
0521:  CLRF   71
0522:  CLRF   72
0523:  CLRF   73
0524:  MOVF   6F,W
0525:  IORWF  6E,W
0526:  IORWF  6D,W
0527:  IORWF  6C,W
0528:  BTFSC  03.2
0529:  GOTO   55A
052A:  MOVLW  20
052B:  MOVWF  74
052C:  BCF    03.0
052D:  RLF    68,F
052E:  RLF    69,F
052F:  RLF    6A,F
0530:  RLF    6B,F
0531:  RLF    70,F
0532:  RLF    71,F
0533:  RLF    72,F
0534:  RLF    73,F
0535:  MOVF   6F,W
0536:  SUBWF  73,W
0537:  BTFSS  03.2
0538:  GOTO   543
0539:  MOVF   6E,W
053A:  SUBWF  72,W
053B:  BTFSS  03.2
053C:  GOTO   543
053D:  MOVF   6D,W
053E:  SUBWF  71,W
053F:  BTFSS  03.2
0540:  GOTO   543
0541:  MOVF   6C,W
0542:  SUBWF  70,W
0543:  BTFSS  03.0
0544:  GOTO   554
0545:  MOVF   6C,W
0546:  SUBWF  70,F
0547:  MOVF   6D,W
0548:  BTFSS  03.0
0549:  INCFSZ 6D,W
054A:  SUBWF  71,F
054B:  MOVF   6E,W
054C:  BTFSS  03.0
054D:  INCFSZ 6E,W
054E:  SUBWF  72,F
054F:  MOVF   6F,W
0550:  BTFSS  03.0
0551:  INCFSZ 6F,W
0552:  SUBWF  73,F
0553:  BSF    03.0
0554:  RLF    77,F
0555:  RLF    78,F
0556:  RLF    79,F
0557:  RLF    7A,F
0558:  DECFSZ 74,F
0559:  GOTO   52C
055A:  MOVF   70,W
055B:  MOVWF  00
055C:  INCF   04,F
055D:  MOVF   71,W
055E:  MOVWF  00
055F:  INCF   04,F
0560:  MOVF   72,W
0561:  MOVWF  00
0562:  INCF   04,F
0563:  MOVF   73,W
0564:  MOVWF  00
0565:  RETURN
0566:  MOVF   04,W
0567:  MOVWF  60
0568:  MOVF   5F,W
0569:  MOVWF  62
056A:  BTFSC  03.2
056B:  GOTO   5F8
056C:  MOVF   5E,W
056D:  MOVWF  6B
056E:  MOVF   5D,W
056F:  MOVWF  6A
0570:  MOVF   5C,W
0571:  MOVWF  69
0572:  MOVF   5B,W
0573:  MOVWF  68
0574:  CLRF   6F
0575:  CLRF   6E
0576:  MOVLW  20
0577:  MOVWF  6D
0578:  MOVLW  82
0579:  MOVWF  6C
057A:  MOVF   68,W
057B:  BTFSC  03.2
057C:  GOTO   5EA
057D:  MOVWF  70
057E:  MOVF   6C,W
057F:  BTFSC  03.2
0580:  GOTO   5EA
0581:  ADDWF  70,F
0582:  BTFSC  03.0
0583:  GOTO   58B
0584:  MOVLW  7F
0585:  SUBWF  70,F
0586:  BTFSS  03.0
0587:  GOTO   5EA
0588:  BTFSC  03.2
0589:  GOTO   5EA
058A:  GOTO   58F
058B:  MOVLW  81
058C:  ADDWF  70,F
058D:  BTFSC  03.0
058E:  GOTO   5EA
058F:  MOVF   70,W
0590:  MOVWF  77
0591:  CLRF   78
0592:  CLRF   79
0593:  CLRF   7A
0594:  MOVF   69,W
0595:  MOVWF  74
0596:  BSF    74.7
0597:  MOVF   6A,W
0598:  MOVWF  73
0599:  MOVF   6B,W
059A:  MOVWF  72
059B:  MOVLW  18
059C:  MOVWF  70
059D:  CLRF   71
059E:  BTFSS  72.0
059F:  GOTO   5B8
05A0:  MOVF   6F,W
05A1:  ADDWF  7A,F
05A2:  BTFSS  03.0
05A3:  GOTO   5AA
05A4:  INCF   79,F
05A5:  BTFSS  03.2
05A6:  GOTO   5AA
05A7:  INCF   78,F
05A8:  BTFSC  03.2
05A9:  BSF    71.7
05AA:  MOVF   6E,W
05AB:  ADDWF  79,F
05AC:  BTFSS  03.0
05AD:  GOTO   5B1
05AE:  INCF   78,F
05AF:  BTFSC  03.2
05B0:  BSF    71.7
05B1:  MOVF   6D,W
05B2:  MOVWF  6A
05B3:  BSF    6A.7
05B4:  MOVF   6A,W
05B5:  ADDWF  78,F
05B6:  BTFSC  03.0
05B7:  BSF    71.7
05B8:  RLF    71,F
05B9:  RRF    78,F
05BA:  RRF    79,F
05BB:  RRF    7A,F
05BC:  RRF    74,F
05BD:  RRF    73,F
05BE:  RRF    72,F
05BF:  BCF    03.0
05C0:  DECFSZ 70,F
05C1:  GOTO   59D
05C2:  MOVLW  01
05C3:  ADDWF  77,F
05C4:  BTFSC  03.0
05C5:  GOTO   5EA
05C6:  BTFSC  78.7
05C7:  GOTO   5CF
05C8:  RLF    74,F
05C9:  RLF    7A,F
05CA:  RLF    79,F
05CB:  RLF    78,F
05CC:  DECF   77,F
05CD:  BTFSC  03.2
05CE:  GOTO   5EA
05CF:  BTFSS  74.7
05D0:  GOTO   5E0
05D1:  INCF   7A,F
05D2:  BTFSS  03.2
05D3:  GOTO   5E0
05D4:  INCF   79,F
05D5:  BTFSS  03.2
05D6:  GOTO   5E0
05D7:  INCF   78,F
05D8:  BTFSS  03.2
05D9:  GOTO   5E0
05DA:  RRF    78,F
05DB:  RRF    79,F
05DC:  RRF    7A,F
05DD:  INCF   77,F
05DE:  BTFSC  03.2
05DF:  GOTO   5EA
05E0:  MOVF   69,W
05E1:  MOVWF  71
05E2:  MOVF   6D,W
05E3:  XORWF  71,F
05E4:  BTFSS  71.7
05E5:  GOTO   5E8
05E6:  BSF    78.7
05E7:  GOTO   5EE
05E8:  BCF    78.7
05E9:  GOTO   5EE
05EA:  CLRF   77
05EB:  CLRF   78
05EC:  CLRF   79
05ED:  CLRF   7A
05EE:  MOVF   7A,W
05EF:  MOVWF  5E
05F0:  MOVF   79,W
05F1:  MOVWF  5D
05F2:  MOVF   78,W
05F3:  MOVWF  5C
05F4:  MOVF   77,W
05F5:  MOVWF  5B
05F6:  DECFSZ 62,F
05F7:  GOTO   56C
05F8:  MOVF   5E,W
05F9:  MOVWF  6B
05FA:  MOVF   5D,W
05FB:  MOVWF  6A
05FC:  MOVF   5C,W
05FD:  MOVWF  69
05FE:  MOVF   5B,W
05FF:  MOVWF  68
0600:  MOVF   68,W
0601:  SUBLW  B6
0602:  MOVWF  68
0603:  CLRF   7A
0604:  MOVF   69,W
0605:  MOVWF  6C
0606:  BSF    69.7
0607:  BCF    03.0
0608:  RRF    69,F
0609:  RRF    6A,F
060A:  RRF    6B,F
060B:  RRF    7A,F
060C:  RRF    79,F
060D:  RRF    78,F
060E:  RRF    77,F
060F:  DECFSZ 68,F
0610:  GOTO   607
0611:  BTFSS  6C.7
0612:  GOTO   61E
0613:  COMF   77,F
0614:  COMF   78,F
0615:  COMF   79,F
0616:  COMF   7A,F
0617:  INCF   77,F
0618:  BTFSC  03.2
0619:  INCF   78,F
061A:  BTFSC  03.2
061B:  INCF   79,F
061C:  BTFSC  03.2
061D:  INCF   7A,F
061E:  MOVF   7A,W
061F:  MOVWF  5E
0620:  MOVF   79,W
0621:  MOVWF  5D
0622:  MOVF   78,W
0623:  MOVWF  5C
0624:  MOVF   77,W
0625:  MOVWF  5B
0626:  BTFSS  5E.7
0627:  GOTO   635
0628:  DECF   60,F
0629:  BSF    60.5
062A:  COMF   5B,F
062B:  COMF   5C,F
062C:  COMF   5D,F
062D:  COMF   5E,F
062E:  INCF   5B,F
062F:  BTFSC  03.2
0630:  INCF   5C,F
0631:  BTFSC  03.2
0632:  INCF   5D,F
0633:  BTFSC  03.2
0634:  INCF   5E,F
0635:  MOVLW  3B
0636:  MOVWF  67
0637:  MOVLW  9A
0638:  MOVWF  66
0639:  MOVLW  CA
063A:  MOVWF  65
063B:  CLRF   64
063C:  MOVLW  0A
063D:  MOVWF  62
063E:  MOVF   5F,W
063F:  BTFSC  03.2
0640:  INCF   60,F
0641:  BSF    03.1
0642:  MOVLW  5B
0643:  MOVWF  04
0644:  BCF    03.7
0645:  MOVF   5E,W
0646:  MOVWF  6B
0647:  MOVF   5D,W
0648:  MOVWF  6A
0649:  MOVF   5C,W
064A:  MOVWF  69
064B:  MOVF   5B,W
064C:  MOVWF  68
064D:  MOVF   67,W
064E:  MOVWF  6F
064F:  MOVF   66,W
0650:  MOVWF  6E
0651:  MOVF   65,W
0652:  MOVWF  6D
0653:  MOVF   64,W
0654:  MOVWF  6C
0655:  CALL   517
0656:  MOVF   78,W
0657:  MOVF   77,F
0658:  BTFSS  03.2
0659:  GOTO   66D
065A:  INCF   5F,W
065B:  SUBWF  62,W
065C:  BTFSC  03.2
065D:  GOTO   66D
065E:  MOVF   60,W
065F:  BTFSC  03.2
0660:  GOTO   66F
0661:  ANDLW  0F
0662:  SUBWF  62,W
0663:  BTFSC  03.2
0664:  GOTO   667
0665:  BTFSC  03.0
0666:  GOTO   69F
0667:  BTFSC  60.7
0668:  GOTO   69F
0669:  BTFSC  60.6
066A:  GOTO   66F
066B:  MOVLW  20
066C:  GOTO   69B
066D:  MOVLW  20
066E:  ANDWF  60,F
066F:  BTFSS  60.5
0670:  GOTO   67D
0671:  BCF    60.5
0672:  MOVF   5F,W
0673:  BTFSS  03.2
0674:  DECF   60,F
0675:  MOVF   77,W
0676:  MOVWF  60
0677:  MOVLW  2D
0678:  MOVWF  68
0679:  CALL   1B1
067A:  MOVF   60,W
067B:  MOVWF  77
067C:  CLRF   60
067D:  MOVF   5F,W
067E:  SUBWF  62,W
067F:  BTFSS  03.2
0680:  GOTO   68B
0681:  MOVF   77,W
0682:  MOVWF  60
0683:  MOVLW  2E
0684:  MOVWF  68
0685:  CALL   1B1
0686:  MOVF   60,W
0687:  MOVWF  77
0688:  MOVLW  20
0689:  ANDWF  60,F
068A:  MOVLW  00
068B:  MOVLW  30
068C:  BTFSS  60.5
068D:  GOTO   69B
068E:  BCF    60.5
068F:  MOVF   5F,W
0690:  BTFSS  03.2
0691:  DECF   60,F
0692:  MOVF   77,W
0693:  MOVWF  60
0694:  MOVLW  2D
0695:  MOVWF  68
0696:  CALL   1B1
0697:  MOVF   60,W
0698:  MOVWF  77
0699:  CLRF   60
069A:  MOVLW  30
069B:  ADDWF  77,F
069C:  MOVF   77,W
069D:  MOVWF  68
069E:  CALL   1B1
069F:  BCF    03.1
06A0:  MOVF   67,W
06A1:  MOVWF  6B
06A2:  MOVF   66,W
06A3:  MOVWF  6A
06A4:  MOVF   65,W
06A5:  MOVWF  69
06A6:  MOVF   64,W
06A7:  MOVWF  68
06A8:  CLRF   6F
06A9:  CLRF   6E
06AA:  CLRF   6D
06AB:  MOVLW  0A
06AC:  MOVWF  6C
06AD:  CALL   517
06AE:  MOVF   7A,W
06AF:  MOVWF  67
06B0:  MOVF   79,W
06B1:  MOVWF  66
06B2:  MOVF   78,W
06B3:  MOVWF  65
06B4:  MOVF   77,W
06B5:  MOVWF  64
06B6:  DECFSZ 62,F
06B7:  GOTO   641
06B8:  BSF    0A.3
06B9:  BCF    0A.4
06BA:  GOTO   108 (RETURN)
*
0722:  BSF    0A.0
0723:  BSF    0A.1
0724:  BSF    0A.2
0725:  ADDWF  02,F
0726:  GOTO   6C7
0727:  GOTO   6CD
0728:  GOTO   6D3
0729:  GOTO   6D9
*
0B64:  BSF    0A.0
0B65:  BSF    0A.1
0B66:  BCF    0A.2
0B67:  ADDWF  02,F
0B68:  GOTO   086
0B69:  GOTO   0AB
0B6A:  GOTO   362
0B6B:  GOTO   1DC
0B6C:  GOTO   246
0B6D:  GOTO   2C1
0B6E:  GOTO   30B
....................  
.................... #list 
....................  
....................  
....................  
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOPUT,NOLVP,BROWNOUT 
.................... #use delay(clock=4M) 
*
0065:  MOVLW  69
0066:  MOVWF  04
0067:  BCF    03.7
0068:  MOVF   00,W
0069:  BTFSC  03.2
006A:  GOTO   079
006B:  MOVLW  01
006C:  MOVWF  78
006D:  CLRF   77
006E:  DECFSZ 77,F
006F:  GOTO   06E
0070:  DECFSZ 78,F
0071:  GOTO   06D
0072:  MOVLW  4A
0073:  MOVWF  77
0074:  DECFSZ 77,F
0075:  GOTO   074
0076:  GOTO   077
0077:  DECFSZ 00,F
0078:  GOTO   06B
0079:  RETURN
.................... #use standard_io(D) 
.................... #use standard_io(C) 
.................... #use fast_io(A) 
....................  
....................  
....................  
....................  
....................    #define TC_CLK     PIN_C3            //edit these pins as necessary  
....................    #define TC_CS      PIN_C0  
....................    #define TC_DATA    PIN_C4  
....................  
....................  
.................... #define LCD_DB4  PIN_D4                     // Pines de la pantalla LCD 2004 
.................... #define LCD_DB5  PIN_D5 
.................... #define LCD_DB6  PIN_D6 
.................... #define LCD_DB7  PIN_D7 
.................... #define LCD_RS   PIN_D2 
.................... #define LCD_E    PIN_D3 
....................  
....................  
.................... #include <LCD_20X4.c>                       // Libreria para el manejo de la LCD 20x4 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... //#define USE_RW_PIN   1 
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
007A:  BTFSC  70.0
007B:  GOTO   07E
007C:  BCF    08.4
007D:  GOTO   07F
007E:  BSF    08.4
007F:  BSF    03.5
0080:  BCF    08.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0081:  BTFSC  70.1
0082:  GOTO   087
0083:  BCF    03.5
0084:  BCF    08.5
0085:  GOTO   089
0086:  BSF    03.5
0087:  BCF    03.5
0088:  BSF    08.5
0089:  BSF    03.5
008A:  BCF    08.5
....................  output_bit(LCD_DB6, !!(nibble & 4));     
008B:  BTFSC  70.2
008C:  GOTO   091
008D:  BCF    03.5
008E:  BCF    08.6
008F:  GOTO   093
0090:  BSF    03.5
0091:  BCF    03.5
0092:  BSF    08.6
0093:  BSF    03.5
0094:  BCF    08.6
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0095:  BTFSC  70.3
0096:  GOTO   09B
0097:  BCF    03.5
0098:  BCF    08.7
0099:  GOTO   09D
009A:  BSF    03.5
009B:  BCF    03.5
009C:  BSF    08.7
009D:  BSF    03.5
009E:  BCF    08.7
....................  
....................  delay_cycles(1);  
009F:  NOP
....................  output_high(LCD_E);  
00A0:  BCF    08.3
00A1:  BCF    03.5
00A2:  BSF    08.3
....................  delay_us(2);  
00A3:  GOTO   0A4
....................  output_low(LCD_E);  
00A4:  BSF    03.5
00A5:  BCF    08.3
00A6:  BCF    03.5
00A7:  BCF    08.3
00A8:  RETURN
.................... }  
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
00A9:  BSF    03.5
00AA:  BCF    08.2
00AB:  BCF    03.5
00AC:  BCF    08.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
00AD:  MOVLW  13
00AE:  MOVWF  77
00AF:  DECFSZ 77,F
00B0:  GOTO   0AF
00B1:  GOTO   0B2
.................... #endif  
....................  
.................... if(address)  
00B2:  MOVF   6D,F
00B3:  BTFSC  03.2
00B4:  GOTO   0BA
....................    output_high(LCD_RS);  
00B5:  BSF    03.5
00B6:  BCF    08.2
00B7:  BCF    03.5
00B8:  BSF    08.2
00B9:  GOTO   0BE
.................... else  
....................    output_low(LCD_RS);  
00BA:  BSF    03.5
00BB:  BCF    08.2
00BC:  BCF    03.5
00BD:  BCF    08.2
....................        
....................  delay_cycles(1);  
00BE:  NOP
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
00BF:  BSF    03.5
00C0:  BCF    08.3
00C1:  BCF    03.5
00C2:  BCF    08.3
....................  
.................... lcd_send_nibble(n >> 4);  
00C3:  SWAPF  6E,W
00C4:  MOVWF  6F
00C5:  MOVLW  0F
00C6:  ANDWF  6F,F
00C7:  MOVF   6F,W
00C8:  MOVWF  70
00C9:  CALL   07A
.................... lcd_send_nibble(n & 0xf);  
00CA:  MOVF   6E,W
00CB:  ANDLW  0F
00CC:  MOVWF  6F
00CD:  MOVWF  70
00CE:  CALL   07A
00CF:  RETURN
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... lcd_line = 1;  
00D0:  MOVLW  01
00D1:  MOVWF  21
....................  
.................... output_low(LCD_RS);  
00D2:  BSF    03.5
00D3:  BCF    08.2
00D4:  BCF    03.5
00D5:  BCF    08.2
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
00D6:  BSF    03.5
00D7:  BCF    08.3
00D8:  BCF    03.5
00D9:  BCF    08.3
....................  
.................... // Some LCDs require 15 ms minimum delay after  
.................... // power-up.  Others require 30 ms.  I'm going  
.................... // to set it to 35 ms, so it should work with  
.................... // all of them.  
.................... delay_ms(35);           
00DA:  MOVLW  23
00DB:  MOVWF  69
00DC:  CALL   065
....................  
.................... for(i=0 ;i < 3; i++)  
00DD:  CLRF   57
00DE:  MOVF   57,W
00DF:  SUBLW  02
00E0:  BTFSS  03.0
00E1:  GOTO   0EA
....................    {  
....................     lcd_send_nibble(0x03);  
00E2:  MOVLW  03
00E3:  MOVWF  70
00E4:  CALL   07A
....................     delay_ms(5);  
00E5:  MOVLW  05
00E6:  MOVWF  69
00E7:  CALL   065
00E8:  INCF   57,F
00E9:  GOTO   0DE
....................    }  
....................  
.................... lcd_send_nibble(0x02);  
00EA:  MOVLW  02
00EB:  MOVWF  70
00EC:  CALL   07A
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00ED:  CLRF   57
00EE:  MOVF   57,W
00EF:  SUBLW  03
00F0:  BTFSS  03.0
00F1:  GOTO   0FE
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
00F2:  MOVF   57,W
00F3:  CALL   004
00F4:  MOVWF  58
00F5:  CLRF   6D
00F6:  MOVF   58,W
00F7:  MOVWF  6E
00F8:  CALL   0A9
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 50 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_RW_PIN  
....................     delay_ms(5);  
00F9:  MOVLW  05
00FA:  MOVWF  69
00FB:  CALL   065
....................     #endif  
00FC:  INCF   57,F
00FD:  GOTO   0EE
....................    }  
00FE:  BSF    0A.3
00FF:  BCF    0A.4
0100:  GOTO   04E (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
018C:  MOVF   6A,W
018D:  XORLW  01
018E:  BTFSC  03.2
018F:  GOTO   19A
0190:  XORLW  03
0191:  BTFSC  03.2
0192:  GOTO   19C
0193:  XORLW  01
0194:  BTFSC  03.2
0195:  GOTO   19F
0196:  XORLW  07
0197:  BTFSC  03.2
0198:  GOTO   1A2
0199:  GOTO   1A5
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
019A:  CLRF   6B
....................      break;  
019B:  GOTO   1A6
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
019C:  MOVLW  40
019D:  MOVWF  6B
....................      break;  
019E:  GOTO   1A6
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
019F:  MOVLW  14
01A0:  MOVWF  6B
....................      break;  
01A1:  GOTO   1A6
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
01A2:  MOVLW  54
01A3:  MOVWF  6B
....................      break;  
01A4:  GOTO   1A6
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
01A5:  CLRF   6B
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
01A6:  MOVLW  01
01A7:  SUBWF  69,W
01A8:  ADDWF  6B,F
.................... lcd_send_byte(0, 0x80 | address);  
01A9:  MOVF   6B,W
01AA:  IORLW  80
01AB:  MOVWF  6C
01AC:  CLRF   6D
01AD:  MOVF   6C,W
01AE:  MOVWF  6E
01AF:  CALL   0A9
01B0:  RETURN
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
01B1:  MOVF   68,W
01B2:  XORLW  0C
01B3:  BTFSC  03.2
01B4:  GOTO   1BC
01B5:  XORLW  06
01B6:  BTFSC  03.2
01B7:  GOTO   1C6
01B8:  XORLW  02
01B9:  BTFSC  03.2
01BA:  GOTO   1CD
01BB:  GOTO   1D2
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
01BC:  CLRF   6D
01BD:  MOVLW  01
01BE:  MOVWF  6E
01BF:  CALL   0A9
....................       lcd_line = 1;  
01C0:  MOVLW  01
01C1:  MOVWF  21
....................       delay_ms(2);  
01C2:  MOVLW  02
01C3:  MOVWF  69
01C4:  CALL   065
....................       break;  
01C5:  GOTO   1D7
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
01C6:  INCF   21,F
01C7:  MOVLW  01
01C8:  MOVWF  69
01C9:  MOVF   21,W
01CA:  MOVWF  6A
01CB:  CALL   18C
....................        break;  
01CC:  GOTO   1D7
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
01CD:  CLRF   6D
01CE:  MOVLW  10
01CF:  MOVWF  6E
01D0:  CALL   0A9
....................        break;  
01D1:  GOTO   1D7
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
01D2:  MOVLW  01
01D3:  MOVWF  6D
01D4:  MOVF   68,W
01D5:  MOVWF  6E
01D6:  CALL   0A9
....................        break;  
....................    }  
01D7:  RETURN
.................... } 
....................  
.................... void lcd_clear() 
.................... { 
....................    lcd_putc("\f"); 
.................... } 
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... void send_D7_D4(int8 address_lcd,int8 nibble_lcd) 
.................... {   
....................   if((nibble_lcd & 1)==1) output_high(LCD_DB4); else output_low(LCD_DB4); 
*
0104:  MOVF   5F,W
0105:  ANDLW  01
0106:  SUBLW  01
0107:  BTFSS  03.2
0108:  GOTO   10E
0109:  BSF    03.5
010A:  BCF    08.4
010B:  BCF    03.5
010C:  BSF    08.4
010D:  GOTO   112
010E:  BSF    03.5
010F:  BCF    08.4
0110:  BCF    03.5
0111:  BCF    08.4
....................   if((nibble_lcd & 2)==2) output_high(LCD_DB5); else output_low(LCD_DB5); 
0112:  MOVF   5F,W
0113:  ANDLW  02
0114:  SUBLW  02
0115:  BTFSS  03.2
0116:  GOTO   11C
0117:  BSF    03.5
0118:  BCF    08.5
0119:  BCF    03.5
011A:  BSF    08.5
011B:  GOTO   120
011C:  BSF    03.5
011D:  BCF    08.5
011E:  BCF    03.5
011F:  BCF    08.5
....................   if((nibble_lcd & 4)==4) output_high(LCD_DB6); else output_low(LCD_DB6); 
0120:  MOVF   5F,W
0121:  ANDLW  04
0122:  SUBLW  04
0123:  BTFSS  03.2
0124:  GOTO   12A
0125:  BSF    03.5
0126:  BCF    08.6
0127:  BCF    03.5
0128:  BSF    08.6
0129:  GOTO   12E
012A:  BSF    03.5
012B:  BCF    08.6
012C:  BCF    03.5
012D:  BCF    08.6
....................   if((nibble_lcd & 8)==8) output_high(LCD_DB7); else output_low(LCD_DB7); 
012E:  MOVF   5F,W
012F:  ANDLW  08
0130:  SUBLW  08
0131:  BTFSS  03.2
0132:  GOTO   138
0133:  BSF    03.5
0134:  BCF    08.7
0135:  BCF    03.5
0136:  BSF    08.7
0137:  GOTO   13C
0138:  BSF    03.5
0139:  BCF    08.7
013A:  BCF    03.5
013B:  BCF    08.7
....................    delay_us(60); 
013C:  MOVLW  13
013D:  MOVWF  77
013E:  DECFSZ 77,F
013F:  GOTO   13E
0140:  GOTO   141
....................    if(address_lcd) 
0141:  MOVF   5E,F
0142:  BTFSC  03.2
0143:  GOTO   149
....................      output_high(LCD_RS); 
0144:  BSF    03.5
0145:  BCF    08.2
0146:  BCF    03.5
0147:  BSF    08.2
0148:  GOTO   14D
....................        
....................    else 
....................      output_low(LCD_RS);  
0149:  BSF    03.5
014A:  BCF    08.2
014B:  BCF    03.5
014C:  BCF    08.2
....................        
....................  output_high(LCD_E); 
014D:  BSF    03.5
014E:  BCF    08.3
014F:  BCF    03.5
0150:  BSF    08.3
....................  delay_us(2); 
0151:  GOTO   152
....................  output_low(LCD_E); 
0152:  BSF    03.5
0153:  BCF    08.3
0154:  BCF    03.5
0155:  BCF    08.3
0156:  RETURN
.................... } 
....................  
.................... void send_byte_data(int8 address_lcd, int8 n) 
.................... { 
....................    send_D7_D4(address_lcd,n >> 4); 
0157:  SWAPF  5C,W
0158:  MOVWF  5D
0159:  MOVLW  0F
015A:  ANDWF  5D,F
015B:  MOVF   5B,W
015C:  MOVWF  5E
015D:  MOVF   5D,W
015E:  MOVWF  5F
015F:  CALL   104
....................    send_D7_D4(address_lcd,n & 0xf); 
0160:  MOVF   5C,W
0161:  ANDLW  0F
0162:  MOVWF  5D
0163:  MOVF   5B,W
0164:  MOVWF  5E
0165:  MOVF   5D,W
0166:  MOVWF  5F
0167:  CALL   104
0168:  RETURN
.................... } 
....................  
.................... void CGRAM_putc(int8 n) 
.................... { 
....................    send_byte_data(1,n); 
*
01D8:  MOVLW  01
01D9:  MOVWF  5B
01DA:  MOVF   57,W
01DB:  MOVWF  5C
01DC:  CALL   157
01DD:  RETURN
.................... } 
....................  
.................... void CGRAM_position(int p) 
.................... { 
....................   send_byte_data(0,0x40+p*8); 
*
0169:  RLF    57,W
016A:  MOVWF  77
016B:  RLF    77,F
016C:  RLF    77,F
016D:  MOVLW  F8
016E:  ANDWF  77,F
016F:  MOVF   77,W
0170:  ADDLW  40
0171:  MOVWF  58
0172:  CLRF   5B
0173:  MOVF   58,W
0174:  MOVWF  5C
0175:  CALL   157
0176:  RETURN
.................... } 
....................  
.................... void CGRAM_create_char(char* new_char) 
.................... { 
....................   for(int cg=0; cg<=7;cg++) 
0177:  CLRF   59
0178:  MOVF   59,W
0179:  SUBLW  07
017A:  BTFSS  03.0
017B:  GOTO   18B
....................   { 
....................     send_byte_data(1,new_char[cg]); 
017C:  MOVF   59,W
017D:  ADDWF  57,W
017E:  MOVWF  04
017F:  BCF    03.7
0180:  BTFSC  58.0
0181:  BSF    03.7
0182:  MOVF   00,W
0183:  MOVWF  5A
0184:  MOVLW  01
0185:  MOVWF  5B
0186:  MOVF   5A,W
0187:  MOVWF  5C
0188:  CALL   157
0189:  INCF   59,F
018A:  GOTO   178
....................   } 
018B:  RETURN
.................... } 
....................  
.................... #include <math.h>                            // libreria mate 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <kbd4x4.c>           // libreria teclado 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     KBD_LIB.C by Redraven                         //// 
.................... ////                                                                   //// 
.................... ////                     Derived from KBDD.C                           //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81              // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83              // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                  // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B0) 
....................  
.................... #define COL0 (1 << 0) // PIN_B0 
.................... #define COL1 (1 << 1) // PIN_B1 
.................... #define COL2 (1 << 2) // PIN_B2 
.................... #define COL3 (1 << 3) // PIN_B3 
....................  
.................... #define ROW0 (1 << 4) // PIN_B4 
.................... #define ROW1 (1 << 5) // PIN_B5 
.................... #define ROW2 (1 << 6) // PIN_B6 
.................... #define ROW3 (1 << 7) // PIN_B7 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
.................... void kbd_init() { 
*
0101:  BSF    0A.3
0102:  BCF    0A.4
0103:  GOTO   051 (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static byte kbd_call_count; 
*
0816:  BCF    03.5
0817:  CLRF   22
....................    static short int kbd_down; 
0818:  BCF    23.0
....................    static char last_key; 
0819:  CLRF   24
....................    static byte col; 
081A:  CLRF   25
....................  
....................    byte kchar; 
....................    byte row; 
....................  
....................    kchar='\0'; 
*
06BB:  CLRF   57
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
06BC:  INCF   22,F
06BD:  MOVF   22,W
06BE:  SUBLW  21
06BF:  BTFSC  03.0
06C0:  GOTO   71B
....................        switch (col) { 
06C1:  MOVF   25,W
06C2:  ADDLW  FC
06C3:  BTFSC  03.0
06C4:  GOTO   6DE
06C5:  ADDLW  04
06C6:  GOTO   722
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
06C7:  MOVLW  FE
06C8:  BSF    03.5
06C9:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
06CA:  BCF    03.5
06CB:  MOVWF  06
....................                     break; 
06CC:  GOTO   6DE
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
06CD:  MOVLW  FD
06CE:  BSF    03.5
06CF:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
06D0:  BCF    03.5
06D1:  MOVWF  06
....................                     break; 
06D2:  GOTO   6DE
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
06D3:  MOVLW  FB
06D4:  BSF    03.5
06D5:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
06D6:  BCF    03.5
06D7:  MOVWF  06
....................                     break; 
06D8:  GOTO   6DE
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3); 
06D9:  MOVLW  F7
06DA:  BSF    03.5
06DB:  MOVWF  06
....................                     kbd=~COL3&ALL_PINS; 
06DC:  BCF    03.5
06DD:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
06DE:  BTFSS  23.0
06DF:  GOTO   6EA
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
06E0:  MOVF   06,W
06E1:  ANDLW  F0
06E2:  SUBLW  F0
06E3:  BTFSS  03.2
06E4:  GOTO   6E9
....................            kbd_down=false; 
06E5:  BCF    23.0
....................            kchar=last_key; 
06E6:  MOVF   24,W
06E7:  MOVWF  57
....................            last_key='\0'; 
06E8:  CLRF   24
....................          } 
....................        } else { 
06E9:  GOTO   71A
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
06EA:  MOVF   06,W
06EB:  ANDLW  F0
06EC:  SUBLW  F0
06ED:  BTFSC  03.2
06EE:  GOTO   715
....................              if((kbd & ROW0)==0) 
06EF:  MOVF   06,W
06F0:  ANDLW  10
06F1:  BTFSS  03.2
06F2:  GOTO   6F5
....................                row=0; 
06F3:  CLRF   58
06F4:  GOTO   709
....................              else if((kbd & ROW1)==0) 
06F5:  MOVF   06,W
06F6:  ANDLW  20
06F7:  BTFSS  03.2
06F8:  GOTO   6FC
....................                row=1; 
06F9:  MOVLW  01
06FA:  MOVWF  58
06FB:  GOTO   709
....................              else if((kbd & ROW2)==0) 
06FC:  MOVF   06,W
06FD:  ANDLW  40
06FE:  BTFSS  03.2
06FF:  GOTO   703
....................                row=2; 
0700:  MOVLW  02
0701:  MOVWF  58
0702:  GOTO   709
....................              else if((kbd & ROW3)==0) 
0703:  MOVF   06,W
0704:  ANDLW  80
0705:  BTFSS  03.2
0706:  GOTO   709
....................                row=3; 
0707:  MOVLW  03
0708:  MOVWF  58
....................              last_key =KEYS[row][col]; 
0709:  RLF    58,W
070A:  MOVWF  77
070B:  RLF    77,F
070C:  MOVLW  FC
070D:  ANDWF  77,F
070E:  MOVF   77,W
070F:  ADDWF  25,W
0710:  CALL   00C
0711:  MOVWF  78
0712:  MOVWF  24
....................              kbd_down = true; 
0713:  BSF    23.0
....................           } else { 
0714:  GOTO   71A
....................              ++col; 
0715:  INCF   25,F
....................              if(col==4) 
0716:  MOVF   25,W
0717:  SUBLW  04
0718:  BTFSC  03.2
....................                col=0; 
0719:  CLRF   25
....................           } 
....................        } 
....................       kbd_call_count=0; 
071A:  CLRF   22
....................    } 
....................   set_tris_kbd(ALL_PINS); 
071B:  MOVLW  FF
071C:  BSF    03.5
071D:  MOVWF  06
....................   return(kchar); 
071E:  BCF    03.5
071F:  MOVF   57,W
0720:  MOVWF  78
0721:  RETURN
.................... } 
....................  
.................... #include <string.h>        //libreria comparaciones 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
072A:  MOVF   58,W
072B:  MOVWF  7A
072C:  MOVF   57,W
072D:  MOVWF  04
072E:  BCF    03.7
072F:  BTFSC  7A.0
0730:  BSF    03.7
0731:  MOVF   00,F
0732:  BTFSC  03.2
0733:  GOTO   774
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0734:  MOVF   58,W
0735:  MOVWF  5C
0736:  MOVF   57,W
0737:  MOVWF  5B
0738:  MOVF   5A,W
0739:  MOVWF  5E
073A:  MOVF   59,W
073B:  MOVWF  5D
073C:  MOVF   5E,W
073D:  MOVWF  7A
073E:  MOVF   5D,W
073F:  MOVWF  04
0740:  BCF    03.7
0741:  BTFSC  7A.0
0742:  BSF    03.7
0743:  MOVF   00,F
0744:  BTFSC  03.2
0745:  GOTO   761
0746:  MOVF   5C,W
0747:  MOVWF  7A
0748:  MOVF   5B,W
0749:  MOVWF  04
074A:  BCF    03.7
074B:  BTFSC  7A.0
074C:  BSF    03.7
074D:  MOVF   00,W
074E:  MOVWF  5F
074F:  MOVF   5E,W
0750:  MOVWF  7A
0751:  MOVF   5D,W
0752:  MOVWF  04
0753:  BCF    03.7
0754:  BTFSC  7A.0
0755:  BSF    03.7
0756:  MOVF   00,W
0757:  SUBWF  5F,W
0758:  BTFSS  03.2
0759:  GOTO   761
075A:  INCF   5B,F
075B:  BTFSC  03.2
075C:  INCF   5C,F
075D:  INCF   5D,F
075E:  BTFSC  03.2
075F:  INCF   5E,F
0760:  GOTO   73C
....................  
....................       if (*t == '\0') 
0761:  MOVF   5E,W
0762:  MOVWF  7A
0763:  MOVF   5D,W
0764:  MOVWF  04
0765:  BCF    03.7
0766:  BTFSC  7A.0
0767:  BSF    03.7
0768:  MOVF   00,F
0769:  BTFSS  03.2
076A:  GOTO   770
....................          return s1; 
076B:  MOVF   57,W
076C:  MOVWF  78
076D:  MOVF   58,W
076E:  MOVWF  79
076F:  GOTO   777
....................       ++s1; 
0770:  INCF   57,F
0771:  BTFSC  03.2
0772:  INCF   58,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0773:  GOTO   72A
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0774:  MOVLW  00
0775:  MOVWF  78
0776:  MOVWF  79
0777:  RETURN
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
081B:  CLRF   26
081C:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <max6675.c>             //libreria termocupla 
.................... /**************************************************************************************  
.................... *   max6675.c - communicates with a MAX6675 thermcouple interface chip                *  
.................... *   Copyright Jimbob's Ma 2006                                                        *  
.................... *                                                                                     *  
.................... *   This program is free software; you can redistribute it and/or                     *  
.................... *   modify it under the terms of the GNU General Public License                       *  
.................... *   as published by the Free Software Foundation version 2                            *  
.................... *   of the License.                                                                   *  
.................... *                                                                                     *  
.................... *   This program is distributed in the hope that it will be useful,                   *  
.................... *   but WITHOUT ANY WARRANTY; without even the implied warranty of                    *  
.................... *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                     *  
.................... *   GNU General Public License for more details.                                      *  
.................... *                                                                                     *  
.................... *   You should have received a copy of the GNU General Public License                 *  
.................... *   along with this program; if not, write to the Free Software                       *  
.................... *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.   *  
.................... **************************************************************************************/  
....................  
.................... /*  
.................... This is a diver for the MAX6675 K-type thermocouple interface chip. It implements an SPI  
.................... bus without the need for dedicated hardware (aka a bit-banged interface). The result from  
.................... toFloat_TC() is the temperature in degrees celcius of the thermocouple tip. The rest should  
.................... be self-evident. Have a look at the end of the file for example usage.  
.................... */  
....................  
.................... #ifndef TC_CLK  
....................    #define TC_CLK     PIN_C3            //edit these pins as necessary  
.................... #endif  
....................  
.................... #ifndef TC_CS  
....................    #define TC_CS      PIN_C0  
.................... #endif  
....................  
.................... #ifndef TC_DATA  
....................    #define TC_DATA    PIN_C4  
.................... #endif  
....................  
....................  
.................... int1 thermocouple_error;         //a handy dandy global error flag to tell you if a thermocouple is connected or not  
....................  
.................... void init_TC(void)  
.................... {  
....................    output_low(TC_CLK);  
*
024B:  BCF    20.3
024C:  MOVF   20,W
024D:  BSF    03.5
024E:  MOVWF  07
024F:  BCF    03.5
0250:  BCF    07.3
....................    output_low(TC_DATA);  
0251:  BCF    20.4
0252:  MOVF   20,W
0253:  BSF    03.5
0254:  MOVWF  07
0255:  BCF    03.5
0256:  BCF    07.4
....................    output_high(TC_CS);            //if we idle high, the chip keeps doing conversions. Change this if you like  
0257:  BCF    20.0
0258:  MOVF   20,W
0259:  BSF    03.5
025A:  MOVWF  07
025B:  BCF    03.5
025C:  BSF    07.0
.................... }  
....................  
.................... int16 read_TC(void)               //It takes 200ms (ish) for the MAX6675 to perform a conversion  
.................... {  
....................    int8 i;  
....................    int16 data;  
....................  
....................    output_low(TC_CS);            //stop any conversion processes  
*
0260:  BCF    20.0
0261:  MOVF   20,W
0262:  BSF    03.5
0263:  MOVWF  07
0264:  BCF    03.5
0265:  BCF    07.0
....................    delay_ms(1);               //and give it some time to power up (not very much, admittedly)  
0266:  MOVLW  01
0267:  MOVWF  69
0268:  CALL   065
....................  
....................    for (i=0;i<16;i++){  
0269:  CLRF   57
026A:  MOVF   57,W
026B:  SUBLW  0F
026C:  BTFSS  03.0
026D:  GOTO   28A
....................       shift_left(&data,2,input(TC_DATA));      //reads in 2 bytes to data from the pin TC_DATA  
026E:  BSF    20.4
026F:  MOVF   20,W
0270:  BSF    03.5
0271:  MOVWF  07
0272:  BCF    03.5
0273:  BTFSC  07.4
0274:  GOTO   277
0275:  BCF    03.0
0276:  GOTO   278
0277:  BSF    03.0
0278:  RLF    58,F
0279:  RLF    59,F
....................       output_high(TC_CLK);  
027A:  BCF    20.3
027B:  MOVF   20,W
027C:  BSF    03.5
027D:  MOVWF  07
027E:  BCF    03.5
027F:  BSF    07.3
....................       delay_us(1); //Descomentar si usa crystal mayor a 10MHz 
0280:  NOP
....................       output_low(TC_CLK);  
0281:  BCF    20.3
0282:  MOVF   20,W
0283:  BSF    03.5
0284:  MOVWF  07
0285:  BCF    03.5
0286:  BCF    07.3
....................       delay_us(1); 
0287:  NOP
0288:  INCF   57,F
0289:  GOTO   26A
....................    }  
....................  
....................    thermocouple_error=bit_test(data,2);      //this is the thermocouple status bit  
028A:  BCF    23.1
028B:  BTFSC  58.2
028C:  BSF    23.1
....................    delay_ms(1);      
028D:  MOVLW  01
028E:  MOVWF  69
028F:  CALL   065
....................    output_high(TC_CS);  
0290:  BCF    20.0
0291:  MOVF   20,W
0292:  BSF    03.5
0293:  MOVWF  07
0294:  BCF    03.5
0295:  BSF    07.0
....................    return(data);  
0296:  MOVF   58,W
0297:  MOVWF  78
0298:  MOVF   59,W
0299:  MOVWF  79
.................... }  
....................  
.................... int16 sortout(int16 raw)  
.................... {  
....................     return(0x0FFF & (raw>>3));      //returns only the bits converning temperature  
*
02A2:  RRF    5A,W
02A3:  MOVWF  7A
02A4:  RRF    59,W
02A5:  MOVWF  79
02A6:  RRF    7A,F
02A7:  RRF    79,F
02A8:  RRF    7A,F
02A9:  RRF    79,F
02AA:  MOVLW  1F
02AB:  ANDWF  7A,F
02AC:  MOVF   79,W
02AD:  MOVWF  77
02AE:  MOVLW  0F
02AF:  ANDWF  7A,F
02B0:  MOVF   79,W
02B1:  MOVWF  78
02B2:  MOVF   7A,W
02B3:  MOVWF  79
.................... }  
....................  
.................... float toFloat_TC(int16 tmp)  
.................... {  
....................    return(((float)tmp-44)/2.021142857);  
*
02BC:  MOVF   5A,W
02BD:  MOVWF  5C
02BE:  MOVF   59,W
02BF:  MOVWF  5B
*
02DC:  MOVF   7A,W
02DD:  MOVWF  5E
02DE:  MOVF   79,W
02DF:  MOVWF  5D
02E0:  MOVF   78,W
02E1:  MOVWF  5C
02E2:  MOVF   77,W
02E3:  MOVWF  5B
02E4:  BSF    03.1
02E5:  MOVF   5E,W
02E6:  MOVWF  62
02E7:  MOVF   5D,W
02E8:  MOVWF  61
02E9:  MOVF   5C,W
02EA:  MOVWF  60
02EB:  MOVF   5B,W
02EC:  MOVWF  5F
02ED:  CLRF   66
02EE:  CLRF   65
02EF:  MOVLW  30
02F0:  MOVWF  64
02F1:  MOVLW  84
02F2:  MOVWF  63
*
0433:  MOVF   7A,W
0434:  MOVWF  5E
0435:  MOVF   79,W
0436:  MOVWF  5D
0437:  MOVF   78,W
0438:  MOVWF  5C
0439:  MOVF   77,W
043A:  MOVWF  5B
043B:  MOVF   5E,W
043C:  MOVWF  62
043D:  MOVF   5D,W
043E:  MOVWF  61
043F:  MOVF   5C,W
0440:  MOVWF  60
0441:  MOVF   5B,W
0442:  MOVWF  5F
0443:  MOVLW  68
0444:  MOVWF  66
0445:  MOVLW  5A
0446:  MOVWF  65
0447:  MOVLW  01
0448:  MOVWF  64
0449:  MOVLW  80
044A:  MOVWF  63
....................    //return((float)tmp); 
.................... }  
....................  
.................... float do_everything(void)  
.................... {  
....................    init_TC();  
....................    delay_ms(200);               //200ms is a long time to be doing nothing. use a timer interrupt to avoid wasting time here  
*
025D:  MOVLW  C8
025E:  MOVWF  69
025F:  CALL   065
....................    return(toFloat_TC(sortout(read_TC())));  
*
029A:  MOVF   79,W
029B:  MOVWF  58
029C:  MOVF   78,W
029D:  MOVWF  57
029E:  MOVF   58,W
029F:  MOVWF  5A
02A0:  MOVF   57,W
02A1:  MOVWF  59
*
02B4:  MOVF   79,W
02B5:  MOVWF  58
02B6:  MOVF   78,W
02B7:  MOVWF  57
02B8:  MOVF   58,W
02B9:  MOVWF  5A
02BA:  MOVF   57,W
02BB:  MOVWF  59
*
0514:  BSF    0A.3
0515:  BCF    0A.4
0516:  GOTO   0F1 (RETURN)
.................... } 
....................  
....................  
....................  
.................... char cara[8] = {0x00,0x0A,0x0A,0x0A,0x00,0x11,0x0E,0x00}; 
*
081D:  CLRF   28
081E:  MOVLW  0A
081F:  MOVWF  29
0820:  MOVWF  2A
0821:  MOVWF  2B
0822:  CLRF   2C
0823:  MOVLW  11
0824:  MOVWF  2D
0825:  MOVLW  0E
0826:  MOVWF  2E
0827:  CLRF   2F
.................... char grado[8] = {0x07,0x05,0x07,0x00,0x00,0x00,0x00,0x00}; 
0828:  MOVLW  07
0829:  MOVWF  30
082A:  MOVLW  05
082B:  MOVWF  31
082C:  MOVLW  07
082D:  MOVWF  32
082E:  CLRF   33
082F:  CLRF   34
0830:  CLRF   35
0831:  CLRF   36
0832:  CLRF   37
.................... char bota [8] =  {0b00000001, 0b00000011, 0b00000111, 0b00000111, 0b00000111,0b0000111,0b00001101,0b00011101}; 
0833:  MOVLW  01
0834:  MOVWF  38
0835:  MOVLW  03
0836:  MOVWF  39
0837:  MOVLW  07
0838:  MOVWF  3A
0839:  MOVWF  3B
083A:  MOVWF  3C
083B:  MOVWF  3D
083C:  MOVLW  0D
083D:  MOVWF  3E
083E:  MOVLW  1D
083F:  MOVWF  3F
.................... char k; 
.................... int num=0; 
....................  
....................                   //variable 
....................  
.................... int cont=0; 
.................... int pos=0; 
.................... int sensor1=0; 
.................... int sensor2=0; 
.................... int sensor3=0; 
.................... int sensor4=0; 
.................... char clave [4]; 
.................... char clavem [1]; 
.................... char clave_a[] = "A";   // para ingresar a opcion a 
0840:  MOVLW  41
0841:  MOVWF  4D
0842:  CLRF   4E
.................... char clave_b[] = "B";   // para ingresar b 
0843:  MOVLW  42
0844:  MOVWF  4F
0845:  CLRF   50
.................... char clave_c[] = "C";   // para ingresar c 
0846:  MOVLW  43
0847:  MOVWF  51
0848:  CLRF   52
.................... char temperatura_entrada[] ="#";  //entrada a temperatura 
0849:  MOVLW  23
084A:  MOVWF  53
084B:  CLRF   54
....................  
.................... int menu=0; 
....................  
.................... int dato_temperatura=0; 
....................  
....................  
.................... void termocupla(); 
.................... void botones(); 
....................  
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  20
0805:  CLRF   41
0806:  CLRF   42
0807:  CLRF   43
0808:  CLRF   44
0809:  CLRF   45
080A:  CLRF   46
080B:  CLRF   47
080C:  CLRF   55
080D:  CLRF   56
080E:  BSF    03.5
080F:  BSF    1F.0
0810:  BSF    1F.1
0811:  BSF    1F.2
0812:  BCF    1F.3
0813:  MOVLW  07
0814:  MOVWF  1C
0815:  BCF    03.7
.................... { 
....................  
....................  
....................       lcd_init();       //inicia lcd 
*
084C:  BCF    0A.3
084D:  GOTO   0D0
084E:  BSF    0A.3
....................       kbd_init();       //inicia tecaldo 
084F:  BCF    0A.3
0850:  GOTO   101
0851:  BSF    0A.3
....................       port_b_pullups(true);      //oficializa pullups 
0852:  BSF    03.5
0853:  BCF    01.7
....................  
.................... //setup_timer_2(t2_div_by_16,155,1);        //estabiliza timer 2 
.................... //setup_ccp1(ccp_pwm);                      // configura pwm 
....................  
....................  
.................... //setup_adc(adc_clock_internal);            //inicia salidas de A en adc 
.................... //setup_adc_ports(all_analog);              // establecer todo puerto A en enalogo 
.................... SET_TRIS_D(0xFF);          //D como salidas   
0854:  MOVLW  FF
0855:  MOVWF  08
.................... SET_TRIS_B(0xFF);           //B como salidas           
0856:  MOVWF  06
.................... SET_TRIS_C(0xFF);          //C como salidas  
0857:  MOVWF  07
0858:  BCF    03.5
0859:  MOVWF  20
.................... SET_TRIS_A(0x00);          //C como Entradas  
085A:  MOVLW  00
085B:  BSF    03.5
085C:  MOVWF  05
....................  
....................  
....................  
....................  
....................  CGRAM_position(0); 
085D:  BCF    03.5
085E:  CLRF   57
085F:  BCF    0A.3
0860:  CALL   169
0861:  BSF    0A.3
....................  CGRAM_create_char(cara); 
0862:  CLRF   58
0863:  MOVLW  28
0864:  MOVWF  57
0865:  BCF    0A.3
0866:  CALL   177
0867:  BSF    0A.3
....................  
....................  CGRAM_position(1); 
0868:  MOVLW  01
0869:  MOVWF  57
086A:  BCF    0A.3
086B:  CALL   169
086C:  BSF    0A.3
....................  CGRAM_create_char(grado); 
086D:  CLRF   58
086E:  MOVLW  30
086F:  MOVWF  57
0870:  BCF    0A.3
0871:  CALL   177
0872:  BSF    0A.3
....................  
....................  CGRAM_position(2); 
0873:  MOVLW  02
0874:  MOVWF  57
0875:  BCF    0A.3
0876:  CALL   169
0877:  BSF    0A.3
....................  CGRAM_create_char(bota); 
0878:  CLRF   58
0879:  MOVLW  38
087A:  MOVWF  57
087B:  BCF    0A.3
087C:  CALL   177
087D:  BSF    0A.3
....................  
....................  
....................  
....................    while(true) 
....................    { 
....................       num=0; 
087E:  CLRF   41
....................       pos=0; 
087F:  CLRF   43
....................  
....................       switch (menu) {            //generar menu con # 
0880:  MOVF   55,W
0881:  ADDLW  F9
0882:  BTFSC  03.0
0883:  GOTO   362
0884:  ADDLW  07
0885:  GOTO   364
....................     case 0:   
....................               //menu caso 1 (Temperatura) 
....................       lcd_putc('\f'); 
0886:  MOVLW  0C
0887:  MOVWF  68
0888:  BCF    0A.3
0889:  CALL   1B1
088A:  BSF    0A.3
....................       lcd_gotoxy(6,2); 
088B:  MOVLW  06
088C:  MOVWF  69
088D:  MOVLW  02
088E:  MOVWF  6A
088F:  BCF    0A.3
0890:  CALL   18C
0891:  BSF    0A.3
....................       CGRAM_putc(2); 
0892:  MOVLW  02
0893:  MOVWF  57
0894:  BCF    0A.3
0895:  CALL   1D8
0896:  BSF    0A.3
....................       lcd_putc("buen dia "); 
0897:  MOVLW  21
0898:  BSF    03.6
0899:  MOVWF  0D
089A:  MOVLW  00
089B:  MOVWF  0F
089C:  BCF    0A.3
089D:  BCF    03.6
089E:  CALL   1DE
089F:  BSF    0A.3
....................       CGRAM_putc(0); 
08A0:  CLRF   57
08A1:  BCF    0A.3
08A2:  CALL   1D8
08A3:  BSF    0A.3
....................       delay_ms(200);   
08A4:  MOVLW  C8
08A5:  MOVWF  69
08A6:  BCF    0A.3
08A7:  CALL   065
08A8:  BSF    0A.3
....................       menu++; 
08A9:  INCF   55,F
....................            break; 
08AA:  GOTO   362
....................  
....................     case 1:          //menu caso 2 (Medicion) 
....................  while(input(menu)==1); 
08AB:  MOVF   55,W
08AC:  MOVWF  57
08AD:  CLRF   59
08AE:  CLRF   58
08AF:  BCF    0A.3
08B0:  CALL   234
08B1:  BSF    0A.3
08B2:  BTFSC  78.0
08B3:  GOTO   0AB
....................       while(input(menu)!=1){ 
08B4:  MOVF   55,W
08B5:  MOVWF  57
08B6:  CLRF   59
08B7:  CLRF   58
08B8:  BCF    0A.3
08B9:  CALL   234
08BA:  BSF    0A.3
08BB:  BTFSC  78.0
08BC:  GOTO   1DC
....................          lcd_putc('\f'); 
08BD:  MOVLW  0C
08BE:  MOVWF  68
08BF:  BCF    0A.3
08C0:  CALL   1B1
08C1:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
08C2:  MOVLW  01
08C3:  MOVWF  69
08C4:  MOVWF  6A
08C5:  BCF    0A.3
08C6:  CALL   18C
08C7:  BSF    0A.3
....................          lcd_putc("cont"); 
08C8:  MOVLW  26
08C9:  BSF    03.6
08CA:  MOVWF  0D
08CB:  MOVLW  00
08CC:  MOVWF  0F
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   1DE
08D0:  BSF    0A.3
....................          lcd_gotoxy(5,1); 
08D1:  MOVLW  05
08D2:  MOVWF  69
08D3:  MOVLW  01
08D4:  MOVWF  6A
08D5:  BCF    0A.3
08D6:  CALL   18C
08D7:  BSF    0A.3
....................  
....................  
....................          lcd_gotoxy(1,2); 
08D8:  MOVLW  01
08D9:  MOVWF  69
08DA:  MOVLW  02
08DB:  MOVWF  6A
08DC:  BCF    0A.3
08DD:  CALL   18C
08DE:  BSF    0A.3
....................          lcd_putc("Temp:"); 
08DF:  MOVLW  29
08E0:  BSF    03.6
08E1:  MOVWF  0D
08E2:  MOVLW  00
08E3:  MOVWF  0F
08E4:  BCF    0A.3
08E5:  BCF    03.6
08E6:  CALL   1DE
08E7:  BSF    0A.3
....................       lcd_gotoxy(8,3); 
08E8:  MOVLW  08
08E9:  MOVWF  69
08EA:  MOVLW  03
08EB:  MOVWF  6A
08EC:  BCF    0A.3
08ED:  CALL   18C
08EE:  BSF    0A.3
....................       printf(lcd_putc,"%01.2f%cC\r\n", do_everything(),0xB0); 
08EF:  BCF    0A.3
08F0:  GOTO   24B
08F1:  BSF    0A.3
08F2:  MOVF   7A,W
08F3:  MOVWF  5A
08F4:  MOVF   79,W
08F5:  MOVWF  59
08F6:  MOVF   78,W
08F7:  MOVWF  58
08F8:  MOVF   77,W
08F9:  MOVWF  57
08FA:  MOVLW  C9
08FB:  MOVWF  04
08FC:  MOVF   5A,W
08FD:  MOVWF  5E
08FE:  MOVF   59,W
08FF:  MOVWF  5D
0900:  MOVF   58,W
0901:  MOVWF  5C
0902:  MOVF   57,W
0903:  MOVWF  5B
0904:  MOVLW  02
0905:  MOVWF  5F
0906:  BCF    0A.3
0907:  GOTO   566
0908:  BSF    0A.3
0909:  MOVLW  B0
090A:  MOVWF  68
090B:  BCF    0A.3
090C:  CALL   1B1
090D:  BSF    0A.3
090E:  MOVLW  43
090F:  MOVWF  68
0910:  BCF    0A.3
0911:  CALL   1B1
0912:  BSF    0A.3
0913:  MOVLW  0D
0914:  MOVWF  68
0915:  BCF    0A.3
0916:  CALL   1B1
0917:  BSF    0A.3
0918:  MOVLW  0A
0919:  MOVWF  68
091A:  BCF    0A.3
091B:  CALL   1B1
091C:  BSF    0A.3
....................  
....................         lcd_gotoxy(17,2); 
091D:  MOVLW  11
091E:  MOVWF  69
091F:  MOVLW  02
0920:  MOVWF  6A
0921:  BCF    0A.3
0922:  CALL   18C
0923:  BSF    0A.3
....................     CGRAM_putc(1); 
0924:  MOVLW  01
0925:  MOVWF  57
0926:  BCF    0A.3
0927:  CALL   1D8
0928:  BSF    0A.3
....................          lcd_gotoxy(1,3); 
0929:  MOVLW  01
092A:  MOVWF  69
092B:  MOVLW  03
092C:  MOVWF  6A
092D:  BCF    0A.3
092E:  CALL   18C
092F:  BSF    0A.3
....................          lcd_putc("Posicion:"); 
0930:  MOVLW  2C
0931:  BSF    03.6
0932:  MOVWF  0D
0933:  MOVLW  00
0934:  MOVWF  0F
0935:  BCF    0A.3
0936:  BCF    03.6
0937:  CALL   1DE
0938:  BSF    0A.3
....................  
....................  
.................... if(sensor1==1){ 
0939:  DECFSZ 44,W
093A:  GOTO   14B
....................     lcd_gotoxy(11,3); 
093B:  MOVLW  0B
093C:  MOVWF  69
093D:  MOVLW  03
093E:  MOVWF  6A
093F:  BCF    0A.3
0940:  CALL   18C
0941:  BSF    0A.3
....................          lcd_putc("34-35"); 
0942:  MOVLW  31
0943:  BSF    03.6
0944:  MOVWF  0D
0945:  MOVLW  00
0946:  MOVWF  0F
0947:  BCF    0A.3
0948:  BCF    03.6
0949:  CALL   1DE
094A:  BSF    0A.3
....................  
....................  
.................... } 
.................... if(sensor2==1){ 
094B:  DECFSZ 45,W
094C:  GOTO   15D
....................     lcd_gotoxy(11,3); 
094D:  MOVLW  0B
094E:  MOVWF  69
094F:  MOVLW  03
0950:  MOVWF  6A
0951:  BCF    0A.3
0952:  CALL   18C
0953:  BSF    0A.3
....................          lcd_putc("36-37"); 
0954:  MOVLW  34
0955:  BSF    03.6
0956:  MOVWF  0D
0957:  MOVLW  00
0958:  MOVWF  0F
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   1DE
095C:  BSF    0A.3
.................... } 
.................... if(sensor3==1){ 
095D:  DECFSZ 46,W
095E:  GOTO   16F
....................     lcd_gotoxy(11,3); 
095F:  MOVLW  0B
0960:  MOVWF  69
0961:  MOVLW  03
0962:  MOVWF  6A
0963:  BCF    0A.3
0964:  CALL   18C
0965:  BSF    0A.3
....................          lcd_putc("38-39"); 
0966:  MOVLW  37
0967:  BSF    03.6
0968:  MOVWF  0D
0969:  MOVLW  00
096A:  MOVWF  0F
096B:  BCF    0A.3
096C:  BCF    03.6
096D:  CALL   1DE
096E:  BSF    0A.3
.................... } 
....................  
....................  
....................          lcd_gotoxy(1,4); 
096F:  MOVLW  01
0970:  MOVWF  69
0971:  MOVLW  04
0972:  MOVWF  6A
0973:  BCF    0A.3
0974:  CALL   18C
0975:  BSF    0A.3
....................          lcd_putc("Presione # para temp"); 
0976:  MOVLW  3A
0977:  BSF    03.6
0978:  MOVWF  0D
0979:  MOVLW  00
097A:  MOVWF  0F
097B:  BCF    0A.3
097C:  BCF    03.6
097D:  CALL   1DE
097E:  BSF    0A.3
....................  
....................  
.................... while(num<1){ 
097F:  MOVF   41,F
0980:  BTFSS  03.2
0981:  GOTO   19E
....................    k=kbd_getc(); 
0982:  BCF    0A.3
0983:  CALL   6BB
0984:  BSF    0A.3
0985:  MOVF   78,W
0986:  MOVWF  40
....................    if(k != 0){ 
0987:  MOVF   40,F
0988:  BTFSC  03.2
0989:  GOTO   19D
....................             
....................           clavem[num]=k; 
098A:  MOVLW  4C
098B:  ADDWF  41,W
098C:  MOVWF  04
098D:  BCF    03.7
098E:  MOVF   40,W
098F:  MOVWF  00
....................           num++; 
0990:  INCF   41,F
....................          lcd_gotoxy(10,1); 
0991:  MOVLW  0A
0992:  MOVWF  69
0993:  MOVLW  01
0994:  MOVWF  6A
0995:  BCF    0A.3
0996:  CALL   18C
0997:  BSF    0A.3
....................          lcd_putc(k); 
0998:  MOVF   40,W
0999:  MOVWF  68
099A:  BCF    0A.3
099B:  CALL   1B1
099C:  BSF    0A.3
....................  
.................... } 
099D:  GOTO   17F
.................... } 
....................  
.................... if(strstr(clavem, clave_a)){             //posicion 34/35 , A 
099E:  CLRF   58
099F:  MOVLW  4C
09A0:  MOVWF  57
09A1:  CLRF   5A
09A2:  MOVLW  4D
09A3:  MOVWF  59
09A4:  BCF    0A.3
09A5:  CALL   72A
09A6:  BSF    0A.3
09A7:  MOVF   78,W
09A8:  IORWF  79,W
09A9:  BTFSC  03.2
09AA:  GOTO   1AD
.................... menu =3; 
09AB:  MOVLW  03
09AC:  MOVWF  55
.................... } 
.................... if(strstr(clavem, clave_b)){               //posicion 36/37     B 
09AD:  CLRF   58
09AE:  MOVLW  4C
09AF:  MOVWF  57
09B0:  CLRF   5A
09B1:  MOVLW  4F
09B2:  MOVWF  59
09B3:  BCF    0A.3
09B4:  CALL   72A
09B5:  BSF    0A.3
09B6:  MOVF   78,W
09B7:  IORWF  79,W
09B8:  BTFSC  03.2
09B9:  GOTO   1BC
.................... menu=4; 
09BA:  MOVLW  04
09BB:  MOVWF  55
....................  
.................... } 
.................... if(strstr(clavem, clave_c)){                  //posicion 38/39  C 
09BC:  CLRF   58
09BD:  MOVLW  4C
09BE:  MOVWF  57
09BF:  CLRF   5A
09C0:  MOVLW  51
09C1:  MOVWF  59
09C2:  BCF    0A.3
09C3:  CALL   72A
09C4:  BSF    0A.3
09C5:  MOVF   78,W
09C6:  IORWF  79,W
09C7:  BTFSC  03.2
09C8:  GOTO   1CB
.................... menu=5; 
09C9:  MOVLW  05
09CA:  MOVWF  55
.................... } 
.................... if(strstr(clavem, temperatura_entrada)){ 
09CB:  CLRF   58
09CC:  MOVLW  4C
09CD:  MOVWF  57
09CE:  CLRF   5A
09CF:  MOVLW  53
09D0:  MOVWF  59
09D1:  BCF    0A.3
09D2:  CALL   72A
09D3:  BSF    0A.3
09D4:  MOVF   78,W
09D5:  IORWF  79,W
09D6:  BTFSC  03.2
09D7:  GOTO   1DA
....................       menu=6; 
09D8:  MOVLW  06
09D9:  MOVWF  55
....................       } 
....................  break; 
09DA:  GOTO   1DC
09DB:  GOTO   0B4
....................  
....................  
....................       } 
....................  case 3:                // posicion 1 
....................        lcd_putc('\f'); 
09DC:  MOVLW  0C
09DD:  MOVWF  68
09DE:  BCF    0A.3
09DF:  CALL   1B1
09E0:  BSF    0A.3
....................       lcd_gotoxy(7,1); 
09E1:  MOVLW  07
09E2:  MOVWF  69
09E3:  MOVLW  01
09E4:  MOVWF  6A
09E5:  BCF    0A.3
09E6:  CALL   18C
09E7:  BSF    0A.3
....................       lcd_putc("BUSCANDO"); 
09E8:  MOVLW  45
09E9:  BSF    03.6
09EA:  MOVWF  0D
09EB:  MOVLW  00
09EC:  MOVWF  0F
09ED:  BCF    0A.3
09EE:  BCF    03.6
09EF:  CALL   1DE
09F0:  BSF    0A.3
....................       sensor1=0; 
09F1:  CLRF   44
....................       sensor2=0; 
09F2:  CLRF   45
....................       sensor3=0; 
09F3:  CLRF   46
....................       sensor4=0;                                                                                                                                   //posicion 1 
09F4:  CLRF   47
.................... if(pos<2){ 
09F5:  MOVF   43,W
09F6:  SUBLW  01
09F7:  BTFSS  03.0
09F8:  GOTO   205
....................       output_low(pin_c1);      
09F9:  BCF    20.1
09FA:  MOVF   20,W
09FB:  BSF    03.5
09FC:  MOVWF  07
09FD:  BCF    03.5
09FE:  BCF    07.1
....................       output_high(pin_c2);          //empieza a bajar el motor si la posicion es distinta a 0, siempre baja 
09FF:  BCF    20.2
0A00:  MOVF   20,W
0A01:  BSF    03.5
0A02:  MOVWF  07
0A03:  BCF    03.5
0A04:  BSF    07.2
....................  }    
.................... if(pos>2){ 
0A05:  MOVF   43,W
0A06:  SUBLW  02
0A07:  BTFSC  03.0
0A08:  GOTO   215
....................       output_low(pin_c1);      
0A09:  BCF    20.1
0A0A:  MOVF   20,W
0A0B:  BSF    03.5
0A0C:  MOVWF  07
0A0D:  BCF    03.5
0A0E:  BCF    07.1
....................       output_high(pin_c2);          //empieza a bajar el motor si la posicion es distinta a 0, siempre baja 
0A0F:  BCF    20.2
0A10:  MOVF   20,W
0A11:  BSF    03.5
0A12:  MOVWF  07
0A13:  BCF    03.5
0A14:  BSF    07.2
.................... } 
....................  
....................  
....................  
....................  
.................... if(input(PIN_A0)==1){         //si llega a accionarse el sensor A0 el motor se detiene 
0A15:  BTFSS  05.0
0A16:  GOTO   21D
....................    while(input(PIN_A0)==1){ 
0A17:  BTFSS  05.0
0A18:  GOTO   21D
....................       sensor1=1;           //se suma sensor 1, aclarando que esta en la posicion 1 
0A19:  MOVLW  01
0A1A:  MOVWF  44
....................       pos=1; 
0A1B:  MOVWF  43
0A1C:  GOTO   217
....................   } 
.................... } 
.................... if(sensor1==1){ 
0A1D:  DECFSZ 44,W
0A1E:  GOTO   22B
....................       output_low(pin_c1); 
0A1F:  BCF    20.1
0A20:  MOVF   20,W
0A21:  BSF    03.5
0A22:  MOVWF  07
0A23:  BCF    03.5
0A24:  BCF    07.1
....................       output_low(pin_c2);           //se detiene el motor 
0A25:  BCF    20.2
0A26:  MOVF   20,W
0A27:  BSF    03.5
0A28:  MOVWF  07
0A29:  BCF    03.5
0A2A:  BCF    07.2
....................       } 
.................... if(sensor1==1){ 
0A2B:  DECFSZ 44,W
0A2C:  GOTO   240
....................             output_low(pin_c1); 
0A2D:  BCF    20.1
0A2E:  MOVF   20,W
0A2F:  BSF    03.5
0A30:  MOVWF  07
0A31:  BCF    03.5
0A32:  BCF    07.1
....................       output_low(pin_c2);    
0A33:  BCF    20.2
0A34:  MOVF   20,W
0A35:  BSF    03.5
0A36:  MOVWF  07
0A37:  BCF    03.5
0A38:  BCF    07.2
....................       menu=1; 
0A39:  MOVLW  01
0A3A:  MOVWF  55
....................       delay_ms(200); 
0A3B:  MOVLW  C8
0A3C:  MOVWF  69
0A3D:  BCF    0A.3
0A3E:  CALL   065
0A3F:  BSF    0A.3
.................... } 
....................       delay_ms(200); 
0A40:  MOVLW  C8
0A41:  MOVWF  69
0A42:  BCF    0A.3
0A43:  CALL   065
0A44:  BSF    0A.3
....................  
....................  break; 
0A45:  GOTO   362
....................  
....................  
....................  case 4:                            // posicion 2 
....................  
....................  
....................       lcd_putc('\f'); 
0A46:  MOVLW  0C
0A47:  MOVWF  68
0A48:  BCF    0A.3
0A49:  CALL   1B1
0A4A:  BSF    0A.3
....................       lcd_gotoxy(7,1); 
0A4B:  MOVLW  07
0A4C:  MOVWF  69
0A4D:  MOVLW  01
0A4E:  MOVWF  6A
0A4F:  BCF    0A.3
0A50:  CALL   18C
0A51:  BSF    0A.3
....................       lcd_putc("BUSCANDO"); 
0A52:  MOVLW  4A
0A53:  BSF    03.6
0A54:  MOVWF  0D
0A55:  MOVLW  00
0A56:  MOVWF  0F
0A57:  BCF    0A.3
0A58:  BCF    03.6
0A59:  CALL   1DE
0A5A:  BSF    0A.3
....................       lcd_gotoxy(7,2); 
0A5B:  MOVLW  07
0A5C:  MOVWF  69
0A5D:  MOVLW  02
0A5E:  MOVWF  6A
0A5F:  BCF    0A.3
0A60:  CALL   18C
0A61:  BSF    0A.3
....................       lcd_putc("36-37");; 
0A62:  MOVLW  4F
0A63:  BSF    03.6
0A64:  MOVWF  0D
0A65:  MOVLW  00
0A66:  MOVWF  0F
0A67:  BCF    0A.3
0A68:  BCF    03.6
0A69:  CALL   1DE
0A6A:  BSF    0A.3
....................       sensor1=0; 
0A6B:  CLRF   44
....................       sensor2=0; 
0A6C:  CLRF   45
....................       sensor3=0; 
0A6D:  CLRF   46
....................       sensor4=0;                                                                                                                                   //posicion 1 
0A6E:  CLRF   47
.................... if(pos<2){ 
0A6F:  MOVF   43,W
0A70:  SUBLW  01
0A71:  BTFSS  03.0
0A72:  GOTO   27F
....................       output_low(pin_c1);      
0A73:  BCF    20.1
0A74:  MOVF   20,W
0A75:  BSF    03.5
0A76:  MOVWF  07
0A77:  BCF    03.5
0A78:  BCF    07.1
....................       output_high(pin_c2);          //empieza a bajar el motor si la posicion es distinta a 0, siempre baja 
0A79:  BCF    20.2
0A7A:  MOVF   20,W
0A7B:  BSF    03.5
0A7C:  MOVWF  07
0A7D:  BCF    03.5
0A7E:  BSF    07.2
....................  }    
.................... if(pos>2){ 
0A7F:  MOVF   43,W
0A80:  SUBLW  02
0A81:  BTFSC  03.0
0A82:  GOTO   28F
....................       output_low(pin_c1);      
0A83:  BCF    20.1
0A84:  MOVF   20,W
0A85:  BSF    03.5
0A86:  MOVWF  07
0A87:  BCF    03.5
0A88:  BCF    07.1
....................       output_high(pin_c2);          //empieza a bajar el motor si la posicion es distinta a 0, siempre baja 
0A89:  BCF    20.2
0A8A:  MOVF   20,W
0A8B:  BSF    03.5
0A8C:  MOVWF  07
0A8D:  BCF    03.5
0A8E:  BSF    07.2
.................... } 
....................  
....................  
....................  
....................  
.................... if(input(PIN_A1)==1){         //si llega a accionarse el sensor A0 el motor se detiene 
0A8F:  BTFSS  05.1
0A90:  GOTO   298
....................    while(input(PIN_A1)==1){ 
0A91:  BTFSS  05.1
0A92:  GOTO   298
....................       sensor2=1;           //se suma sensor 1, aclarando que esta en la posicion 1 
0A93:  MOVLW  01
0A94:  MOVWF  45
....................       pos=2; 
0A95:  MOVLW  02
0A96:  MOVWF  43
0A97:  GOTO   291
....................   } 
.................... } 
.................... if(sensor2==1){ 
0A98:  DECFSZ 45,W
0A99:  GOTO   2A6
....................       output_low(pin_c1); 
0A9A:  BCF    20.1
0A9B:  MOVF   20,W
0A9C:  BSF    03.5
0A9D:  MOVWF  07
0A9E:  BCF    03.5
0A9F:  BCF    07.1
....................       output_low(pin_c2);           //se detiene el motor 
0AA0:  BCF    20.2
0AA1:  MOVF   20,W
0AA2:  BSF    03.5
0AA3:  MOVWF  07
0AA4:  BCF    03.5
0AA5:  BCF    07.2
....................       } 
.................... if(sensor2==1){ 
0AA6:  DECFSZ 45,W
0AA7:  GOTO   2BB
....................             output_low(pin_c1); 
0AA8:  BCF    20.1
0AA9:  MOVF   20,W
0AAA:  BSF    03.5
0AAB:  MOVWF  07
0AAC:  BCF    03.5
0AAD:  BCF    07.1
....................       output_low(pin_c2);    
0AAE:  BCF    20.2
0AAF:  MOVF   20,W
0AB0:  BSF    03.5
0AB1:  MOVWF  07
0AB2:  BCF    03.5
0AB3:  BCF    07.2
....................       menu=1; 
0AB4:  MOVLW  01
0AB5:  MOVWF  55
....................       delay_ms(200); 
0AB6:  MOVLW  C8
0AB7:  MOVWF  69
0AB8:  BCF    0A.3
0AB9:  CALL   065
0ABA:  BSF    0A.3
.................... } 
....................       delay_ms(200); 
0ABB:  MOVLW  C8
0ABC:  MOVWF  69
0ABD:  BCF    0A.3
0ABE:  CALL   065
0ABF:  BSF    0A.3
....................  break; 
0AC0:  GOTO   362
....................  
....................  
....................  case 5:                            //posicion 3 
....................       sensor1=0; 
0AC1:  CLRF   44
....................       sensor2=0; 
0AC2:  CLRF   45
....................       sensor3=0; 
0AC3:  CLRF   46
....................       sensor4=0; 
0AC4:  CLRF   47
....................  
.................... if (pos<4){ 
0AC5:  MOVF   43,W
0AC6:  SUBLW  03
0AC7:  BTFSS  03.0
0AC8:  GOTO   2D5
....................       output_low(pin_c1);      
0AC9:  BCF    20.1
0ACA:  MOVF   20,W
0ACB:  BSF    03.5
0ACC:  MOVWF  07
0ACD:  BCF    03.5
0ACE:  BCF    07.1
....................       output_high(pin_c2);          //empieza a bajar el motor si la posicion es distinta a 0, siempre baja 
0ACF:  BCF    20.2
0AD0:  MOVF   20,W
0AD1:  BSF    03.5
0AD2:  MOVWF  07
0AD3:  BCF    03.5
0AD4:  BSF    07.2
.................... } 
....................       lcd_putc('\f'); 
0AD5:  MOVLW  0C
0AD6:  MOVWF  68
0AD7:  BCF    0A.3
0AD8:  CALL   1B1
0AD9:  BSF    0A.3
....................       lcd_gotoxy(7,1); 
0ADA:  MOVLW  07
0ADB:  MOVWF  69
0ADC:  MOVLW  01
0ADD:  MOVWF  6A
0ADE:  BCF    0A.3
0ADF:  CALL   18C
0AE0:  BSF    0A.3
....................       lcd_putc("posicion 4"); 
0AE1:  MOVLW  52
0AE2:  BSF    03.6
0AE3:  MOVWF  0D
0AE4:  MOVLW  00
0AE5:  MOVWF  0F
0AE6:  BCF    0A.3
0AE7:  BCF    03.6
0AE8:  CALL   1DE
0AE9:  BSF    0A.3
....................        
....................                                                                                                                                                 //posicion 3 
.................... if(input(PIN_A2==1)){         //si llega a accionarse el sensor A3 el motor se detiene 
0AEA:  BTFSS  00.0
0AEB:  GOTO   2F3
....................    while(input(PIN_A2)==1){ 
0AEC:  BTFSS  05.2
0AED:  GOTO   2F3
.................... sensor3=1; 
0AEE:  MOVLW  01
0AEF:  MOVWF  46
.................... pos=3; 
0AF0:  MOVLW  03
0AF1:  MOVWF  43
0AF2:  GOTO   2EC
....................  
....................  }} 
....................  
....................  
.................... if(sensor3==1){ 
0AF3:  DECFSZ 46,W
0AF4:  GOTO   301
....................       output_low(pin_c1); 
0AF5:  BCF    20.1
0AF6:  MOVF   20,W
0AF7:  BSF    03.5
0AF8:  MOVWF  07
0AF9:  BCF    03.5
0AFA:  BCF    07.1
....................       output_low(pin_c2); 
0AFB:  BCF    20.2
0AFC:  MOVF   20,W
0AFD:  BSF    03.5
0AFE:  MOVWF  07
0AFF:  BCF    03.5
0B00:  BCF    07.2
....................  } 
....................  
....................  if (sensor3==1){ 
0B01:  DECFSZ 46,W
0B02:  GOTO   30A
....................       menu=1; 
0B03:  MOVLW  01
0B04:  MOVWF  55
....................       delay_ms(200); 
0B05:  MOVLW  C8
0B06:  MOVWF  69
0B07:  BCF    0A.3
0B08:  CALL   065
0B09:  BSF    0A.3
....................  } 
....................  
....................  
....................  break; 
0B0A:  GOTO   362
....................  
....................  
....................  case 6: 
....................  
....................       lcd_putc('\f'); 
0B0B:  MOVLW  0C
0B0C:  MOVWF  68
0B0D:  BCF    0A.3
0B0E:  CALL   1B1
0B0F:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
0B10:  MOVLW  01
0B11:  MOVWF  69
0B12:  MOVWF  6A
0B13:  BCF    0A.3
0B14:  CALL   18C
0B15:  BSF    0A.3
....................          lcd_putc("INGRESE GRADOS"); 
0B16:  MOVLW  58
0B17:  BSF    03.6
0B18:  MOVWF  0D
0B19:  MOVLW  00
0B1A:  MOVWF  0F
0B1B:  BCF    0A.3
0B1C:  BCF    03.6
0B1D:  CALL   1DE
0B1E:  BSF    0A.3
....................           CGRAM_putc(1); 
0B1F:  MOVLW  01
0B20:  MOVWF  57
0B21:  BCF    0A.3
0B22:  CALL   1D8
0B23:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0B24:  MOVLW  01
0B25:  MOVWF  69
0B26:  MOVLW  02
0B27:  MOVWF  6A
0B28:  BCF    0A.3
0B29:  CALL   18C
0B2A:  BSF    0A.3
....................          lcd_putc("3 digitos"); 
0B2B:  MOVLW  60
0B2C:  BSF    03.6
0B2D:  MOVWF  0D
0B2E:  MOVLW  00
0B2F:  MOVWF  0F
0B30:  BCF    0A.3
0B31:  BCF    03.6
0B32:  CALL   1DE
0B33:  BSF    0A.3
....................  
....................  
....................  
.................... while(num<3){ 
0B34:  MOVF   41,W
0B35:  SUBLW  02
0B36:  BTFSS  03.0
0B37:  GOTO   35D
....................    k=kbd_getc(); 
0B38:  BCF    0A.3
0B39:  CALL   6BB
0B3A:  BSF    0A.3
0B3B:  MOVF   78,W
0B3C:  MOVWF  40
....................    if(k != 0){ 
0B3D:  MOVF   40,F
0B3E:  BTFSC  03.2
0B3F:  GOTO   357
....................             
....................           clave[num]=k; 
0B40:  MOVLW  48
0B41:  ADDWF  41,W
0B42:  MOVWF  04
0B43:  BCF    03.7
0B44:  MOVF   40,W
0B45:  MOVWF  00
....................           num++; 
0B46:  INCF   41,F
....................          lcd_gotoxy(num+1,4); 
0B47:  MOVLW  01
0B48:  ADDWF  41,W
0B49:  MOVWF  57
0B4A:  MOVWF  69
0B4B:  MOVLW  04
0B4C:  MOVWF  6A
0B4D:  BCF    0A.3
0B4E:  CALL   18C
0B4F:  BSF    0A.3
....................          lcd_putc(k); 
0B50:  MOVF   40,W
0B51:  MOVWF  68
0B52:  BCF    0A.3
0B53:  CALL   1B1
0B54:  BSF    0A.3
.................... dato_temperatura=k; 
0B55:  MOVF   40,W
0B56:  MOVWF  56
.................... } 
....................  
.................... if(dato_temperatura!=0){ 
0B57:  MOVF   56,F
0B58:  BTFSC  03.2
0B59:  GOTO   35C
.................... menu=1; 
0B5A:  MOVLW  01
0B5B:  MOVWF  55
.................... } 
0B5C:  GOTO   334
....................  
.................... } 
....................  
....................    delay_ms(100); 
0B5D:  MOVLW  64
0B5E:  MOVWF  69
0B5F:  BCF    0A.3
0B60:  CALL   065
0B61:  BSF    0A.3
....................  
....................  
....................  
.................... }} 
0B62:  GOTO   07E
....................  
....................    } 
....................  
0B63:  SLEEP
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
