CCS PCM C Compiler, Version 5.025, 63725               20-oct.-22 20:22

               Filename:   C:\Users\juand\Desktop\micros\Sensores\main.lst

               ROM used:   2209 words (27%)
                           Largest free fragment is 2048
               RAM used:   25 (7%) at main() level
                           60 (16%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  41
000C:  RETLW  34
000D:  RETLW  35
000E:  RETLW  36
000F:  RETLW  42
0010:  RETLW  37
0011:  RETLW  38
0012:  RETLW  39
0013:  RETLW  43
0014:  RETLW  2A
0015:  RETLW  30
0016:  RETLW  23
0017:  RETLW  44
0018:  DATA CC,30
0019:  DATA 20,3A
001A:  DATA E5,36
001B:  DATA 70,10
001C:  DATA 8A,32
001D:  DATA 73,1D
001E:  DATA A0,12
001F:  DATA 75,10
0020:  DATA 43,00
0021:  DATA 49,27
0022:  DATA 47,29
0023:  DATA C5,29
0024:  DATA 41,29
0025:  DATA A0,21
0026:  DATA CC,20
0027:  DATA D6,22
0028:  DATA 00,00
0029:  DATA A0,31
002A:  DATA EC,30
002B:  DATA F6,32
002C:  DATA A0,31
002D:  DATA 6F,39
002E:  DATA F2,32
002F:  DATA 63,3A
0030:  DATA 61,00
0031:  DATA A0,20
0032:  DATA E4,32
0033:  DATA EC,30
0034:  DATA 6E,3A
0035:  DATA E5,10
0036:  DATA 00,01
0037:  DATA CC,30
0038:  DATA 20,3A
0039:  DATA E5,36
003A:  DATA 70,10
003B:  DATA 8A,32
003C:  DATA 73,1D
003D:  DATA A0,12
003E:  DATA 75,10
003F:  DATA 43,00
0040:  DATA 20,10
0041:  DATA 63,36
0042:  DATA 61,3B
0043:  DATA 65,10
0044:  DATA 65,39
0045:  DATA F2,37
0046:  DATA EE,32
0047:  DATA 61,00
0048:  DATA 65,36
0049:  DATA A0,33
004A:  DATA F2,30
004B:  DATA E4,37
004C:  DATA 20,05
004D:  DATA E5,39
004E:  DATA 3A,10
004F:  DATA 25,23
0050:  DATA 33,17
0051:  DATA 32,00
0052:  DATA 49,27
0053:  DATA 47,29
0054:  DATA C5,29
0055:  DATA 41,29
0056:  DATA A0,21
0057:  DATA CC,20
0058:  DATA D6,22
0059:  DATA 00,01
005A:  DATA A0,31
005B:  DATA EC,30
005C:  DATA F6,32
005D:  DATA A0,31
005E:  DATA 6F,39
005F:  DATA F2,32
0060:  DATA 63,3A
0061:  DATA 61,00
0062:  DATA A0,20
0063:  DATA E4,32
0064:  DATA EC,30
0065:  DATA 6E,3A
0066:  DATA E5,10
0067:  DATA 00,01
0068:  DATA A0,32
0069:  DATA 73,1D
006A:  DATA A0,12
006B:  DATA E6,19
006C:  DATA 2E,19
006D:  DATA 00,01
006E:  DATA 20,10
006F:  DATA 63,36
0070:  DATA 61,3B
0071:  DATA 65,10
0072:  DATA 65,39
0073:  DATA F2,37
0074:  DATA EE,32
0075:  DATA 61,00
*
0124:  MOVLW  10
0125:  MOVWF  41
0126:  CLRF   77
0127:  CLRF   7A
0128:  RRF    3E,F
0129:  RRF    3D,F
012A:  BTFSS  03.0
012B:  GOTO   132
012C:  MOVF   3F,W
012D:  ADDWF  77,F
012E:  BTFSC  03.0
012F:  INCF   7A,F
0130:  MOVF   40,W
0131:  ADDWF  7A,F
0132:  RRF    7A,F
0133:  RRF    77,F
0134:  RRF    79,F
0135:  RRF    78,F
0136:  DECFSZ 41,F
0137:  GOTO   128
0138:  BSF    0A.3
0139:  BCF    0A.4
013A:  GOTO   051 (RETURN)
013B:  MOVLW  8E
013C:  MOVWF  77
013D:  MOVF   3E,W
013E:  MOVWF  78
013F:  MOVF   3D,W
0140:  MOVWF  79
0141:  CLRF   7A
0142:  MOVF   78,F
0143:  BTFSS  03.2
0144:  GOTO   14F
0145:  MOVF   79,W
0146:  MOVWF  78
0147:  CLRF   79
0148:  MOVLW  08
0149:  SUBWF  77,F
014A:  MOVF   78,F
014B:  BTFSS  03.2
014C:  GOTO   14F
014D:  CLRF   77
014E:  GOTO   157
014F:  BCF    03.0
0150:  BTFSC  78.7
0151:  GOTO   156
0152:  RLF    79,F
0153:  RLF    78,F
0154:  DECF   77,F
0155:  GOTO   14F
0156:  BCF    78.7
0157:  RETURN
0158:  MOVF   4A,W
0159:  BTFSC  03.2
015A:  GOTO   1C8
015B:  MOVWF  52
015C:  MOVF   4E,W
015D:  BTFSC  03.2
015E:  GOTO   1C8
015F:  ADDWF  52,F
0160:  BTFSC  03.0
0161:  GOTO   169
0162:  MOVLW  7F
0163:  SUBWF  52,F
0164:  BTFSS  03.0
0165:  GOTO   1C8
0166:  BTFSC  03.2
0167:  GOTO   1C8
0168:  GOTO   16D
0169:  MOVLW  81
016A:  ADDWF  52,F
016B:  BTFSC  03.0
016C:  GOTO   1C8
016D:  MOVF   52,W
016E:  MOVWF  77
016F:  CLRF   78
0170:  CLRF   79
0171:  CLRF   7A
0172:  MOVF   4B,W
0173:  MOVWF  56
0174:  BSF    56.7
0175:  MOVF   4C,W
0176:  MOVWF  55
0177:  MOVF   4D,W
0178:  MOVWF  54
0179:  MOVLW  18
017A:  MOVWF  52
017B:  CLRF   53
017C:  BTFSS  54.0
017D:  GOTO   196
017E:  MOVF   51,W
017F:  ADDWF  7A,F
0180:  BTFSS  03.0
0181:  GOTO   188
0182:  INCF   79,F
0183:  BTFSS  03.2
0184:  GOTO   188
0185:  INCF   78,F
0186:  BTFSC  03.2
0187:  BSF    53.7
0188:  MOVF   50,W
0189:  ADDWF  79,F
018A:  BTFSS  03.0
018B:  GOTO   18F
018C:  INCF   78,F
018D:  BTFSC  03.2
018E:  BSF    53.7
018F:  MOVF   4F,W
0190:  MOVWF  4C
0191:  BSF    4C.7
0192:  MOVF   4C,W
0193:  ADDWF  78,F
0194:  BTFSC  03.0
0195:  BSF    53.7
0196:  RLF    53,F
0197:  RRF    78,F
0198:  RRF    79,F
0199:  RRF    7A,F
019A:  RRF    56,F
019B:  RRF    55,F
019C:  RRF    54,F
019D:  BCF    03.0
019E:  DECFSZ 52,F
019F:  GOTO   17B
01A0:  MOVLW  01
01A1:  ADDWF  77,F
01A2:  BTFSC  03.0
01A3:  GOTO   1C8
01A4:  BTFSC  78.7
01A5:  GOTO   1AD
01A6:  RLF    56,F
01A7:  RLF    7A,F
01A8:  RLF    79,F
01A9:  RLF    78,F
01AA:  DECF   77,F
01AB:  BTFSC  03.2
01AC:  GOTO   1C8
01AD:  BTFSS  56.7
01AE:  GOTO   1BE
01AF:  INCF   7A,F
01B0:  BTFSS  03.2
01B1:  GOTO   1BE
01B2:  INCF   79,F
01B3:  BTFSS  03.2
01B4:  GOTO   1BE
01B5:  INCF   78,F
01B6:  BTFSS  03.2
01B7:  GOTO   1BE
01B8:  RRF    78,F
01B9:  RRF    79,F
01BA:  RRF    7A,F
01BB:  INCF   77,F
01BC:  BTFSC  03.2
01BD:  GOTO   1C8
01BE:  MOVF   4B,W
01BF:  MOVWF  53
01C0:  MOVF   4F,W
01C1:  XORWF  53,F
01C2:  BTFSS  53.7
01C3:  GOTO   1C6
01C4:  BSF    78.7
01C5:  GOTO   1CC
01C6:  BCF    78.7
01C7:  GOTO   1CC
01C8:  CLRF   77
01C9:  CLRF   78
01CA:  CLRF   79
01CB:  CLRF   7A
01CC:  RETURN
01CD:  MOVLW  8E
01CE:  MOVWF  77
01CF:  MOVF   3D,W
01D0:  SUBWF  77,F
01D1:  MOVF   3E,W
01D2:  MOVWF  79
01D3:  MOVF   3F,W
01D4:  MOVWF  78
01D5:  BSF    79.7
01D6:  MOVF   77,F
01D7:  BTFSC  03.2
01D8:  GOTO   1E4
01D9:  BCF    03.0
01DA:  MOVF   79,F
01DB:  BTFSS  03.2
01DC:  GOTO   1E0
01DD:  MOVF   78,F
01DE:  BTFSC  03.2
01DF:  GOTO   1E4
01E0:  RRF    79,F
01E1:  RRF    78,F
01E2:  DECFSZ 77,F
01E3:  GOTO   1D9
01E4:  BTFSS  3E.7
01E5:  GOTO   1EB
01E6:  COMF   78,F
01E7:  COMF   79,F
01E8:  INCF   78,F
01E9:  BTFSC  03.2
01EA:  INCF   79,F
01EB:  BSF    0A.3
01EC:  BCF    0A.4
01ED:  GOTO   0AE (RETURN)
*
022C:  MOVF   0B,W
022D:  MOVWF  3E
022E:  BCF    0B.7
022F:  BSF    03.5
0230:  BSF    03.6
0231:  BSF    0C.7
0232:  BSF    0C.0
0233:  NOP
0234:  NOP
0235:  BCF    03.5
0236:  BCF    03.6
0237:  BTFSC  3E.7
0238:  BSF    0B.7
0239:  BTFSC  03.0
023A:  GOTO   263
023B:  BSF    03.6
023C:  MOVF   0C,W
023D:  ANDLW  7F
023E:  BCF    03.6
023F:  MOVWF  3E
0240:  BSF    03.6
0241:  MOVF   0D,W
0242:  BCF    03.6
0243:  MOVWF  3F
0244:  BSF    03.6
0245:  MOVF   0F,W
0246:  BCF    03.6
0247:  MOVWF  40
0248:  MOVF   3E,W
0249:  MOVWF  4A
024A:  CALL   200
024B:  MOVF   3F,W
024C:  BSF    03.6
024D:  MOVWF  0D
024E:  BCF    03.6
024F:  MOVF   40,W
0250:  BSF    03.6
0251:  MOVWF  0F
0252:  BCF    03.6
0253:  MOVF   0B,W
0254:  MOVWF  41
0255:  BCF    0B.7
0256:  BSF    03.5
0257:  BSF    03.6
0258:  BSF    0C.7
0259:  BSF    0C.0
025A:  NOP
025B:  NOP
025C:  BCF    03.5
025D:  BCF    03.6
025E:  BTFSC  41.7
025F:  BSF    0B.7
0260:  DECFSZ 3D,F
0261:  GOTO   263
0262:  GOTO   282
0263:  BSF    03.6
0264:  RLF    0C,W
0265:  RLF    0E,W
0266:  ANDLW  7F
0267:  BCF    03.6
0268:  MOVWF  3E
0269:  BSF    03.6
026A:  MOVF   0D,W
026B:  BCF    03.6
026C:  MOVWF  3F
026D:  BSF    03.6
026E:  MOVF   0F,W
026F:  BCF    03.6
0270:  MOVWF  40
0271:  MOVF   3E,W
0272:  MOVWF  4A
0273:  CALL   200
0274:  MOVF   3F,W
0275:  BSF    03.6
0276:  MOVWF  0D
0277:  BCF    03.6
0278:  MOVF   40,W
0279:  BSF    03.6
027A:  MOVWF  0F
027B:  INCF   0D,F
027C:  BTFSC  03.2
027D:  INCF   0F,F
027E:  BCF    03.0
027F:  BCF    03.6
0280:  DECFSZ 3D,F
0281:  GOTO   22C
0282:  RETURN
0283:  MOVF   40,W
0284:  CLRF   78
0285:  SUBWF  3F,W
0286:  BTFSC  03.0
0287:  GOTO   28B
0288:  MOVF   3F,W
0289:  MOVWF  77
028A:  GOTO   297
028B:  CLRF   77
028C:  MOVLW  08
028D:  MOVWF  41
028E:  RLF    3F,F
028F:  RLF    77,F
0290:  MOVF   40,W
0291:  SUBWF  77,W
0292:  BTFSC  03.0
0293:  MOVWF  77
0294:  RLF    78,F
0295:  DECFSZ 41,F
0296:  GOTO   28E
0297:  RETURN
0298:  MOVF   78,W
0299:  MOVF   3D,W
029A:  MOVWF  3F
029B:  MOVLW  64
029C:  MOVWF  40
029D:  CALL   283
029E:  MOVF   77,W
029F:  MOVWF  3D
02A0:  MOVF   78,W
02A1:  MOVLW  30
02A2:  BTFSS  03.2
02A3:  GOTO   2AB
02A4:  BTFSS  3E.1
02A5:  GOTO   2B2
02A6:  BTFSC  3E.3
02A7:  GOTO   2B2
02A8:  BTFSC  3E.4
02A9:  MOVLW  20
02AA:  GOTO   2AE
02AB:  BCF    3E.3
02AC:  BCF    3E.4
02AD:  BSF    3E.0
02AE:  ADDWF  78,F
02AF:  MOVF   78,W
02B0:  MOVWF  4A
02B1:  CALL   200
02B2:  MOVF   3D,W
02B3:  MOVWF  3F
02B4:  MOVLW  0A
02B5:  MOVWF  40
02B6:  CALL   283
02B7:  MOVF   77,W
02B8:  MOVWF  3D
02B9:  MOVF   78,W
02BA:  MOVLW  30
02BB:  BTFSS  03.2
02BC:  GOTO   2C3
02BD:  BTFSC  3E.3
02BE:  GOTO   2C7
02BF:  BTFSS  3E.0
02C0:  GOTO   2C7
02C1:  BTFSC  3E.4
02C2:  MOVLW  20
02C3:  ADDWF  78,F
02C4:  MOVF   78,W
02C5:  MOVWF  4A
02C6:  CALL   200
02C7:  MOVLW  30
02C8:  ADDWF  3D,F
02C9:  MOVF   3D,W
02CA:  MOVWF  4A
02CB:  CALL   200
02CC:  RETURN
02CD:  MOVF   0B,W
02CE:  MOVWF  3D
02CF:  BCF    0B.7
02D0:  BSF    03.5
02D1:  BSF    03.6
02D2:  BSF    0C.7
02D3:  BSF    0C.0
02D4:  NOP
02D5:  NOP
02D6:  BCF    03.5
02D7:  BCF    03.6
02D8:  BTFSC  3D.7
02D9:  BSF    0B.7
02DA:  BSF    03.6
02DB:  MOVF   0C,W
02DC:  ANDLW  7F
02DD:  BTFSC  03.2
02DE:  GOTO   321
02DF:  BCF    03.6
02E0:  MOVWF  3D
02E1:  BSF    03.6
02E2:  MOVF   0D,W
02E3:  BCF    03.6
02E4:  MOVWF  3E
02E5:  BSF    03.6
02E6:  MOVF   0F,W
02E7:  BCF    03.6
02E8:  MOVWF  3F
02E9:  MOVF   3D,W
02EA:  MOVWF  4A
02EB:  CALL   200
02EC:  MOVF   3E,W
02ED:  BSF    03.6
02EE:  MOVWF  0D
02EF:  BCF    03.6
02F0:  MOVF   3F,W
02F1:  BSF    03.6
02F2:  MOVWF  0F
02F3:  BCF    03.6
02F4:  MOVF   0B,W
02F5:  MOVWF  40
02F6:  BCF    0B.7
02F7:  BSF    03.5
02F8:  BSF    03.6
02F9:  BSF    0C.7
02FA:  BSF    0C.0
02FB:  NOP
02FC:  NOP
02FD:  BCF    03.5
02FE:  BCF    03.6
02FF:  BTFSC  40.7
0300:  BSF    0B.7
0301:  BSF    03.6
0302:  RLF    0C,W
0303:  RLF    0E,W
0304:  ANDLW  7F
0305:  BTFSC  03.2
0306:  GOTO   321
0307:  BCF    03.6
0308:  MOVWF  3D
0309:  BSF    03.6
030A:  MOVF   0D,W
030B:  BCF    03.6
030C:  MOVWF  3E
030D:  BSF    03.6
030E:  MOVF   0F,W
030F:  BCF    03.6
0310:  MOVWF  3F
0311:  MOVF   3D,W
0312:  MOVWF  4A
0313:  CALL   200
0314:  MOVF   3E,W
0315:  BSF    03.6
0316:  MOVWF  0D
0317:  BCF    03.6
0318:  MOVF   3F,W
0319:  BSF    03.6
031A:  MOVWF  0F
031B:  INCF   0D,F
031C:  BTFSC  03.2
031D:  INCF   0F,F
031E:  BCF    03.6
031F:  GOTO   2CD
0320:  BSF    03.6
0321:  BCF    03.6
0322:  RETURN
*
038A:  BSF    0A.0
038B:  BSF    0A.1
038C:  BCF    0A.2
038D:  ADDWF  02,F
038E:  GOTO   32F
038F:  GOTO   335
0390:  GOTO   33B
0391:  GOTO   341
*
03E0:  BTFSC  03.1
03E1:  GOTO   3E5
03E2:  MOVLW  52
03E3:  MOVWF  04
03E4:  BCF    03.7
03E5:  CLRF   77
03E6:  CLRF   78
03E7:  CLRF   79
03E8:  CLRF   7A
03E9:  CLRF   52
03EA:  CLRF   53
03EB:  CLRF   54
03EC:  CLRF   55
03ED:  MOVF   51,W
03EE:  IORWF  50,W
03EF:  IORWF  4F,W
03F0:  IORWF  4E,W
03F1:  BTFSC  03.2
03F2:  GOTO   423
03F3:  MOVLW  20
03F4:  MOVWF  56
03F5:  BCF    03.0
03F6:  RLF    4A,F
03F7:  RLF    4B,F
03F8:  RLF    4C,F
03F9:  RLF    4D,F
03FA:  RLF    52,F
03FB:  RLF    53,F
03FC:  RLF    54,F
03FD:  RLF    55,F
03FE:  MOVF   51,W
03FF:  SUBWF  55,W
0400:  BTFSS  03.2
0401:  GOTO   40C
0402:  MOVF   50,W
0403:  SUBWF  54,W
0404:  BTFSS  03.2
0405:  GOTO   40C
0406:  MOVF   4F,W
0407:  SUBWF  53,W
0408:  BTFSS  03.2
0409:  GOTO   40C
040A:  MOVF   4E,W
040B:  SUBWF  52,W
040C:  BTFSS  03.0
040D:  GOTO   41D
040E:  MOVF   4E,W
040F:  SUBWF  52,F
0410:  MOVF   4F,W
0411:  BTFSS  03.0
0412:  INCFSZ 4F,W
0413:  SUBWF  53,F
0414:  MOVF   50,W
0415:  BTFSS  03.0
0416:  INCFSZ 50,W
0417:  SUBWF  54,F
0418:  MOVF   51,W
0419:  BTFSS  03.0
041A:  INCFSZ 51,W
041B:  SUBWF  55,F
041C:  BSF    03.0
041D:  RLF    77,F
041E:  RLF    78,F
041F:  RLF    79,F
0420:  RLF    7A,F
0421:  DECFSZ 56,F
0422:  GOTO   3F5
0423:  MOVF   52,W
0424:  MOVWF  00
0425:  INCF   04,F
0426:  MOVF   53,W
0427:  MOVWF  00
0428:  INCF   04,F
0429:  MOVF   54,W
042A:  MOVWF  00
042B:  INCF   04,F
042C:  MOVF   55,W
042D:  MOVWF  00
042E:  RETURN
042F:  MOVF   04,W
0430:  MOVWF  42
0431:  MOVF   41,W
0432:  MOVWF  44
0433:  BTFSC  03.2
0434:  GOTO   44E
0435:  MOVF   40,W
0436:  MOVWF  4D
0437:  MOVF   3F,W
0438:  MOVWF  4C
0439:  MOVF   3E,W
043A:  MOVWF  4B
043B:  MOVF   3D,W
043C:  MOVWF  4A
043D:  CLRF   51
043E:  CLRF   50
043F:  MOVLW  20
0440:  MOVWF  4F
0441:  MOVLW  82
0442:  MOVWF  4E
0443:  CALL   158
0444:  MOVF   7A,W
0445:  MOVWF  40
0446:  MOVF   79,W
0447:  MOVWF  3F
0448:  MOVF   78,W
0449:  MOVWF  3E
044A:  MOVF   77,W
044B:  MOVWF  3D
044C:  DECFSZ 44,F
044D:  GOTO   435
044E:  MOVF   40,W
044F:  MOVWF  4D
0450:  MOVF   3F,W
0451:  MOVWF  4C
0452:  MOVF   3E,W
0453:  MOVWF  4B
0454:  MOVF   3D,W
0455:  MOVWF  4A
0456:  MOVF   4A,W
0457:  SUBLW  B6
0458:  MOVWF  4A
0459:  CLRF   7A
045A:  MOVF   4B,W
045B:  MOVWF  4E
045C:  BSF    4B.7
045D:  BCF    03.0
045E:  RRF    4B,F
045F:  RRF    4C,F
0460:  RRF    4D,F
0461:  RRF    7A,F
0462:  RRF    79,F
0463:  RRF    78,F
0464:  RRF    77,F
0465:  DECFSZ 4A,F
0466:  GOTO   45D
0467:  BTFSS  4E.7
0468:  GOTO   474
0469:  COMF   77,F
046A:  COMF   78,F
046B:  COMF   79,F
046C:  COMF   7A,F
046D:  INCF   77,F
046E:  BTFSC  03.2
046F:  INCF   78,F
0470:  BTFSC  03.2
0471:  INCF   79,F
0472:  BTFSC  03.2
0473:  INCF   7A,F
0474:  MOVF   7A,W
0475:  MOVWF  40
0476:  MOVF   79,W
0477:  MOVWF  3F
0478:  MOVF   78,W
0479:  MOVWF  3E
047A:  MOVF   77,W
047B:  MOVWF  3D
047C:  BTFSS  40.7
047D:  GOTO   48B
047E:  DECF   42,F
047F:  BSF    42.5
0480:  COMF   3D,F
0481:  COMF   3E,F
0482:  COMF   3F,F
0483:  COMF   40,F
0484:  INCF   3D,F
0485:  BTFSC  03.2
0486:  INCF   3E,F
0487:  BTFSC  03.2
0488:  INCF   3F,F
0489:  BTFSC  03.2
048A:  INCF   40,F
048B:  MOVLW  3B
048C:  MOVWF  49
048D:  MOVLW  9A
048E:  MOVWF  48
048F:  MOVLW  CA
0490:  MOVWF  47
0491:  CLRF   46
0492:  MOVLW  0A
0493:  MOVWF  44
0494:  MOVF   41,W
0495:  BTFSC  03.2
0496:  INCF   42,F
0497:  BSF    03.1
0498:  MOVLW  3D
0499:  MOVWF  04
049A:  BCF    03.7
049B:  MOVF   40,W
049C:  MOVWF  4D
049D:  MOVF   3F,W
049E:  MOVWF  4C
049F:  MOVF   3E,W
04A0:  MOVWF  4B
04A1:  MOVF   3D,W
04A2:  MOVWF  4A
04A3:  MOVF   49,W
04A4:  MOVWF  51
04A5:  MOVF   48,W
04A6:  MOVWF  50
04A7:  MOVF   47,W
04A8:  MOVWF  4F
04A9:  MOVF   46,W
04AA:  MOVWF  4E
04AB:  CALL   3E0
04AC:  MOVF   78,W
04AD:  MOVF   77,F
04AE:  BTFSS  03.2
04AF:  GOTO   4C3
04B0:  INCF   41,W
04B1:  SUBWF  44,W
04B2:  BTFSC  03.2
04B3:  GOTO   4C3
04B4:  MOVF   42,W
04B5:  BTFSC  03.2
04B6:  GOTO   4C5
04B7:  ANDLW  0F
04B8:  SUBWF  44,W
04B9:  BTFSC  03.2
04BA:  GOTO   4BD
04BB:  BTFSC  03.0
04BC:  GOTO   4F5
04BD:  BTFSC  42.7
04BE:  GOTO   4F5
04BF:  BTFSC  42.6
04C0:  GOTO   4C5
04C1:  MOVLW  20
04C2:  GOTO   4F1
04C3:  MOVLW  20
04C4:  ANDWF  42,F
04C5:  BTFSS  42.5
04C6:  GOTO   4D3
04C7:  BCF    42.5
04C8:  MOVF   41,W
04C9:  BTFSS  03.2
04CA:  DECF   42,F
04CB:  MOVF   77,W
04CC:  MOVWF  42
04CD:  MOVLW  2D
04CE:  MOVWF  4A
04CF:  CALL   200
04D0:  MOVF   42,W
04D1:  MOVWF  77
04D2:  CLRF   42
04D3:  MOVF   41,W
04D4:  SUBWF  44,W
04D5:  BTFSS  03.2
04D6:  GOTO   4E1
04D7:  MOVF   77,W
04D8:  MOVWF  42
04D9:  MOVLW  2E
04DA:  MOVWF  4A
04DB:  CALL   200
04DC:  MOVF   42,W
04DD:  MOVWF  77
04DE:  MOVLW  20
04DF:  ANDWF  42,F
04E0:  MOVLW  00
04E1:  MOVLW  30
04E2:  BTFSS  42.5
04E3:  GOTO   4F1
04E4:  BCF    42.5
04E5:  MOVF   41,W
04E6:  BTFSS  03.2
04E7:  DECF   42,F
04E8:  MOVF   77,W
04E9:  MOVWF  42
04EA:  MOVLW  2D
04EB:  MOVWF  4A
04EC:  CALL   200
04ED:  MOVF   42,W
04EE:  MOVWF  77
04EF:  CLRF   42
04F0:  MOVLW  30
04F1:  ADDWF  77,F
04F2:  MOVF   77,W
04F3:  MOVWF  4A
04F4:  CALL   200
04F5:  BCF    03.1
04F6:  MOVF   49,W
04F7:  MOVWF  4D
04F8:  MOVF   48,W
04F9:  MOVWF  4C
04FA:  MOVF   47,W
04FB:  MOVWF  4B
04FC:  MOVF   46,W
04FD:  MOVWF  4A
04FE:  CLRF   51
04FF:  CLRF   50
0500:  CLRF   4F
0501:  MOVLW  0A
0502:  MOVWF  4E
0503:  CALL   3E0
0504:  MOVF   7A,W
0505:  MOVWF  49
0506:  MOVF   79,W
0507:  MOVWF  48
0508:  MOVF   78,W
0509:  MOVWF  47
050A:  MOVF   77,W
050B:  MOVWF  46
050C:  DECFSZ 44,F
050D:  GOTO   497
050E:  RETURN
050F:  MOVF   3E,W
0510:  MOVWF  45
0511:  MOVF   42,W
0512:  XORWF  45,F
0513:  BTFSS  45.7
0514:  GOTO   51A
0515:  BCF    03.2
0516:  BCF    03.0
0517:  BTFSC  3E.7
0518:  BSF    03.0
0519:  GOTO   54D
051A:  MOVF   3E,W
051B:  MOVWF  45
051C:  MOVF   41,W
051D:  MOVWF  46
051E:  MOVF   3D,W
051F:  SUBWF  46,F
0520:  BTFSC  03.2
0521:  GOTO   528
0522:  BTFSS  45.7
0523:  GOTO   54D
0524:  MOVF   03,W
0525:  XORLW  01
0526:  MOVWF  03
0527:  GOTO   54D
0528:  MOVF   42,W
0529:  MOVWF  46
052A:  MOVF   3E,W
052B:  SUBWF  46,F
052C:  BTFSC  03.2
052D:  GOTO   534
052E:  BTFSS  45.7
052F:  GOTO   54D
0530:  MOVF   03,W
0531:  XORLW  01
0532:  MOVWF  03
0533:  GOTO   54D
0534:  MOVF   43,W
0535:  MOVWF  46
0536:  MOVF   3F,W
0537:  SUBWF  46,F
0538:  BTFSC  03.2
0539:  GOTO   540
053A:  BTFSS  45.7
053B:  GOTO   54D
053C:  MOVF   03,W
053D:  XORLW  01
053E:  MOVWF  03
053F:  GOTO   54D
0540:  MOVF   44,W
0541:  MOVWF  46
0542:  MOVF   40,W
0543:  SUBWF  46,F
0544:  BTFSC  03.2
0545:  GOTO   54C
0546:  BTFSS  45.7
0547:  GOTO   54D
0548:  MOVF   03,W
0549:  XORLW  01
054A:  MOVWF  03
054B:  GOTO   54D
054C:  BCF    03.0
054D:  BSF    0A.3
054E:  BCF    0A.4
054F:  GOTO   26C (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
0076:  MOVLW  4B
0077:  MOVWF  04
0078:  BCF    03.7
0079:  MOVF   00,W
007A:  BTFSC  03.2
007B:  GOTO   089
007C:  MOVLW  06
007D:  MOVWF  78
007E:  CLRF   77
007F:  DECFSZ 77,F
0080:  GOTO   07F
0081:  DECFSZ 78,F
0082:  GOTO   07E
0083:  MOVLW  7B
0084:  MOVWF  77
0085:  DECFSZ 77,F
0086:  GOTO   085
0087:  DECFSZ 00,F
0088:  GOTO   07C
0089:  RETURN
....................  
....................  
....................  
.................... #fuses nowdt,noprotect,nolvp,nodebug,xt 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00A7:  MOVLW  0F
00A8:  BSF    03.5
00A9:  ANDWF  08,W
00AA:  IORLW  F0
00AB:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00AC:  BCF    03.5
00AD:  BSF    08.2
....................    delay_cycles(1); 
00AE:  NOP
....................    lcd_output_enable(1); 
00AF:  BSF    08.0
....................    delay_cycles(1); 
00B0:  NOP
....................    high = lcd_read_nibble(); 
00B1:  CALL   09B
00B2:  MOVF   78,W
00B3:  MOVWF  52
....................        
....................    lcd_output_enable(0); 
00B4:  BCF    08.0
....................    delay_cycles(1); 
00B5:  NOP
....................    lcd_output_enable(1); 
00B6:  BSF    08.0
....................    delay_us(1); 
00B7:  GOTO   0B8
00B8:  GOTO   0B9
00B9:  NOP
....................    low = lcd_read_nibble(); 
00BA:  CALL   09B
00BB:  MOVF   78,W
00BC:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
00BD:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00BE:  MOVLW  0F
00BF:  BSF    03.5
00C0:  ANDWF  08,W
00C1:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00C2:  BCF    03.5
00C3:  SWAPF  52,W
00C4:  MOVWF  77
00C5:  MOVLW  F0
00C6:  ANDWF  77,F
00C7:  MOVF   77,W
00C8:  IORWF  51,W
00C9:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
009B:  MOVF   08,W
009C:  MOVWF  77
009D:  SWAPF  08,W
009E:  ANDLW  0F
009F:  MOVWF  78
....................   #endif 
00A0:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
008A:  SWAPF  52,W
008B:  ANDLW  F0
008C:  MOVWF  77
008D:  MOVLW  0F
008E:  ANDWF  08,W
008F:  IORWF  77,W
0090:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0091:  NOP
....................    lcd_output_enable(1); 
0092:  BSF    08.0
....................    delay_us(2); 
0093:  MOVLW  02
0094:  MOVWF  77
0095:  DECFSZ 77,F
0096:  GOTO   095
0097:  GOTO   098
0098:  NOP
....................    lcd_output_enable(0); 
0099:  BCF    08.0
009A:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00A1:  BSF    03.5
00A2:  BCF    08.0
....................    lcd_rs_tris(); 
00A3:  BCF    08.1
....................    lcd_rw_tris(); 
00A4:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00A5:  BCF    03.5
00A6:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00CA:  MOVF   78,W
00CB:  MOVWF  51
00CC:  BTFSC  51.7
00CD:  GOTO   0A7
....................    lcd_output_rs(address); 
00CE:  BTFSS  4F.0
00CF:  BCF    08.1
00D0:  BTFSC  4F.0
00D1:  BSF    08.1
....................    delay_cycles(1); 
00D2:  NOP
....................    lcd_output_rw(0); 
00D3:  BCF    08.2
....................    delay_cycles(1); 
00D4:  NOP
....................    lcd_output_enable(0); 
00D5:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00D6:  SWAPF  50,W
00D7:  MOVWF  51
00D8:  MOVLW  0F
00D9:  ANDWF  51,F
00DA:  MOVF   51,W
00DB:  MOVWF  52
00DC:  CALL   08A
....................    lcd_send_nibble(n & 0xf); 
00DD:  MOVF   50,W
00DE:  ANDLW  0F
00DF:  MOVWF  51
00E0:  MOVWF  52
00E1:  CALL   08A
00E2:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00E3:  MOVLW  28
00E4:  MOVWF  3E
00E5:  MOVLW  0C
00E6:  MOVWF  3F
00E7:  MOVLW  01
00E8:  MOVWF  40
00E9:  MOVLW  06
00EA:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00EB:  BCF    08.0
....................    lcd_output_rs(0); 
00EC:  BCF    08.1
....................    lcd_output_rw(0); 
00ED:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00EE:  MOVLW  0F
00EF:  BSF    03.5
00F0:  ANDWF  08,W
00F1:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00F2:  BCF    08.0
....................    lcd_rs_tris(); 
00F3:  BCF    08.1
....................    lcd_rw_tris(); 
00F4:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
00F5:  MOVLW  0F
00F6:  BCF    03.5
00F7:  MOVWF  4B
00F8:  CALL   076
....................    for(i=1;i<=3;++i) 
00F9:  MOVLW  01
00FA:  MOVWF  3D
00FB:  MOVF   3D,W
00FC:  SUBLW  03
00FD:  BTFSS  03.0
00FE:  GOTO   107
....................    { 
....................        lcd_send_nibble(3); 
00FF:  MOVLW  03
0100:  MOVWF  52
0101:  CALL   08A
....................        delay_ms(5); 
0102:  MOVLW  05
0103:  MOVWF  4B
0104:  CALL   076
0105:  INCF   3D,F
0106:  GOTO   0FB
....................    } 
....................     
....................    lcd_send_nibble(2); 
0107:  MOVLW  02
0108:  MOVWF  52
0109:  CALL   08A
....................    delay_ms(5); 
010A:  MOVLW  05
010B:  MOVWF  4B
010C:  CALL   076
....................    for(i=0;i<=3;++i) 
010D:  CLRF   3D
010E:  MOVF   3D,W
010F:  SUBLW  03
0110:  BTFSS  03.0
0111:  GOTO   11E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0112:  MOVLW  3E
0113:  ADDWF  3D,W
0114:  MOVWF  04
0115:  BCF    03.7
0116:  MOVF   00,W
0117:  MOVWF  42
0118:  CLRF   4F
0119:  MOVF   42,W
011A:  MOVWF  50
011B:  CALL   0A1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
011C:  INCF   3D,F
011D:  GOTO   10E
011E:  BSF    0A.3
011F:  BCF    0A.4
0120:  GOTO   041 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01EE:  DECFSZ 4C,W
01EF:  GOTO   1F1
01F0:  GOTO   1F4
....................       address=LCD_LINE_TWO; 
01F1:  MOVLW  40
01F2:  MOVWF  4D
01F3:  GOTO   1F5
....................    else 
....................       address=0; 
01F4:  CLRF   4D
....................       
....................    address+=x-1; 
01F5:  MOVLW  01
01F6:  SUBWF  4B,W
01F7:  ADDWF  4D,F
....................    lcd_send_byte(0,0x80|address); 
01F8:  MOVF   4D,W
01F9:  IORLW  80
01FA:  MOVWF  4E
01FB:  CLRF   4F
01FC:  MOVF   4E,W
01FD:  MOVWF  50
01FE:  CALL   0A1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01FF:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0200:  MOVF   4A,W
0201:  XORLW  07
0202:  BTFSC  03.2
0203:  GOTO   20E
0204:  XORLW  0B
0205:  BTFSC  03.2
0206:  GOTO   213
0207:  XORLW  06
0208:  BTFSC  03.2
0209:  GOTO   21B
020A:  XORLW  02
020B:  BTFSC  03.2
020C:  GOTO   221
020D:  GOTO   226
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
020E:  MOVLW  01
020F:  MOVWF  4B
0210:  MOVWF  4C
0211:  CALL   1EE
0212:  GOTO   22B
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0213:  CLRF   4F
0214:  MOVLW  01
0215:  MOVWF  50
0216:  CALL   0A1
....................                      delay_ms(2); 
0217:  MOVLW  02
0218:  MOVWF  4B
0219:  CALL   076
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
021A:  GOTO   22B
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
021B:  MOVLW  01
021C:  MOVWF  4B
021D:  MOVLW  02
021E:  MOVWF  4C
021F:  CALL   1EE
0220:  GOTO   22B
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0221:  CLRF   4F
0222:  MOVLW  10
0223:  MOVWF  50
0224:  CALL   0A1
0225:  GOTO   22B
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0226:  MOVLW  01
0227:  MOVWF  4F
0228:  MOVF   4A,W
0229:  MOVWF  50
022A:  CALL   0A1
....................      #endif 
....................    } 
022B:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #use standard_io(B) 
.................... #use fast_io(E) 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0392:  MOVF   3E,W
0393:  MOVWF  7A
0394:  MOVF   3D,W
0395:  MOVWF  04
0396:  BCF    03.7
0397:  BTFSC  7A.0
0398:  BSF    03.7
0399:  MOVF   00,F
039A:  BTFSC  03.2
039B:  GOTO   3DC
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
039C:  MOVF   3E,W
039D:  MOVWF  42
039E:  MOVF   3D,W
039F:  MOVWF  41
03A0:  MOVF   40,W
03A1:  MOVWF  44
03A2:  MOVF   3F,W
03A3:  MOVWF  43
03A4:  MOVF   44,W
03A5:  MOVWF  7A
03A6:  MOVF   43,W
03A7:  MOVWF  04
03A8:  BCF    03.7
03A9:  BTFSC  7A.0
03AA:  BSF    03.7
03AB:  MOVF   00,F
03AC:  BTFSC  03.2
03AD:  GOTO   3C9
03AE:  MOVF   42,W
03AF:  MOVWF  7A
03B0:  MOVF   41,W
03B1:  MOVWF  04
03B2:  BCF    03.7
03B3:  BTFSC  7A.0
03B4:  BSF    03.7
03B5:  MOVF   00,W
03B6:  MOVWF  45
03B7:  MOVF   44,W
03B8:  MOVWF  7A
03B9:  MOVF   43,W
03BA:  MOVWF  04
03BB:  BCF    03.7
03BC:  BTFSC  7A.0
03BD:  BSF    03.7
03BE:  MOVF   00,W
03BF:  SUBWF  45,W
03C0:  BTFSS  03.2
03C1:  GOTO   3C9
03C2:  INCF   41,F
03C3:  BTFSC  03.2
03C4:  INCF   42,F
03C5:  INCF   43,F
03C6:  BTFSC  03.2
03C7:  INCF   44,F
03C8:  GOTO   3A4
....................  
....................       if (*t == '\0') 
03C9:  MOVF   44,W
03CA:  MOVWF  7A
03CB:  MOVF   43,W
03CC:  MOVWF  04
03CD:  BCF    03.7
03CE:  BTFSC  7A.0
03CF:  BSF    03.7
03D0:  MOVF   00,F
03D1:  BTFSS  03.2
03D2:  GOTO   3D8
....................          return s1; 
03D3:  MOVF   3D,W
03D4:  MOVWF  78
03D5:  MOVF   3E,W
03D6:  MOVWF  79
03D7:  GOTO   3DF
....................       ++s1; 
03D8:  INCF   3D,F
03D9:  BTFSC  03.2
03DA:  INCF   3E,F
....................       #ifdef FASTER_BUT_MORE_ROM 
03DB:  GOTO   392
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
03DC:  MOVLW  00
03DD:  MOVWF  78
03DE:  MOVWF  79
03DF:  RETURN
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
080E:  BCF    03.5
080F:  CLRF   20
0810:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <kbd4x4.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     KBD_LIB.C by Redraven                         //// 
.................... ////                                                                   //// 
.................... ////                     Derived from KBDD.C                           //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81              // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83              // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                  // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B0) 
....................  
.................... #define COL0 (1 << 0) // PIN_B0 
.................... #define COL1 (1 << 1) // PIN_B1 
.................... #define COL2 (1 << 2) // PIN_B2 
.................... #define COL3 (1 << 3) // PIN_B3 
....................  
.................... #define ROW0 (1 << 4) // PIN_B4 
.................... #define ROW1 (1 << 5) // PIN_B5 
.................... #define ROW2 (1 << 6) // PIN_B6 
.................... #define ROW3 (1 << 7) // PIN_B7 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
.................... void kbd_init() { 
*
0121:  BSF    0A.3
0122:  BCF    0A.4
0123:  GOTO   044 (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static byte kbd_call_count; 
*
0811:  CLRF   22
....................    static short int kbd_down; 
0812:  BCF    23.0
....................    static char last_key; 
0813:  CLRF   24
....................    static byte col; 
0814:  CLRF   25
....................  
....................    byte kchar; 
....................    byte row; 
....................  
....................    kchar='\0'; 
*
0323:  CLRF   3D
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0324:  INCF   22,F
0325:  MOVF   22,W
0326:  SUBLW  21
0327:  BTFSC  03.0
0328:  GOTO   383
....................        switch (col) { 
0329:  MOVF   25,W
032A:  ADDLW  FC
032B:  BTFSC  03.0
032C:  GOTO   346
032D:  ADDLW  04
032E:  GOTO   38A
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
032F:  MOVLW  FE
0330:  BSF    03.5
0331:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
0332:  BCF    03.5
0333:  MOVWF  06
....................                     break; 
0334:  GOTO   346
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
0335:  MOVLW  FD
0336:  BSF    03.5
0337:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
0338:  BCF    03.5
0339:  MOVWF  06
....................                     break; 
033A:  GOTO   346
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
033B:  MOVLW  FB
033C:  BSF    03.5
033D:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
033E:  BCF    03.5
033F:  MOVWF  06
....................                     break; 
0340:  GOTO   346
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3); 
0341:  MOVLW  F7
0342:  BSF    03.5
0343:  MOVWF  06
....................                     kbd=~COL3&ALL_PINS; 
0344:  BCF    03.5
0345:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
0346:  BTFSS  23.0
0347:  GOTO   352
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
0348:  MOVF   06,W
0349:  ANDLW  F0
034A:  SUBLW  F0
034B:  BTFSS  03.2
034C:  GOTO   351
....................            kbd_down=false; 
034D:  BCF    23.0
....................            kchar=last_key; 
034E:  MOVF   24,W
034F:  MOVWF  3D
....................            last_key='\0'; 
0350:  CLRF   24
....................          } 
....................        } else { 
0351:  GOTO   382
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0352:  MOVF   06,W
0353:  ANDLW  F0
0354:  SUBLW  F0
0355:  BTFSC  03.2
0356:  GOTO   37D
....................              if((kbd & ROW0)==0) 
0357:  MOVF   06,W
0358:  ANDLW  10
0359:  BTFSS  03.2
035A:  GOTO   35D
....................                row=0; 
035B:  CLRF   3E
035C:  GOTO   371
....................              else if((kbd & ROW1)==0) 
035D:  MOVF   06,W
035E:  ANDLW  20
035F:  BTFSS  03.2
0360:  GOTO   364
....................                row=1; 
0361:  MOVLW  01
0362:  MOVWF  3E
0363:  GOTO   371
....................              else if((kbd & ROW2)==0) 
0364:  MOVF   06,W
0365:  ANDLW  40
0366:  BTFSS  03.2
0367:  GOTO   36B
....................                row=2; 
0368:  MOVLW  02
0369:  MOVWF  3E
036A:  GOTO   371
....................              else if((kbd & ROW3)==0) 
036B:  MOVF   06,W
036C:  ANDLW  80
036D:  BTFSS  03.2
036E:  GOTO   371
....................                row=3; 
036F:  MOVLW  03
0370:  MOVWF  3E
....................              last_key =KEYS[row][col]; 
0371:  RLF    3E,W
0372:  MOVWF  77
0373:  RLF    77,F
0374:  MOVLW  FC
0375:  ANDWF  77,F
0376:  MOVF   77,W
0377:  ADDWF  25,W
0378:  CALL   004
0379:  MOVWF  78
037A:  MOVWF  24
....................              kbd_down = true; 
037B:  BSF    23.0
....................           } else { 
037C:  GOTO   382
....................              ++col; 
037D:  INCF   25,F
....................              if(col==4) 
037E:  MOVF   25,W
037F:  SUBLW  04
0380:  BTFSC  03.2
....................                col=0; 
0381:  CLRF   25
....................           } 
....................        } 
....................       kbd_call_count=0; 
0382:  CLRF   22
....................    } 
....................   set_tris_kbd(ALL_PINS); 
0383:  MOVLW  FF
0384:  BSF    03.5
0385:  MOVWF  06
....................   return(kchar); 
0386:  BCF    03.5
0387:  MOVF   3D,W
0388:  MOVWF  78
0389:  RETURN
.................... } 
....................  
....................  
.................... char k; 
....................  
.................... int num=0; 
.................... char clave_entrada[] = "1111"; 
*
0815:  MOVLW  31
0816:  MOVWF  28
0817:  MOVWF  29
0818:  MOVWF  2A
0819:  MOVWF  2B
081A:  CLRF   2C
.................... char clave [4]; 
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   27
0804:  MOVLW  FF
0805:  MOVWF  31
0806:  BSF    03.5
0807:  BSF    1F.0
0808:  BSF    1F.1
0809:  BSF    1F.2
080A:  BCF    1F.3
080B:  MOVLW  07
080C:  MOVWF  1C
080D:  BCF    03.7
....................  
.................... { 
.................... setup_adc(adc_clock_internal); 
*
081B:  BSF    03.5
081C:  BCF    1F.6
081D:  BCF    03.5
081E:  BSF    1F.6
081F:  BSF    1F.7
0820:  BSF    03.5
0821:  BSF    1F.7
0822:  BCF    03.5
0823:  BSF    1F.0
.................... setup_adc_ports(all_analog); 
0824:  BSF    03.5
0825:  BCF    1F.0
0826:  BCF    1F.1
0827:  BCF    1F.2
0828:  BCF    1F.3
.................... SET_TRIS_D(0xFF); 
0829:  MOVLW  FF
082A:  MOVWF  08
.................... SET_TRIS_B(0xFF); 
082B:  MOVWF  06
.................... SET_TRIS_C(0xFF); 
082C:  MOVWF  07
082D:  BCF    03.5
082E:  MOVWF  31
....................  
....................  
....................  
.................... setup_timer_2(t2_div_by_16,155,1); 
082F:  MOVLW  00
0830:  MOVWF  78
0831:  IORLW  06
0832:  MOVWF  12
0833:  MOVLW  9B
0834:  BSF    03.5
0835:  MOVWF  12
.................... setup_ccp1(ccp_pwm); 
0836:  BCF    03.5
0837:  BCF    31.2
0838:  MOVF   31,W
0839:  BSF    03.5
083A:  MOVWF  07
083B:  BCF    03.5
083C:  BCF    07.2
083D:  MOVLW  0C
083E:  MOVWF  17
....................  
....................  
.................... int8 a; 
.................... int8 temp; 
.................... float valor_a; 
.................... float pot; 
.................... lcd_init(); 
083F:  BCF    0A.3
0840:  GOTO   0E3
0841:  BSF    0A.3
....................  
....................  
....................  
....................  
.................... kbd_init(); 
0842:  BCF    0A.3
0843:  GOTO   121
0844:  BSF    0A.3
.................... port_b_pullups(true); 
0845:  BSF    03.5
0846:  BCF    01.7
....................  
....................  
....................  
....................  
.................... int8 pwm= (temp*625)/1024; 
0847:  BCF    03.5
0848:  CLRF   3E
0849:  MOVF   33,W
084A:  MOVWF  3D
084B:  MOVLW  02
084C:  MOVWF  40
084D:  MOVLW  71
084E:  MOVWF  3F
084F:  BCF    0A.3
0850:  GOTO   124
0851:  BSF    0A.3
0852:  MOVF   79,W
0853:  MOVWF  3E
0854:  MOVF   78,W
0855:  MOVWF  3D
0856:  CLRF   7A
0857:  RRF    3E,W
0858:  MOVWF  79
0859:  RRF    79,F
085A:  MOVLW  3F
085B:  ANDWF  79,F
085C:  MOVF   79,W
085D:  MOVWF  3C
....................  
.................... //625/1024 
....................    while(TRUE) 
....................    { 
....................   
....................     
....................  
....................       if(input(PIN_C5)==1){         //Sensor Temperatura 
085E:  BSF    31.5
085F:  MOVF   31,W
0860:  BSF    03.5
0861:  MOVWF  07
0862:  BCF    03.5
0863:  BTFSS  07.5
0864:  GOTO   1BA
....................    while(input(PIN_C5)==1); 
0865:  BSF    31.5
0866:  MOVF   31,W
0867:  BSF    03.5
0868:  MOVWF  07
0869:  BCF    03.5
086A:  BTFSC  07.5
086B:  GOTO   065
....................    delay_ms(20); 
086C:  MOVLW  14
086D:  MOVWF  4B
086E:  BCF    0A.3
086F:  CALL   076
0870:  BSF    0A.3
....................  
....................       while(input(pin_C6)!=1){ 
0871:  BSF    31.6
0872:  MOVF   31,W
0873:  BSF    03.5
0874:  MOVWF  07
0875:  BCF    03.5
0876:  BTFSC  07.6
0877:  GOTO   1BA
....................          set_adc_channel(0); 
0878:  MOVLW  00
0879:  MOVWF  78
087A:  MOVF   1F,W
087B:  ANDLW  C7
087C:  IORWF  78,W
087D:  MOVWF  1F
....................          delay_us(20); 
087E:  MOVLW  20
087F:  MOVWF  77
0880:  DECFSZ 77,F
0881:  GOTO   080
0882:  GOTO   083
0883:  NOP
....................           a=read_adc(); 
0884:  BSF    1F.2
0885:  BTFSC  1F.2
0886:  GOTO   085
0887:  BSF    03.5
0888:  MOVF   1E,W
0889:  BCF    03.5
088A:  MOVWF  32
....................          temp=a*0.4882; 
088B:  CLRF   3E
088C:  MOVF   32,W
088D:  MOVWF  3D
088E:  BCF    0A.3
088F:  CALL   13B
0890:  BSF    0A.3
0891:  MOVF   7A,W
0892:  MOVWF  4D
0893:  MOVF   79,W
0894:  MOVWF  4C
0895:  MOVF   78,W
0896:  MOVWF  4B
0897:  MOVF   77,W
0898:  MOVWF  4A
0899:  MOVLW  5A
089A:  MOVWF  51
089B:  MOVLW  F5
089C:  MOVWF  50
089D:  MOVLW  79
089E:  MOVWF  4F
089F:  MOVLW  7D
08A0:  MOVWF  4E
08A1:  BCF    0A.3
08A2:  CALL   158
08A3:  BSF    0A.3
08A4:  MOVF   7A,W
08A5:  MOVWF  40
08A6:  MOVF   79,W
08A7:  MOVWF  3F
08A8:  MOVF   78,W
08A9:  MOVWF  3E
08AA:  MOVF   77,W
08AB:  MOVWF  3D
08AC:  BCF    0A.3
08AD:  GOTO   1CD
08AE:  BSF    0A.3
08AF:  MOVF   78,W
08B0:  MOVWF  33
....................        
....................      
....................          lcd_gotoxy(2,1); 
08B1:  MOVLW  02
08B2:  MOVWF  4B
08B3:  MOVLW  01
08B4:  MOVWF  4C
08B5:  BCF    0A.3
08B6:  CALL   1EE
08B7:  BSF    0A.3
....................          printf(lcd_putc,"La temp \nes: %u C",temp); 
08B8:  MOVLW  18
08B9:  BSF    03.6
08BA:  MOVWF  0D
08BB:  MOVLW  00
08BC:  MOVWF  0F
08BD:  BCF    03.0
08BE:  MOVLW  0D
08BF:  BCF    03.6
08C0:  MOVWF  3D
08C1:  BCF    0A.3
08C2:  CALL   22C
08C3:  BSF    0A.3
08C4:  MOVF   33,W
08C5:  MOVWF  3D
08C6:  MOVLW  1B
08C7:  MOVWF  3E
08C8:  BCF    0A.3
08C9:  CALL   298
08CA:  BSF    0A.3
08CB:  MOVLW  20
08CC:  MOVWF  4A
08CD:  BCF    0A.3
08CE:  CALL   200
08CF:  BSF    0A.3
08D0:  MOVLW  43
08D1:  MOVWF  4A
08D2:  BCF    0A.3
08D3:  CALL   200
08D4:  BSF    0A.3
....................          delay_us(20); 
08D5:  MOVLW  20
08D6:  MOVWF  77
08D7:  DECFSZ 77,F
08D8:  GOTO   0D7
08D9:  GOTO   0DA
08DA:  NOP
....................  
....................          switch(temp){ 
08DB:  MOVF   33,W
08DC:  XORLW  19
08DD:  BTFSC  03.2
08DE:  GOTO   0E3
08DF:  XORLW  04
08E0:  BTFSC  03.2
08E1:  GOTO   0E4
08E2:  GOTO   0EC
....................               case 25:        set_pwm1_duty(0);  
08E3:  CLRF   15
....................  
....................               case 29:       delay_us(20); 
08E4:  MOVLW  20
08E5:  MOVWF  77
08E6:  DECFSZ 77,F
08E7:  GOTO   0E6
08E8:  GOTO   0E9
08E9:  NOP
....................                              set_pwm1_duty(pwm); // alarma 
08EA:  MOVF   3C,W
08EB:  MOVWF  15
....................              
....................       }  
....................        
....................       output_low(pin_b0); 
08EC:  BSF    03.5
08ED:  BCF    06.0
08EE:  BCF    03.5
08EF:  BCF    06.0
....................        
....................  
....................  
.................... if (temp>30){ 
08F0:  MOVF   33,W
08F1:  SUBLW  1E
08F2:  BTFSC  03.0
08F3:  GOTO   1B9
....................       lcd_putc('\f'); 
08F4:  MOVLW  0C
08F5:  MOVWF  4A
08F6:  BCF    0A.3
08F7:  CALL   200
08F8:  BSF    0A.3
....................      lcd_gotoxy(1,1); 
08F9:  MOVLW  01
08FA:  MOVWF  4B
08FB:  MOVWF  4C
08FC:  BCF    0A.3
08FD:  CALL   1EE
08FE:  BSF    0A.3
....................       lcd_putc("INGRESAR CLAVE"); 
08FF:  MOVLW  21
0900:  BSF    03.6
0901:  MOVWF  0D
0902:  MOVLW  00
0903:  MOVWF  0F
0904:  BCF    0A.3
0905:  BCF    03.6
0906:  CALL   2CD
0907:  BSF    0A.3
.................... num = 0; 
0908:  CLRF   27
....................             while(num<4){ 
0909:  MOVF   27,W
090A:  SUBLW  03
090B:  BTFSS  03.0
090C:  GOTO   12B
....................                   k=kbd_getc(); 
090D:  BCF    0A.3
090E:  CALL   323
090F:  BSF    0A.3
0910:  MOVF   78,W
0911:  MOVWF  26
....................                   if(k != 0){ 
0912:  MOVF   26,F
0913:  BTFSC  03.2
0914:  GOTO   12A
....................                   clave[num]=k; 
0915:  MOVLW  2D
0916:  ADDWF  27,W
0917:  MOVWF  04
0918:  BCF    03.7
0919:  MOVF   26,W
091A:  MOVWF  00
....................                   num++; 
091B:  INCF   27,F
....................                   lcd_gotoxy(num+1,2); 
091C:  MOVLW  01
091D:  ADDWF  27,W
091E:  MOVWF  3D
091F:  MOVWF  4B
0920:  MOVLW  02
0921:  MOVWF  4C
0922:  BCF    0A.3
0923:  CALL   1EE
0924:  BSF    0A.3
....................                   lcd_putc(k); 
0925:  MOVF   26,W
0926:  MOVWF  4A
0927:  BCF    0A.3
0928:  CALL   200
0929:  BSF    0A.3
....................             } 
092A:  GOTO   109
....................          } 
....................       delay_ms(150); 
092B:  MOVLW  96
092C:  MOVWF  4B
092D:  BCF    0A.3
092E:  CALL   076
092F:  BSF    0A.3
....................  
.................... if(strstr(clave , clave_entrada)){ 
0930:  CLRF   3E
0931:  MOVLW  2D
0932:  MOVWF  3D
0933:  CLRF   40
0934:  MOVLW  28
0935:  MOVWF  3F
0936:  BCF    0A.3
0937:  CALL   392
0938:  BSF    0A.3
0939:  MOVF   78,W
093A:  IORWF  79,W
093B:  BTFSC  03.2
093C:  GOTO   19E
....................       lcd_putc('\f'); 
093D:  MOVLW  0C
093E:  MOVWF  4A
093F:  BCF    0A.3
0940:  CALL   200
0941:  BSF    0A.3
....................       lcd_gotoxy(1,1); 
0942:  MOVLW  01
0943:  MOVWF  4B
0944:  MOVWF  4C
0945:  BCF    0A.3
0946:  CALL   1EE
0947:  BSF    0A.3
....................       lcd_putc(" clave correcta"); 
0948:  MOVLW  29
0949:  BSF    03.6
094A:  MOVWF  0D
094B:  MOVLW  00
094C:  MOVWF  0F
094D:  BCF    0A.3
094E:  BCF    03.6
094F:  CALL   2CD
0950:  BSF    0A.3
....................  
....................   delay_ms(100); 
0951:  MOVLW  64
0952:  MOVWF  4B
0953:  BCF    0A.3
0954:  CALL   076
0955:  BSF    0A.3
....................       lcd_gotoxy(1,2); 
0956:  MOVLW  01
0957:  MOVWF  4B
0958:  MOVLW  02
0959:  MOVWF  4C
095A:  BCF    0A.3
095B:  CALL   1EE
095C:  BSF    0A.3
....................       lcd_putc(" Adelante!"); 
095D:  MOVLW  31
095E:  BSF    03.6
095F:  MOVWF  0D
0960:  MOVLW  00
0961:  MOVWF  0F
0962:  BCF    0A.3
0963:  BCF    03.6
0964:  CALL   2CD
0965:  BSF    0A.3
.................... delay_ms(150); 
0966:  MOVLW  96
0967:  MOVWF  4B
0968:  BCF    0A.3
0969:  CALL   076
096A:  BSF    0A.3
....................  
....................  
....................  
.................... lcd_putc('\f'); 
096B:  MOVLW  0C
096C:  MOVWF  4A
096D:  BCF    0A.3
096E:  CALL   200
096F:  BSF    0A.3
.................... lcd_gotoxy(1,2); 
0970:  MOVLW  01
0971:  MOVWF  4B
0972:  MOVLW  02
0973:  MOVWF  4C
0974:  BCF    0A.3
0975:  CALL   1EE
0976:  BSF    0A.3
.................... printf(lcd_putc,"La temp \nes: %u C",temp); 
0977:  MOVLW  37
0978:  BSF    03.6
0979:  MOVWF  0D
097A:  MOVLW  00
097B:  MOVWF  0F
097C:  BCF    03.0
097D:  MOVLW  0D
097E:  BCF    03.6
097F:  MOVWF  3D
0980:  BCF    0A.3
0981:  CALL   22C
0982:  BSF    0A.3
0983:  MOVF   33,W
0984:  MOVWF  3D
0985:  MOVLW  1B
0986:  MOVWF  3E
0987:  BCF    0A.3
0988:  CALL   298
0989:  BSF    0A.3
098A:  MOVLW  20
098B:  MOVWF  4A
098C:  BCF    0A.3
098D:  CALL   200
098E:  BSF    0A.3
098F:  MOVLW  43
0990:  MOVWF  4A
0991:  BCF    0A.3
0992:  CALL   200
0993:  BSF    0A.3
.................... delay_ms(2000); 
0994:  MOVLW  08
0995:  MOVWF  3D
0996:  MOVLW  FA
0997:  MOVWF  4B
0998:  BCF    0A.3
0999:  CALL   076
099A:  BSF    0A.3
099B:  DECFSZ 3D,F
099C:  GOTO   196
....................  
.................... } 
099D:  GOTO   1B9
.................... else { 
....................       output_high(PIN_E1); 
099E:  BSF    09.1
....................       output_low(PIN_E0); 
099F:  BCF    09.0
....................       lcd_putc('\f'); 
09A0:  MOVLW  0C
09A1:  MOVWF  4A
09A2:  BCF    0A.3
09A3:  CALL   200
09A4:  BSF    0A.3
....................       lcd_gotoxy(1,1); 
09A5:  MOVLW  01
09A6:  MOVWF  4B
09A7:  MOVWF  4C
09A8:  BCF    0A.3
09A9:  CALL   1EE
09AA:  BSF    0A.3
....................       lcd_putc("  clave erronea"); 
09AB:  MOVLW  40
09AC:  BSF    03.6
09AD:  MOVWF  0D
09AE:  MOVLW  00
09AF:  MOVWF  0F
09B0:  BCF    0A.3
09B1:  BCF    03.6
09B2:  CALL   2CD
09B3:  BSF    0A.3
....................   delay_ms(150); 
09B4:  MOVLW  96
09B5:  MOVWF  4B
09B6:  BCF    0A.3
09B7:  CALL   076
09B8:  BSF    0A.3
....................  
....................  
....................  
....................   }  
.................... } 
09B9:  GOTO   071
....................  }  
....................  
....................  
....................  } 
....................  
....................  
....................  
....................  
....................  
....................       if(input(PIN_C6)==1){         //Sensor Potenciometro 
09BA:  BSF    31.6
09BB:  MOVF   31,W
09BC:  BSF    03.5
09BD:  MOVWF  07
09BE:  BCF    03.5
09BF:  BTFSS  07.6
09C0:  GOTO   34F
....................    while(input(PIN_C6)==1); 
09C1:  BSF    31.6
09C2:  MOVF   31,W
09C3:  BSF    03.5
09C4:  MOVWF  07
09C5:  BCF    03.5
09C6:  BTFSC  07.6
09C7:  GOTO   1C1
.................... delay_ms(20); 
09C8:  MOVLW  14
09C9:  MOVWF  4B
09CA:  BCF    0A.3
09CB:  CALL   076
09CC:  BSF    0A.3
....................       while(input(pin_C5)!=1){ 
09CD:  BSF    31.5
09CE:  MOVF   31,W
09CF:  BSF    03.5
09D0:  MOVWF  07
09D1:  BCF    03.5
09D2:  BTFSC  07.5
09D3:  GOTO   34F
....................          set_adc_channel(1); 
09D4:  MOVLW  08
09D5:  MOVWF  78
09D6:  MOVF   1F,W
09D7:  ANDLW  C7
09D8:  IORWF  78,W
09D9:  MOVWF  1F
....................          delay_us(20); 
09DA:  MOVLW  20
09DB:  MOVWF  77
09DC:  DECFSZ 77,F
09DD:  GOTO   1DC
09DE:  GOTO   1DF
09DF:  NOP
....................  
....................           valor_a=read_adc(); 
09E0:  BSF    1F.2
09E1:  BTFSC  1F.2
09E2:  GOTO   1E1
09E3:  MOVF   1E,W
09E4:  MOVWF  7A
09E5:  BSF    03.5
09E6:  MOVF   1E,W
09E7:  BCF    03.5
09E8:  MOVWF  3D
09E9:  MOVF   1E,W
09EA:  MOVWF  3E
09EB:  BCF    0A.3
09EC:  CALL   13B
09ED:  BSF    0A.3
09EE:  MOVF   7A,W
09EF:  MOVWF  37
09F0:  MOVF   79,W
09F1:  MOVWF  36
09F2:  MOVF   78,W
09F3:  MOVWF  35
09F4:  MOVF   77,W
09F5:  MOVWF  34
....................  
....................          pot=(valor_a*32.2); 
09F6:  MOVF   37,W
09F7:  MOVWF  4D
09F8:  MOVF   36,W
09F9:  MOVWF  4C
09FA:  MOVF   35,W
09FB:  MOVWF  4B
09FC:  MOVF   34,W
09FD:  MOVWF  4A
09FE:  MOVLW  CD
09FF:  MOVWF  51
0A00:  MOVLW  CC
0A01:  MOVWF  50
0A02:  CLRF   4F
0A03:  MOVLW  84
0A04:  MOVWF  4E
0A05:  BCF    0A.3
0A06:  CALL   158
0A07:  BSF    0A.3
0A08:  MOVF   7A,W
0A09:  MOVWF  3B
0A0A:  MOVF   79,W
0A0B:  MOVWF  3A
0A0C:  MOVF   78,W
0A0D:  MOVWF  39
0A0E:  MOVF   77,W
0A0F:  MOVWF  38
....................        
....................      
....................          lcd_gotoxy(2,1); 
0A10:  MOVLW  02
0A11:  MOVWF  4B
0A12:  MOVLW  01
0A13:  MOVWF  4C
0A14:  BCF    0A.3
0A15:  CALL   1EE
0A16:  BSF    0A.3
....................          printf(lcd_putc,"el grado \nes: %F3.2",pot); 
0A17:  MOVLW  48
0A18:  BSF    03.6
0A19:  MOVWF  0D
0A1A:  MOVLW  00
0A1B:  MOVWF  0F
0A1C:  BCF    03.0
0A1D:  MOVLW  0E
0A1E:  BCF    03.6
0A1F:  MOVWF  3D
0A20:  BCF    0A.3
0A21:  CALL   22C
0A22:  BSF    0A.3
0A23:  MOVLW  89
0A24:  MOVWF  04
0A25:  MOVF   3B,W
0A26:  MOVWF  40
0A27:  MOVF   3A,W
0A28:  MOVWF  3F
0A29:  MOVF   39,W
0A2A:  MOVWF  3E
0A2B:  MOVF   38,W
0A2C:  MOVWF  3D
0A2D:  MOVLW  02
0A2E:  MOVWF  41
0A2F:  BCF    0A.3
0A30:  CALL   42F
0A31:  BSF    0A.3
0A32:  MOVLW  33
0A33:  MOVWF  4A
0A34:  BCF    0A.3
0A35:  CALL   200
0A36:  BSF    0A.3
0A37:  MOVLW  2E
0A38:  MOVWF  4A
0A39:  BCF    0A.3
0A3A:  CALL   200
0A3B:  BSF    0A.3
0A3C:  MOVLW  32
0A3D:  MOVWF  4A
0A3E:  BCF    0A.3
0A3F:  CALL   200
0A40:  BSF    0A.3
....................          delay_us(20); 
0A41:  MOVLW  20
0A42:  MOVWF  77
0A43:  DECFSZ 77,F
0A44:  GOTO   243
0A45:  GOTO   246
0A46:  NOP
....................  
....................          switch(temp){ 
0A47:  MOVF   33,W
0A48:  XORLW  19
0A49:  BTFSC  03.2
0A4A:  GOTO   24F
0A4B:  XORLW  04
0A4C:  BTFSC  03.2
0A4D:  GOTO   250
0A4E:  GOTO   258
....................               case 25:        set_pwm1_duty(0);  
0A4F:  CLRF   15
....................  
....................               case 29:       delay_us(20); 
0A50:  MOVLW  20
0A51:  MOVWF  77
0A52:  DECFSZ 77,F
0A53:  GOTO   252
0A54:  GOTO   255
0A55:  NOP
....................                              set_pwm1_duty(pwm); // alarma 
0A56:  MOVF   3C,W
0A57:  MOVWF  15
....................              
....................       }  
....................        
....................       output_low(pin_b0); 
0A58:  BSF    03.5
0A59:  BCF    06.0
0A5A:  BCF    03.5
0A5B:  BCF    06.0
....................        
....................  
....................  
.................... if (pot>30){ 
0A5C:  CLRF   40
0A5D:  CLRF   3F
0A5E:  MOVLW  70
0A5F:  MOVWF  3E
0A60:  MOVLW  83
0A61:  MOVWF  3D
0A62:  MOVF   3B,W
0A63:  MOVWF  44
0A64:  MOVF   3A,W
0A65:  MOVWF  43
0A66:  MOVF   39,W
0A67:  MOVWF  42
0A68:  MOVF   38,W
0A69:  MOVWF  41
0A6A:  BCF    0A.3
0A6B:  GOTO   50F
0A6C:  BSF    0A.3
0A6D:  BTFSS  03.0
0A6E:  GOTO   34E
....................       lcd_putc('\f'); 
0A6F:  MOVLW  0C
0A70:  MOVWF  4A
0A71:  BCF    0A.3
0A72:  CALL   200
0A73:  BSF    0A.3
....................      lcd_gotoxy(1,1); 
0A74:  MOVLW  01
0A75:  MOVWF  4B
0A76:  MOVWF  4C
0A77:  BCF    0A.3
0A78:  CALL   1EE
0A79:  BSF    0A.3
....................       lcd_putc("INGRESAR CLAVE"); 
0A7A:  MOVLW  52
0A7B:  BSF    03.6
0A7C:  MOVWF  0D
0A7D:  MOVLW  00
0A7E:  MOVWF  0F
0A7F:  BCF    0A.3
0A80:  BCF    03.6
0A81:  CALL   2CD
0A82:  BSF    0A.3
.................... num = 0; 
0A83:  CLRF   27
....................             while(num<4){ 
0A84:  MOVF   27,W
0A85:  SUBLW  03
0A86:  BTFSS  03.0
0A87:  GOTO   2A6
....................                   k=kbd_getc(); 
0A88:  BCF    0A.3
0A89:  CALL   323
0A8A:  BSF    0A.3
0A8B:  MOVF   78,W
0A8C:  MOVWF  26
....................                   if(k != 0){ 
0A8D:  MOVF   26,F
0A8E:  BTFSC  03.2
0A8F:  GOTO   2A5
....................                   clave[num]=k; 
0A90:  MOVLW  2D
0A91:  ADDWF  27,W
0A92:  MOVWF  04
0A93:  BCF    03.7
0A94:  MOVF   26,W
0A95:  MOVWF  00
....................                   num++; 
0A96:  INCF   27,F
....................                   lcd_gotoxy(num+1,2); 
0A97:  MOVLW  01
0A98:  ADDWF  27,W
0A99:  MOVWF  3D
0A9A:  MOVWF  4B
0A9B:  MOVLW  02
0A9C:  MOVWF  4C
0A9D:  BCF    0A.3
0A9E:  CALL   1EE
0A9F:  BSF    0A.3
....................                   lcd_putc(k); 
0AA0:  MOVF   26,W
0AA1:  MOVWF  4A
0AA2:  BCF    0A.3
0AA3:  CALL   200
0AA4:  BSF    0A.3
....................             } 
0AA5:  GOTO   284
....................          } 
....................       delay_ms(150); 
0AA6:  MOVLW  96
0AA7:  MOVWF  4B
0AA8:  BCF    0A.3
0AA9:  CALL   076
0AAA:  BSF    0A.3
....................  
.................... if(strstr(clave , clave_entrada)){ 
0AAB:  CLRF   3E
0AAC:  MOVLW  2D
0AAD:  MOVWF  3D
0AAE:  CLRF   40
0AAF:  MOVLW  28
0AB0:  MOVWF  3F
0AB1:  BCF    0A.3
0AB2:  CALL   392
0AB3:  BSF    0A.3
0AB4:  MOVF   78,W
0AB5:  IORWF  79,W
0AB6:  BTFSC  03.2
0AB7:  GOTO   333
....................       output_high(PIN_E0); 
0AB8:  BSF    09.0
....................       output_low(PIN_E1); 
0AB9:  BCF    09.1
....................       lcd_putc('\f'); 
0ABA:  MOVLW  0C
0ABB:  MOVWF  4A
0ABC:  BCF    0A.3
0ABD:  CALL   200
0ABE:  BSF    0A.3
....................       lcd_gotoxy(1,1); 
0ABF:  MOVLW  01
0AC0:  MOVWF  4B
0AC1:  MOVWF  4C
0AC2:  BCF    0A.3
0AC3:  CALL   1EE
0AC4:  BSF    0A.3
....................       lcd_putc(" clave correcta"); 
0AC5:  MOVLW  5A
0AC6:  BSF    03.6
0AC7:  MOVWF  0D
0AC8:  MOVLW  00
0AC9:  MOVWF  0F
0ACA:  BCF    0A.3
0ACB:  BCF    03.6
0ACC:  CALL   2CD
0ACD:  BSF    0A.3
....................  
....................   delay_ms(100); 
0ACE:  MOVLW  64
0ACF:  MOVWF  4B
0AD0:  BCF    0A.3
0AD1:  CALL   076
0AD2:  BSF    0A.3
....................       lcd_gotoxy(1,2); 
0AD3:  MOVLW  01
0AD4:  MOVWF  4B
0AD5:  MOVLW  02
0AD6:  MOVWF  4C
0AD7:  BCF    0A.3
0AD8:  CALL   1EE
0AD9:  BSF    0A.3
....................       lcd_putc(" Adelante!"); 
0ADA:  MOVLW  62
0ADB:  BSF    03.6
0ADC:  MOVWF  0D
0ADD:  MOVLW  00
0ADE:  MOVWF  0F
0ADF:  BCF    0A.3
0AE0:  BCF    03.6
0AE1:  CALL   2CD
0AE2:  BSF    0A.3
.................... delay_ms(150); 
0AE3:  MOVLW  96
0AE4:  MOVWF  4B
0AE5:  BCF    0A.3
0AE6:  CALL   076
0AE7:  BSF    0A.3
....................  
....................  
.................... lcd_gotoxy(1,1); 
0AE8:  MOVLW  01
0AE9:  MOVWF  4B
0AEA:  MOVWF  4C
0AEB:  BCF    0A.3
0AEC:  CALL   1EE
0AED:  BSF    0A.3
.................... lcd_putc('f'); 
0AEE:  MOVLW  66
0AEF:  MOVWF  4A
0AF0:  BCF    0A.3
0AF1:  CALL   200
0AF2:  BSF    0A.3
.................... lcd_gotoxy(1,2); 
0AF3:  MOVLW  01
0AF4:  MOVWF  4B
0AF5:  MOVLW  02
0AF6:  MOVWF  4C
0AF7:  BCF    0A.3
0AF8:  CALL   1EE
0AF9:  BSF    0A.3
.................... lcd_putc('f'); 
0AFA:  MOVLW  66
0AFB:  MOVWF  4A
0AFC:  BCF    0A.3
0AFD:  CALL   200
0AFE:  BSF    0A.3
.................... printf(lcd_putc," es: %f3.2",pot); 
0AFF:  MOVLW  68
0B00:  BSF    03.6
0B01:  MOVWF  0D
0B02:  MOVLW  00
0B03:  MOVWF  0F
0B04:  BCF    03.0
0B05:  MOVLW  05
0B06:  BCF    03.6
0B07:  MOVWF  3D
0B08:  BCF    0A.3
0B09:  CALL   22C
0B0A:  BSF    0A.3
0B0B:  MOVLW  89
0B0C:  MOVWF  04
0B0D:  MOVF   3B,W
0B0E:  MOVWF  40
0B0F:  MOVF   3A,W
0B10:  MOVWF  3F
0B11:  MOVF   39,W
0B12:  MOVWF  3E
0B13:  MOVF   38,W
0B14:  MOVWF  3D
0B15:  MOVLW  02
0B16:  MOVWF  41
0B17:  BCF    0A.3
0B18:  CALL   42F
0B19:  BSF    0A.3
0B1A:  MOVLW  33
0B1B:  MOVWF  4A
0B1C:  BCF    0A.3
0B1D:  CALL   200
0B1E:  BSF    0A.3
0B1F:  MOVLW  2E
0B20:  MOVWF  4A
0B21:  BCF    0A.3
0B22:  CALL   200
0B23:  BSF    0A.3
0B24:  MOVLW  32
0B25:  MOVWF  4A
0B26:  BCF    0A.3
0B27:  CALL   200
0B28:  BSF    0A.3
.................... delay_ms(2000); 
0B29:  MOVLW  08
0B2A:  MOVWF  3D
0B2B:  MOVLW  FA
0B2C:  MOVWF  4B
0B2D:  BCF    0A.3
0B2E:  CALL   076
0B2F:  BSF    0A.3
0B30:  DECFSZ 3D,F
0B31:  GOTO   32B
....................  
.................... } 
0B32:  GOTO   34E
.................... else { 
....................       output_high(PIN_E1); 
0B33:  BSF    09.1
....................       output_low(PIN_E0); 
0B34:  BCF    09.0
....................       lcd_putc('\f'); 
0B35:  MOVLW  0C
0B36:  MOVWF  4A
0B37:  BCF    0A.3
0B38:  CALL   200
0B39:  BSF    0A.3
....................       lcd_gotoxy(1,1); 
0B3A:  MOVLW  01
0B3B:  MOVWF  4B
0B3C:  MOVWF  4C
0B3D:  BCF    0A.3
0B3E:  CALL   1EE
0B3F:  BSF    0A.3
....................       lcd_putc("  clave erronea"); 
0B40:  MOVLW  6E
0B41:  BSF    03.6
0B42:  MOVWF  0D
0B43:  MOVLW  00
0B44:  MOVWF  0F
0B45:  BCF    0A.3
0B46:  BCF    03.6
0B47:  CALL   2CD
0B48:  BSF    0A.3
....................   delay_ms(150); 
0B49:  MOVLW  96
0B4A:  MOVWF  4B
0B4B:  BCF    0A.3
0B4C:  CALL   076
0B4D:  BSF    0A.3
....................  
....................  
....................  
....................   }  
.................... } 
0B4E:  GOTO   1CD
....................  }  
....................  
....................  
....................  } 
0B4F:  GOTO   05E
....................  
....................  
....................  
.................... } } 
....................  
0B50:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 3F31   XT NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
