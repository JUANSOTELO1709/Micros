CCS PCM C Compiler, Version 5.025, 63725               30-oct.-22 13:33

               Filename:   C:\Users\juand\Desktop\PARCIAL 2\parcial2.lst

               ROM used:   2427 words (30%)
                           Largest free fragment is 2048
               RAM used:   41 (11%) at main() level
                           59 (16%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  41
000C:  RETLW  34
000D:  RETLW  35
000E:  RETLW  36
000F:  RETLW  42
0010:  RETLW  37
0011:  RETLW  38
0012:  RETLW  39
0013:  RETLW  43
0014:  RETLW  2A
0015:  RETLW  30
0016:  RETLW  23
0017:  RETLW  44
0018:  DATA EC,30
0019:  DATA F4,32
001A:  DATA 00,00
001B:  DATA 3C,1E
001C:  DATA 00,01
001D:  DATA E3,30
001E:  DATA F0,3A
001F:  DATA 63,34
0020:  DATA 69,37
0021:  DATA 6F,00
0022:  DATA EC,30
0023:  DATA F4,32
0024:  DATA 00,01
0025:  DATA EC,30
0026:  DATA F4,32
0027:  DATA 00,01
0028:  DATA E3,30
0029:  DATA F0,3A
002A:  DATA 63,34
002B:  DATA 69,37
002C:  DATA 6F,00
002D:  DATA 3C,1E
002E:  DATA 00,01
002F:  DATA E3,30
0030:  DATA F0,3A
0031:  DATA 63,34
0032:  DATA 69,37
0033:  DATA 6F,00
0034:  DATA 65,3C
0035:  DATA 70,39
0036:  DATA E5,39
0037:  DATA 6F,00
0038:  DATA 3C,1E
0039:  DATA 00,01
003A:  DATA 65,3C
003B:  DATA 70,39
003C:  DATA E5,39
003D:  DATA 6F,00
003E:  DATA B7,37
003F:  DATA 7A,10
0040:  DATA 3D,10
0041:  DATA 41,00
0042:  DATA 31,19
0043:  DATA 6F,3D
0044:  DATA A0,1E
0045:  DATA 20,21
0046:  DATA 00,01
0047:  DATA B7,37
0048:  DATA 7A,00
0049:  DATA EC,30
004A:  DATA F4,32
004B:  DATA 00,01
004C:  DATA E3,30
004D:  DATA F0,3A
004E:  DATA 63,34
004F:  DATA 69,37
0050:  DATA 6F,00
0051:  DATA 65,3C
0052:  DATA 70,39
0053:  DATA E5,39
0054:  DATA 6F,00
0055:  DATA 31,19
0056:  DATA 6F,3D
0057:  DATA 00,01
0058:  DATA EC,30
0059:  DATA F4,32
005A:  DATA 00,01
005B:  DATA E3,30
005C:  DATA F0,3A
005D:  DATA 63,34
005E:  DATA 69,37
005F:  DATA 6F,00
0060:  DATA 65,3C
0061:  DATA 70,39
0062:  DATA E5,39
0063:  DATA 6F,00
*
014A:  MOVF   0B,W
014B:  MOVWF  42
014C:  BCF    0B.7
014D:  BSF    03.5
014E:  BSF    03.6
014F:  BSF    0C.7
0150:  BSF    0C.0
0151:  NOP
0152:  NOP
0153:  BCF    03.5
0154:  BCF    03.6
0155:  BTFSC  42.7
0156:  BSF    0B.7
0157:  BSF    03.6
0158:  MOVF   0C,W
0159:  ANDLW  7F
015A:  BTFSC  03.2
015B:  GOTO   19E
015C:  BCF    03.6
015D:  MOVWF  42
015E:  BSF    03.6
015F:  MOVF   0D,W
0160:  BCF    03.6
0161:  MOVWF  43
0162:  BSF    03.6
0163:  MOVF   0F,W
0164:  BCF    03.6
0165:  MOVWF  44
0166:  MOVF   42,W
0167:  MOVWF  4B
0168:  CALL   11E
0169:  MOVF   43,W
016A:  BSF    03.6
016B:  MOVWF  0D
016C:  BCF    03.6
016D:  MOVF   44,W
016E:  BSF    03.6
016F:  MOVWF  0F
0170:  BCF    03.6
0171:  MOVF   0B,W
0172:  MOVWF  45
0173:  BCF    0B.7
0174:  BSF    03.5
0175:  BSF    03.6
0176:  BSF    0C.7
0177:  BSF    0C.0
0178:  NOP
0179:  NOP
017A:  BCF    03.5
017B:  BCF    03.6
017C:  BTFSC  45.7
017D:  BSF    0B.7
017E:  BSF    03.6
017F:  RLF    0C,W
0180:  RLF    0E,W
0181:  ANDLW  7F
0182:  BTFSC  03.2
0183:  GOTO   19E
0184:  BCF    03.6
0185:  MOVWF  42
0186:  BSF    03.6
0187:  MOVF   0D,W
0188:  BCF    03.6
0189:  MOVWF  43
018A:  BSF    03.6
018B:  MOVF   0F,W
018C:  BCF    03.6
018D:  MOVWF  44
018E:  MOVF   42,W
018F:  MOVWF  4B
0190:  CALL   11E
0191:  MOVF   43,W
0192:  BSF    03.6
0193:  MOVWF  0D
0194:  BCF    03.6
0195:  MOVF   44,W
0196:  BSF    03.6
0197:  MOVWF  0F
0198:  INCF   0D,F
0199:  BTFSC  03.2
019A:  INCF   0F,F
019B:  BCF    03.6
019C:  GOTO   14A
019D:  BSF    03.6
019E:  BCF    03.6
019F:  RETURN
*
0207:  BCF    0A.0
0208:  BSF    0A.1
0209:  BCF    0A.2
020A:  ADDWF  02,F
020B:  GOTO   1AC
020C:  GOTO   1B2
020D:  GOTO   1B8
020E:  GOTO   1BE
*
025D:  MOVLW  8E
025E:  MOVWF  77
025F:  MOVF   43,W
0260:  MOVWF  78
0261:  MOVF   42,W
0262:  MOVWF  79
0263:  CLRF   7A
0264:  MOVF   78,F
0265:  BTFSS  03.2
0266:  GOTO   271
0267:  MOVF   79,W
0268:  MOVWF  78
0269:  CLRF   79
026A:  MOVLW  08
026B:  SUBWF  77,F
026C:  MOVF   78,F
026D:  BTFSS  03.2
026E:  GOTO   271
026F:  CLRF   77
0270:  GOTO   279
0271:  BCF    03.0
0272:  BTFSC  78.7
0273:  GOTO   278
0274:  RLF    79,F
0275:  RLF    78,F
0276:  DECF   77,F
0277:  GOTO   271
0278:  BCF    78.7
0279:  RETURN
027A:  MOVF   42,W
027B:  BTFSC  03.2
027C:  GOTO   2EA
027D:  MOVWF  4A
027E:  MOVF   46,W
027F:  BTFSC  03.2
0280:  GOTO   2EA
0281:  ADDWF  4A,F
0282:  BTFSC  03.0
0283:  GOTO   28B
0284:  MOVLW  7F
0285:  SUBWF  4A,F
0286:  BTFSS  03.0
0287:  GOTO   2EA
0288:  BTFSC  03.2
0289:  GOTO   2EA
028A:  GOTO   28F
028B:  MOVLW  81
028C:  ADDWF  4A,F
028D:  BTFSC  03.0
028E:  GOTO   2EA
028F:  MOVF   4A,W
0290:  MOVWF  77
0291:  CLRF   78
0292:  CLRF   79
0293:  CLRF   7A
0294:  MOVF   43,W
0295:  MOVWF  4E
0296:  BSF    4E.7
0297:  MOVF   44,W
0298:  MOVWF  4D
0299:  MOVF   45,W
029A:  MOVWF  4C
029B:  MOVLW  18
029C:  MOVWF  4A
029D:  CLRF   4B
029E:  BTFSS  4C.0
029F:  GOTO   2B8
02A0:  MOVF   49,W
02A1:  ADDWF  7A,F
02A2:  BTFSS  03.0
02A3:  GOTO   2AA
02A4:  INCF   79,F
02A5:  BTFSS  03.2
02A6:  GOTO   2AA
02A7:  INCF   78,F
02A8:  BTFSC  03.2
02A9:  BSF    4B.7
02AA:  MOVF   48,W
02AB:  ADDWF  79,F
02AC:  BTFSS  03.0
02AD:  GOTO   2B1
02AE:  INCF   78,F
02AF:  BTFSC  03.2
02B0:  BSF    4B.7
02B1:  MOVF   47,W
02B2:  MOVWF  44
02B3:  BSF    44.7
02B4:  MOVF   44,W
02B5:  ADDWF  78,F
02B6:  BTFSC  03.0
02B7:  BSF    4B.7
02B8:  RLF    4B,F
02B9:  RRF    78,F
02BA:  RRF    79,F
02BB:  RRF    7A,F
02BC:  RRF    4E,F
02BD:  RRF    4D,F
02BE:  RRF    4C,F
02BF:  BCF    03.0
02C0:  DECFSZ 4A,F
02C1:  GOTO   29D
02C2:  MOVLW  01
02C3:  ADDWF  77,F
02C4:  BTFSC  03.0
02C5:  GOTO   2EA
02C6:  BTFSC  78.7
02C7:  GOTO   2CF
02C8:  RLF    4E,F
02C9:  RLF    7A,F
02CA:  RLF    79,F
02CB:  RLF    78,F
02CC:  DECF   77,F
02CD:  BTFSC  03.2
02CE:  GOTO   2EA
02CF:  BTFSS  4E.7
02D0:  GOTO   2E0
02D1:  INCF   7A,F
02D2:  BTFSS  03.2
02D3:  GOTO   2E0
02D4:  INCF   79,F
02D5:  BTFSS  03.2
02D6:  GOTO   2E0
02D7:  INCF   78,F
02D8:  BTFSS  03.2
02D9:  GOTO   2E0
02DA:  RRF    78,F
02DB:  RRF    79,F
02DC:  RRF    7A,F
02DD:  INCF   77,F
02DE:  BTFSC  03.2
02DF:  GOTO   2EA
02E0:  MOVF   43,W
02E1:  MOVWF  4B
02E2:  MOVF   47,W
02E3:  XORWF  4B,F
02E4:  BTFSS  4B.7
02E5:  GOTO   2E8
02E6:  BSF    78.7
02E7:  GOTO   2EE
02E8:  BCF    78.7
02E9:  GOTO   2EE
02EA:  CLRF   77
02EB:  CLRF   78
02EC:  CLRF   79
02ED:  CLRF   7A
02EE:  RETURN
02EF:  MOVLW  8E
02F0:  MOVWF  77
02F1:  MOVF   42,W
02F2:  SUBWF  77,F
02F3:  MOVF   43,W
02F4:  MOVWF  79
02F5:  MOVF   44,W
02F6:  MOVWF  78
02F7:  BSF    79.7
02F8:  MOVF   77,F
02F9:  BTFSC  03.2
02FA:  GOTO   306
02FB:  BCF    03.0
02FC:  MOVF   79,F
02FD:  BTFSS  03.2
02FE:  GOTO   302
02FF:  MOVF   78,F
0300:  BTFSC  03.2
0301:  GOTO   306
0302:  RRF    79,F
0303:  RRF    78,F
0304:  DECFSZ 77,F
0305:  GOTO   2FB
0306:  BTFSS  43.7
0307:  GOTO   30D
0308:  COMF   78,F
0309:  COMF   79,F
030A:  INCF   78,F
030B:  BTFSC  03.2
030C:  INCF   79,F
030D:  RETURN
030E:  CLRF   4A
030F:  MOVF   04,W
0310:  MOVWF  49
0311:  BCF    4A.0
0312:  BTFSC  03.7
0313:  BSF    4A.0
0314:  SWAPF  43,W
0315:  IORLW  F0
0316:  MOVWF  45
0317:  ADDWF  45,F
0318:  ADDLW  E2
0319:  MOVWF  46
031A:  ADDLW  32
031B:  MOVWF  48
031C:  MOVF   43,W
031D:  ANDLW  0F
031E:  ADDWF  46,F
031F:  ADDWF  46,F
0320:  ADDWF  48,F
0321:  ADDLW  E9
0322:  MOVWF  47
0323:  ADDWF  47,F
0324:  ADDWF  47,F
0325:  SWAPF  42,W
0326:  ANDLW  0F
0327:  ADDWF  47,F
0328:  ADDWF  48,F
0329:  RLF    47,F
032A:  RLF    48,F
032B:  COMF   48,F
032C:  RLF    48,F
032D:  MOVF   42,W
032E:  ANDLW  0F
032F:  ADDWF  48,F
0330:  RLF    45,F
0331:  MOVLW  07
0332:  MOVWF  44
0333:  MOVLW  0A
0334:  ADDWF  48,F
0335:  DECF   47,F
0336:  BTFSS  03.0
0337:  GOTO   334
0338:  ADDWF  47,F
0339:  DECF   46,F
033A:  BTFSS  03.0
033B:  GOTO   338
033C:  ADDWF  46,F
033D:  DECF   45,F
033E:  BTFSS  03.0
033F:  GOTO   33C
0340:  ADDWF  45,F
0341:  DECF   44,F
0342:  BTFSS  03.0
0343:  GOTO   340
0344:  MOVLW  44
0345:  MOVWF  04
0346:  BCF    03.7
0347:  MOVLW  07
0348:  ANDWF  49,W
0349:  BCF    49.6
034A:  ADDWF  04,F
034B:  MOVLW  48
034C:  SUBWF  04,W
034D:  BTFSC  03.2
034E:  BSF    49.6
034F:  MOVF   00,W
0350:  MOVWF  77
0351:  BTFSS  03.2
0352:  GOTO   35B
0353:  BTFSC  49.6
0354:  GOTO   35B
0355:  BTFSC  49.4
0356:  GOTO   36D
0357:  BTFSC  49.3
0358:  GOTO   35B
0359:  MOVLW  20
035A:  GOTO   35E
035B:  BSF    49.3
035C:  BCF    49.4
035D:  MOVLW  30
035E:  ADDWF  77,F
035F:  CLRF   43
0360:  MOVF   04,W
0361:  MOVWF  42
0362:  BCF    43.0
0363:  BTFSC  03.7
0364:  BSF    43.0
0365:  MOVF   77,W
0366:  MOVWF  4B
0367:  CALL   11E
0368:  MOVF   42,W
0369:  MOVWF  04
036A:  BCF    03.7
036B:  BTFSC  43.0
036C:  BSF    03.7
036D:  INCF   04,F
036E:  BTFSS  49.6
036F:  GOTO   34B
0370:  RETURN
*
0D8D:  BSF    0A.0
0D8E:  BCF    0A.1
0D8F:  BSF    0A.2
0D90:  ADDWF  02,F
0D91:  GOTO   066
0D92:  GOTO   120
0D93:  GOTO   1CF
0D94:  GOTO   26E
0D95:  GOTO   2EB
0D96:  GOTO   439
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOPUT,NOLVP,BROWNOUT 
.................... #use delay(clock=4M) 
*
0064:  MOVLW  4C
0065:  MOVWF  04
0066:  BCF    03.7
0067:  MOVF   00,W
0068:  BTFSC  03.2
0069:  GOTO   078
006A:  MOVLW  01
006B:  MOVWF  78
006C:  CLRF   77
006D:  DECFSZ 77,F
006E:  GOTO   06D
006F:  DECFSZ 78,F
0070:  GOTO   06C
0071:  MOVLW  4A
0072:  MOVWF  77
0073:  DECFSZ 77,F
0074:  GOTO   073
0075:  GOTO   076
0076:  DECFSZ 00,F
0077:  GOTO   06A
0078:  RETURN
.................... #use standard_io(D) 
.................... #use standard_io(C) 
.................... #use fast_io(E) 
....................  
.................... #include <lcd.c>                       // Libreria para el manejo de la LCD 20x4 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0091:  MOVLW  0F
0092:  BSF    03.5
0093:  ANDWF  08,W
0094:  IORLW  F0
0095:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0096:  BCF    03.5
0097:  BSF    08.2
....................    delay_cycles(1); 
0098:  NOP
....................    lcd_output_enable(1); 
0099:  BSF    08.0
....................    delay_cycles(1); 
009A:  NOP
....................    high = lcd_read_nibble(); 
009B:  CALL   085
009C:  MOVF   78,W
009D:  MOVWF  53
....................        
....................    lcd_output_enable(0); 
009E:  BCF    08.0
....................    delay_cycles(1); 
009F:  NOP
....................    lcd_output_enable(1); 
00A0:  BSF    08.0
....................    delay_us(1); 
00A1:  NOP
....................    low = lcd_read_nibble(); 
00A2:  CALL   085
00A3:  MOVF   78,W
00A4:  MOVWF  52
....................        
....................    lcd_output_enable(0); 
00A5:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00A6:  MOVLW  0F
00A7:  BSF    03.5
00A8:  ANDWF  08,W
00A9:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00AA:  BCF    03.5
00AB:  SWAPF  53,W
00AC:  MOVWF  77
00AD:  MOVLW  F0
00AE:  ANDWF  77,F
00AF:  MOVF   77,W
00B0:  IORWF  52,W
00B1:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0085:  MOVF   08,W
0086:  MOVWF  77
0087:  SWAPF  08,W
0088:  ANDLW  0F
0089:  MOVWF  78
....................   #endif 
008A:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0079:  SWAPF  53,W
007A:  ANDLW  F0
007B:  MOVWF  77
007C:  MOVLW  0F
007D:  ANDWF  08,W
007E:  IORWF  77,W
007F:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0080:  NOP
....................    lcd_output_enable(1); 
0081:  BSF    08.0
....................    delay_us(2); 
0082:  GOTO   083
....................    lcd_output_enable(0); 
0083:  BCF    08.0
0084:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
008B:  BSF    03.5
008C:  BCF    08.0
....................    lcd_rs_tris(); 
008D:  BCF    08.1
....................    lcd_rw_tris(); 
008E:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
008F:  BCF    03.5
0090:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00B2:  MOVF   78,W
00B3:  MOVWF  52
00B4:  BTFSC  52.7
00B5:  GOTO   091
....................    lcd_output_rs(address); 
00B6:  BTFSS  50.0
00B7:  BCF    08.1
00B8:  BTFSC  50.0
00B9:  BSF    08.1
....................    delay_cycles(1); 
00BA:  NOP
....................    lcd_output_rw(0); 
00BB:  BCF    08.2
....................    delay_cycles(1); 
00BC:  NOP
....................    lcd_output_enable(0); 
00BD:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00BE:  SWAPF  51,W
00BF:  MOVWF  52
00C0:  MOVLW  0F
00C1:  ANDWF  52,F
00C2:  MOVF   52,W
00C3:  MOVWF  53
00C4:  CALL   079
....................    lcd_send_nibble(n & 0xf); 
00C5:  MOVF   51,W
00C6:  ANDLW  0F
00C7:  MOVWF  52
00C8:  MOVWF  53
00C9:  CALL   079
00CA:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00CB:  MOVLW  28
00CC:  MOVWF  43
00CD:  MOVLW  0C
00CE:  MOVWF  44
00CF:  MOVLW  01
00D0:  MOVWF  45
00D1:  MOVLW  06
00D2:  MOVWF  46
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00D3:  BCF    08.0
....................    lcd_output_rs(0); 
00D4:  BCF    08.1
....................    lcd_output_rw(0); 
00D5:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00D6:  MOVLW  0F
00D7:  BSF    03.5
00D8:  ANDWF  08,W
00D9:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00DA:  BCF    08.0
....................    lcd_rs_tris(); 
00DB:  BCF    08.1
....................    lcd_rw_tris(); 
00DC:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
00DD:  MOVLW  0F
00DE:  BCF    03.5
00DF:  MOVWF  4C
00E0:  CALL   064
....................    for(i=1;i<=3;++i) 
00E1:  MOVLW  01
00E2:  MOVWF  42
00E3:  MOVF   42,W
00E4:  SUBLW  03
00E5:  BTFSS  03.0
00E6:  GOTO   0EF
....................    { 
....................        lcd_send_nibble(3); 
00E7:  MOVLW  03
00E8:  MOVWF  53
00E9:  CALL   079
....................        delay_ms(5); 
00EA:  MOVLW  05
00EB:  MOVWF  4C
00EC:  CALL   064
00ED:  INCF   42,F
00EE:  GOTO   0E3
....................    } 
....................     
....................    lcd_send_nibble(2); 
00EF:  MOVLW  02
00F0:  MOVWF  53
00F1:  CALL   079
....................    delay_ms(5); 
00F2:  MOVLW  05
00F3:  MOVWF  4C
00F4:  CALL   064
....................    for(i=0;i<=3;++i) 
00F5:  CLRF   42
00F6:  MOVF   42,W
00F7:  SUBLW  03
00F8:  BTFSS  03.0
00F9:  GOTO   106
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00FA:  MOVLW  43
00FB:  ADDWF  42,W
00FC:  MOVWF  04
00FD:  BCF    03.7
00FE:  MOVF   00,W
00FF:  MOVWF  47
0100:  CLRF   50
0101:  MOVF   47,W
0102:  MOVWF  51
0103:  CALL   08B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0104:  INCF   42,F
0105:  GOTO   0F6
0106:  BSF    0A.3
0107:  BCF    0A.4
0108:  GOTO   041 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
010C:  DECFSZ 4D,W
010D:  GOTO   10F
010E:  GOTO   112
....................       address=LCD_LINE_TWO; 
010F:  MOVLW  40
0110:  MOVWF  4E
0111:  GOTO   113
....................    else 
....................       address=0; 
0112:  CLRF   4E
....................       
....................    address+=x-1; 
0113:  MOVLW  01
0114:  SUBWF  4C,W
0115:  ADDWF  4E,F
....................    lcd_send_byte(0,0x80|address); 
0116:  MOVF   4E,W
0117:  IORLW  80
0118:  MOVWF  4F
0119:  CLRF   50
011A:  MOVF   4F,W
011B:  MOVWF  51
011C:  CALL   08B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
011D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
011E:  MOVF   4B,W
011F:  XORLW  07
0120:  BTFSC  03.2
0121:  GOTO   12C
0122:  XORLW  0B
0123:  BTFSC  03.2
0124:  GOTO   131
0125:  XORLW  06
0126:  BTFSC  03.2
0127:  GOTO   139
0128:  XORLW  02
0129:  BTFSC  03.2
012A:  GOTO   13F
012B:  GOTO   144
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
012C:  MOVLW  01
012D:  MOVWF  4C
012E:  MOVWF  4D
012F:  CALL   10C
0130:  GOTO   149
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0131:  CLRF   50
0132:  MOVLW  01
0133:  MOVWF  51
0134:  CALL   08B
....................                      delay_ms(2); 
0135:  MOVLW  02
0136:  MOVWF  4C
0137:  CALL   064
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0138:  GOTO   149
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0139:  MOVLW  01
013A:  MOVWF  4C
013B:  MOVLW  02
013C:  MOVWF  4D
013D:  CALL   10C
013E:  GOTO   149
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
013F:  CLRF   50
0140:  MOVLW  10
0141:  MOVWF  51
0142:  CALL   08B
0143:  GOTO   149
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0144:  MOVLW  01
0145:  MOVWF  50
0146:  MOVF   4B,W
0147:  MOVWF  51
0148:  CALL   08B
....................      #endif 
....................    } 
0149:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <math.h>                            // libreria mate 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <kbd4x4.c>           // libreria teclado 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     KBD_LIB.C by Redraven                         //// 
.................... ////                                                                   //// 
.................... ////                     Derived from KBDD.C                           //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81              // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83              // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                  // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B0) 
....................  
.................... #define COL0 (1 << 0) // PIN_B0 
.................... #define COL1 (1 << 1) // PIN_B1 
.................... #define COL2 (1 << 2) // PIN_B2 
.................... #define COL3 (1 << 3) // PIN_B3 
....................  
.................... #define ROW0 (1 << 4) // PIN_B4 
.................... #define ROW1 (1 << 5) // PIN_B5 
.................... #define ROW2 (1 << 6) // PIN_B6 
.................... #define ROW3 (1 << 7) // PIN_B7 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
.................... void kbd_init() { 
*
0109:  BSF    0A.3
010A:  BCF    0A.4
010B:  GOTO   044 (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static byte kbd_call_count; 
*
0814:  BCF    03.5
0815:  CLRF   21
....................    static short int kbd_down; 
0816:  BCF    22.0
....................    static char last_key; 
0817:  CLRF   23
....................    static byte col; 
0818:  CLRF   24
....................  
....................    byte kchar; 
....................    byte row; 
....................  
....................    kchar='\0'; 
*
01A0:  CLRF   42
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
01A1:  INCF   21,F
01A2:  MOVF   21,W
01A3:  SUBLW  21
01A4:  BTFSC  03.0
01A5:  GOTO   200
....................        switch (col) { 
01A6:  MOVF   24,W
01A7:  ADDLW  FC
01A8:  BTFSC  03.0
01A9:  GOTO   1C3
01AA:  ADDLW  04
01AB:  GOTO   207
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
01AC:  MOVLW  FE
01AD:  BSF    03.5
01AE:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
01AF:  BCF    03.5
01B0:  MOVWF  06
....................                     break; 
01B1:  GOTO   1C3
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
01B2:  MOVLW  FD
01B3:  BSF    03.5
01B4:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
01B5:  BCF    03.5
01B6:  MOVWF  06
....................                     break; 
01B7:  GOTO   1C3
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
01B8:  MOVLW  FB
01B9:  BSF    03.5
01BA:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
01BB:  BCF    03.5
01BC:  MOVWF  06
....................                     break; 
01BD:  GOTO   1C3
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3); 
01BE:  MOVLW  F7
01BF:  BSF    03.5
01C0:  MOVWF  06
....................                     kbd=~COL3&ALL_PINS; 
01C1:  BCF    03.5
01C2:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
01C3:  BTFSS  22.0
01C4:  GOTO   1CF
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
01C5:  MOVF   06,W
01C6:  ANDLW  F0
01C7:  SUBLW  F0
01C8:  BTFSS  03.2
01C9:  GOTO   1CE
....................            kbd_down=false; 
01CA:  BCF    22.0
....................            kchar=last_key; 
01CB:  MOVF   23,W
01CC:  MOVWF  42
....................            last_key='\0'; 
01CD:  CLRF   23
....................          } 
....................        } else { 
01CE:  GOTO   1FF
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
01CF:  MOVF   06,W
01D0:  ANDLW  F0
01D1:  SUBLW  F0
01D2:  BTFSC  03.2
01D3:  GOTO   1FA
....................              if((kbd & ROW0)==0) 
01D4:  MOVF   06,W
01D5:  ANDLW  10
01D6:  BTFSS  03.2
01D7:  GOTO   1DA
....................                row=0; 
01D8:  CLRF   43
01D9:  GOTO   1EE
....................              else if((kbd & ROW1)==0) 
01DA:  MOVF   06,W
01DB:  ANDLW  20
01DC:  BTFSS  03.2
01DD:  GOTO   1E1
....................                row=1; 
01DE:  MOVLW  01
01DF:  MOVWF  43
01E0:  GOTO   1EE
....................              else if((kbd & ROW2)==0) 
01E1:  MOVF   06,W
01E2:  ANDLW  40
01E3:  BTFSS  03.2
01E4:  GOTO   1E8
....................                row=2; 
01E5:  MOVLW  02
01E6:  MOVWF  43
01E7:  GOTO   1EE
....................              else if((kbd & ROW3)==0) 
01E8:  MOVF   06,W
01E9:  ANDLW  80
01EA:  BTFSS  03.2
01EB:  GOTO   1EE
....................                row=3; 
01EC:  MOVLW  03
01ED:  MOVWF  43
....................              last_key =KEYS[row][col]; 
01EE:  RLF    43,W
01EF:  MOVWF  77
01F0:  RLF    77,F
01F1:  MOVLW  FC
01F2:  ANDWF  77,F
01F3:  MOVF   77,W
01F4:  ADDWF  24,W
01F5:  CALL   004
01F6:  MOVWF  78
01F7:  MOVWF  23
....................              kbd_down = true; 
01F8:  BSF    22.0
....................           } else { 
01F9:  GOTO   1FF
....................              ++col; 
01FA:  INCF   24,F
....................              if(col==4) 
01FB:  MOVF   24,W
01FC:  SUBLW  04
01FD:  BTFSC  03.2
....................                col=0; 
01FE:  CLRF   24
....................           } 
....................        } 
....................       kbd_call_count=0; 
01FF:  CLRF   21
....................    } 
....................   set_tris_kbd(ALL_PINS); 
0200:  MOVLW  FF
0201:  BSF    03.5
0202:  MOVWF  06
....................   return(kchar); 
0203:  BCF    03.5
0204:  MOVF   42,W
0205:  MOVWF  78
0206:  RETURN
.................... } 
....................  
.................... #include <string.h>        //libreria comparaciones 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
020F:  MOVF   43,W
0210:  MOVWF  7A
0211:  MOVF   42,W
0212:  MOVWF  04
0213:  BCF    03.7
0214:  BTFSC  7A.0
0215:  BSF    03.7
0216:  MOVF   00,F
0217:  BTFSC  03.2
0218:  GOTO   259
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0219:  MOVF   43,W
021A:  MOVWF  47
021B:  MOVF   42,W
021C:  MOVWF  46
021D:  MOVF   45,W
021E:  MOVWF  49
021F:  MOVF   44,W
0220:  MOVWF  48
0221:  MOVF   49,W
0222:  MOVWF  7A
0223:  MOVF   48,W
0224:  MOVWF  04
0225:  BCF    03.7
0226:  BTFSC  7A.0
0227:  BSF    03.7
0228:  MOVF   00,F
0229:  BTFSC  03.2
022A:  GOTO   246
022B:  MOVF   47,W
022C:  MOVWF  7A
022D:  MOVF   46,W
022E:  MOVWF  04
022F:  BCF    03.7
0230:  BTFSC  7A.0
0231:  BSF    03.7
0232:  MOVF   00,W
0233:  MOVWF  4A
0234:  MOVF   49,W
0235:  MOVWF  7A
0236:  MOVF   48,W
0237:  MOVWF  04
0238:  BCF    03.7
0239:  BTFSC  7A.0
023A:  BSF    03.7
023B:  MOVF   00,W
023C:  SUBWF  4A,W
023D:  BTFSS  03.2
023E:  GOTO   246
023F:  INCF   46,F
0240:  BTFSC  03.2
0241:  INCF   47,F
0242:  INCF   48,F
0243:  BTFSC  03.2
0244:  INCF   49,F
0245:  GOTO   221
....................  
....................       if (*t == '\0') 
0246:  MOVF   49,W
0247:  MOVWF  7A
0248:  MOVF   48,W
0249:  MOVWF  04
024A:  BCF    03.7
024B:  BTFSC  7A.0
024C:  BSF    03.7
024D:  MOVF   00,F
024E:  BTFSS  03.2
024F:  GOTO   255
....................          return s1; 
0250:  MOVF   42,W
0251:  MOVWF  78
0252:  MOVF   43,W
0253:  MOVWF  79
0254:  GOTO   25C
....................       ++s1; 
0255:  INCF   42,F
0256:  BTFSC  03.2
0257:  INCF   43,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0258:  GOTO   20F
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0259:  MOVLW  00
025A:  MOVWF  78
025B:  MOVWF  79
025C:  RETURN
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0819:  CLRF   25
081A:  CLRF   26
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... char k; 
.................... int num=0; 
....................  
....................  
.................... char clave_subida[] = "1";   // para aumentar al menu 
081B:  MOVLW  31
081C:  MOVWF  29
081D:  CLRF   2A
.................... char subida [1]; 
....................  
.................... char clave_bajada[] = "2";    // para disminuir al menu 
081E:  MOVLW  32
081F:  MOVWF  2C
0820:  CLRF   2D
.................... char bajada [1]; 
....................  
.................... char  clave_ok[] = "#";    // para acceder 
0821:  MOVLW  23
0822:  MOVWF  2F
0823:  CLRF   30
.................... char ok [1]; 
....................  
.................... char clave_siete[]= "A";      // acceder a menu 7oz 
0824:  MOVLW  41
0825:  MOVWF  32
0826:  CLRF   33
.................... char siete[1]; 
....................  
.................... char clave_doce[]= "B";       //acceder a menu 12oz 
0827:  MOVLW  42
0828:  MOVWF  35
0829:  CLRF   36
.................... char doce[2]; 
....................  
.................... int late=0; 
.................... int capuchino=0; 
.................... int expreso=0; 
....................  
.................... int menu=0; 
....................  
....................  
....................  
.................... long a; 
.................... long temp; 
.................... int temp_encendido=35; 
....................  
....................  
....................  
.................... void electro(); 
.................... void lat(); 
.................... void capuchi(); 
.................... void exp(); 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  20
0805:  CLRF   28
0806:  CLRF   39
0807:  CLRF   3A
0808:  CLRF   3B
0809:  CLRF   3C
080A:  MOVLW  23
080B:  MOVWF  41
080C:  BSF    03.5
080D:  BSF    1F.0
080E:  BSF    1F.1
080F:  BSF    1F.2
0810:  BCF    1F.3
0811:  MOVLW  07
0812:  MOVWF  1C
0813:  BCF    03.7
.................... { 
....................  
.................... setup_adc(adc_clock_internal);            //inicia salidas de A en adc 
*
082A:  BSF    03.5
082B:  BCF    1F.6
082C:  BCF    03.5
082D:  BSF    1F.6
082E:  BSF    1F.7
082F:  BSF    03.5
0830:  BSF    1F.7
0831:  BCF    03.5
0832:  BSF    1F.0
.................... setup_adc_ports(all_analog);              // establecer todo puerto A en enalogo 
0833:  BSF    03.5
0834:  BCF    1F.0
0835:  BCF    1F.1
0836:  BCF    1F.2
0837:  BCF    1F.3
....................          set_adc_channel(0); 
0838:  MOVLW  00
0839:  MOVWF  78
083A:  BCF    03.5
083B:  MOVF   1F,W
083C:  ANDLW  C7
083D:  IORWF  78,W
083E:  MOVWF  1F
....................        
....................  
....................  
....................  
....................       lcd_init();       //inicia lcd 
083F:  BCF    0A.3
0840:  GOTO   0CB
0841:  BSF    0A.3
....................       kbd_init();       //inicia tecaldo 
0842:  BCF    0A.3
0843:  GOTO   109
0844:  BSF    0A.3
....................       port_b_pullups(true);      //oficializa pullups 
0845:  BSF    03.5
0846:  BCF    01.7
....................  
....................  
....................  
.................... setup_timer_2(t2_div_by_16,155,1);        //estabiliza timer 2 
0847:  MOVLW  00
0848:  MOVWF  78
0849:  IORLW  06
084A:  BCF    03.5
084B:  MOVWF  12
084C:  MOVLW  9B
084D:  BSF    03.5
084E:  MOVWF  12
.................... setup_ccp1(ccp_pwm);                      // configura pwm 
084F:  BCF    03.5
0850:  BCF    20.2
0851:  MOVF   20,W
0852:  BSF    03.5
0853:  MOVWF  07
0854:  BCF    03.5
0855:  BCF    07.2
0856:  MOVLW  0C
0857:  MOVWF  17
....................  
....................  
....................  
.................... SET_TRIS_D(0xFF);          //D como entradas   
0858:  MOVLW  FF
0859:  BSF    03.5
085A:  MOVWF  08
.................... SET_TRIS_B(0xFF);           //B como entradas           
085B:  MOVWF  06
.................... SET_TRIS_C(0xFF);          //C como entradas  
085C:  MOVWF  07
085D:  BCF    03.5
085E:  MOVWF  20
....................  
....................  
....................  
....................  
....................    while(true) 
....................    { 
....................      num=0;       //numero de keyboard 
085F:  CLRF   28
....................  
....................  
....................  
....................  
....................  
....................  
....................        
....................       switch (menu) {            //generar menu 
0860:  MOVF   3C,W
0861:  ADDLW  FA
0862:  BTFSC  03.0
0863:  GOTO   58B
0864:  ADDLW  06
0865:  GOTO   58D
....................  
....................     case 0:   
....................     num=0; 
0866:  CLRF   28
....................     menu=0; 
0867:  CLRF   3C
....................     late=0; 
0868:  CLRF   39
....................     capuchino=0; 
0869:  CLRF   3A
....................     expreso=0; 
086A:  CLRF   3B
.................... lcd_putc('\f'); 
086B:  MOVLW  0C
086C:  MOVWF  4B
086D:  BCF    0A.3
086E:  CALL   11E
086F:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
0870:  MOVLW  01
0871:  MOVWF  4C
0872:  MOVWF  4D
0873:  BCF    0A.3
0874:  CALL   10C
0875:  BSF    0A.3
....................          lcd_putc("late"); 
0876:  MOVLW  18
0877:  BSF    03.6
0878:  MOVWF  0D
0879:  MOVLW  00
087A:  MOVWF  0F
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   14A
087E:  BSF    0A.3
....................             lcd_gotoxy(10,1); 
087F:  MOVLW  0A
0880:  MOVWF  4C
0881:  MOVLW  01
0882:  MOVWF  4D
0883:  BCF    0A.3
0884:  CALL   10C
0885:  BSF    0A.3
....................          lcd_putc("<<"); 
0886:  MOVLW  1B
0887:  BSF    03.6
0888:  MOVWF  0D
0889:  MOVLW  00
088A:  MOVWF  0F
088B:  BCF    0A.3
088C:  BCF    03.6
088D:  CALL   14A
088E:  BSF    0A.3
....................  
....................  
....................          lcd_gotoxy(1,2); 
088F:  MOVLW  01
0890:  MOVWF  4C
0891:  MOVLW  02
0892:  MOVWF  4D
0893:  BCF    0A.3
0894:  CALL   10C
0895:  BSF    0A.3
....................          lcd_putc("capuchino"); 
0896:  MOVLW  1D
0897:  BSF    03.6
0898:  MOVWF  0D
0899:  MOVLW  00
089A:  MOVWF  0F
089B:  BCF    0A.3
089C:  BCF    03.6
089D:  CALL   14A
089E:  BSF    0A.3
....................  
.................... while(num<1){ 
089F:  MOVF   28,F
08A0:  BTFSS  03.2
08A1:  GOTO   0BE
....................    k=kbd_getc(); 
08A2:  BCF    0A.3
08A3:  CALL   1A0
08A4:  BSF    0A.3
08A5:  MOVF   78,W
08A6:  MOVWF  27
....................    if(k != 0){ 
08A7:  MOVF   27,F
08A8:  BTFSC  03.2
08A9:  GOTO   0BD
....................             
....................           subida[num]=k; 
08AA:  MOVLW  2B
08AB:  ADDWF  28,W
08AC:  MOVWF  04
08AD:  BCF    03.7
08AE:  MOVF   27,W
08AF:  MOVWF  00
....................           bajada[num]=k; 
08B0:  MOVLW  2E
08B1:  ADDWF  28,W
08B2:  MOVWF  04
08B3:  BCF    03.7
08B4:  MOVF   27,W
08B5:  MOVWF  00
....................           ok[num]=k; 
08B6:  MOVLW  31
08B7:  ADDWF  28,W
08B8:  MOVWF  04
08B9:  BCF    03.7
08BA:  MOVF   27,W
08BB:  MOVWF  00
....................           num++; 
08BC:  INCF   28,F
....................  
....................  
.................... } 
08BD:  GOTO   09F
.................... } 
....................  
.................... delay_ms(100); 
08BE:  MOVLW  64
08BF:  MOVWF  4C
08C0:  BCF    0A.3
08C1:  CALL   064
08C2:  BSF    0A.3
....................  
.................... if(strstr(subida , clave_subida)){ 
08C3:  CLRF   43
08C4:  MOVLW  2B
08C5:  MOVWF  42
08C6:  CLRF   45
08C7:  MOVLW  29
08C8:  MOVWF  44
08C9:  BCF    0A.3
08CA:  CALL   20F
08CB:  BSF    0A.3
08CC:  MOVF   78,W
08CD:  IORWF  79,W
08CE:  BTFSC  03.2
08CF:  GOTO   0D7
....................       menu++; 
08D0:  INCF   3C,F
.................... delay_ms(100); 
08D1:  MOVLW  64
08D2:  MOVWF  4C
08D3:  BCF    0A.3
08D4:  CALL   064
08D5:  BSF    0A.3
....................    } 
08D6:  GOTO   0D9
....................     
.................... else { 
.................... menu=1; 
08D7:  MOVLW  01
08D8:  MOVWF  3C
.................... } 
....................  
.................... if(strstr(bajada , clave_bajada)){ 
08D9:  CLRF   43
08DA:  MOVLW  2E
08DB:  MOVWF  42
08DC:  CLRF   45
08DD:  MOVLW  2C
08DE:  MOVWF  44
08DF:  BCF    0A.3
08E0:  CALL   20F
08E1:  BSF    0A.3
08E2:  MOVF   78,W
08E3:  IORWF  79,W
08E4:  BTFSC  03.2
08E5:  GOTO   0EE
....................       menu=2; 
08E6:  MOVLW  02
08E7:  MOVWF  3C
.................... delay_ms(100); 
08E8:  MOVLW  64
08E9:  MOVWF  4C
08EA:  BCF    0A.3
08EB:  CALL   064
08EC:  BSF    0A.3
....................    } 
08ED:  GOTO   0F0
....................     
.................... else { 
.................... menu=1; 
08EE:  MOVLW  01
08EF:  MOVWF  3C
.................... } 
....................      
....................  
.................... if(strstr(ok , clave_ok)){ 
08F0:  CLRF   43
08F1:  MOVLW  31
08F2:  MOVWF  42
08F3:  CLRF   45
08F4:  MOVLW  2F
08F5:  MOVWF  44
08F6:  BCF    0A.3
08F7:  CALL   20F
08F8:  BSF    0A.3
08F9:  MOVF   78,W
08FA:  IORWF  79,W
08FB:  BTFSC  03.2
08FC:  GOTO   11F
....................     lcd_putc('\f'); 
08FD:  MOVLW  0C
08FE:  MOVWF  4B
08FF:  BCF    0A.3
0900:  CALL   11E
0901:  BSF    0A.3
....................          lcd_gotoxy(8,1); 
0902:  MOVLW  08
0903:  MOVWF  4C
0904:  MOVLW  01
0905:  MOVWF  4D
0906:  BCF    0A.3
0907:  CALL   10C
0908:  BSF    0A.3
....................          lcd_putc("late"); 
0909:  MOVLW  22
090A:  BSF    03.6
090B:  MOVWF  0D
090C:  MOVLW  00
090D:  MOVWF  0F
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   14A
0911:  BSF    0A.3
....................                   late++; 
0912:  INCF   39,F
.................... delay_ms(200); 
0913:  MOVLW  C8
0914:  MOVWF  4C
0915:  BCF    0A.3
0916:  CALL   064
0917:  BSF    0A.3
....................       menu=3; 
0918:  MOVLW  03
0919:  MOVWF  3C
.................... delay_ms(100); 
091A:  MOVLW  64
091B:  MOVWF  4C
091C:  BCF    0A.3
091D:  CALL   064
091E:  BSF    0A.3
....................  
....................    }   
....................            break; 
091F:  GOTO   58B
....................  
....................     
....................  
....................  
....................  
....................  
....................     
....................     case 1:          //menu caso 1 (seleccion) 
....................            lcd_putc('\f'); 
0920:  MOVLW  0C
0921:  MOVWF  4B
0922:  BCF    0A.3
0923:  CALL   11E
0924:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
0925:  MOVLW  01
0926:  MOVWF  4C
0927:  MOVWF  4D
0928:  BCF    0A.3
0929:  CALL   10C
092A:  BSF    0A.3
....................          lcd_putc("late"); 
092B:  MOVLW  25
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   14A
0933:  BSF    0A.3
....................  
....................          lcd_gotoxy(1,2); 
0934:  MOVLW  01
0935:  MOVWF  4C
0936:  MOVLW  02
0937:  MOVWF  4D
0938:  BCF    0A.3
0939:  CALL   10C
093A:  BSF    0A.3
....................          lcd_putc("capuchino"); 
093B:  MOVLW  28
093C:  BSF    03.6
093D:  MOVWF  0D
093E:  MOVLW  00
093F:  MOVWF  0F
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   14A
0943:  BSF    0A.3
....................             lcd_gotoxy(10,2); 
0944:  MOVLW  0A
0945:  MOVWF  4C
0946:  MOVLW  02
0947:  MOVWF  4D
0948:  BCF    0A.3
0949:  CALL   10C
094A:  BSF    0A.3
....................          lcd_putc("<<"); 
094B:  MOVLW  2D
094C:  BSF    03.6
094D:  MOVWF  0D
094E:  MOVLW  00
094F:  MOVWF  0F
0950:  BCF    0A.3
0951:  BCF    03.6
0952:  CALL   14A
0953:  BSF    0A.3
.................... while(num<1){ 
0954:  MOVF   28,F
0955:  BTFSS  03.2
0956:  GOTO   173
....................    k=kbd_getc(); 
0957:  BCF    0A.3
0958:  CALL   1A0
0959:  BSF    0A.3
095A:  MOVF   78,W
095B:  MOVWF  27
....................    if(k != 0){     
095C:  MOVF   27,F
095D:  BTFSC  03.2
095E:  GOTO   172
....................           subida[num]=k; 
095F:  MOVLW  2B
0960:  ADDWF  28,W
0961:  MOVWF  04
0962:  BCF    03.7
0963:  MOVF   27,W
0964:  MOVWF  00
....................           bajada[num]=k; 
0965:  MOVLW  2E
0966:  ADDWF  28,W
0967:  MOVWF  04
0968:  BCF    03.7
0969:  MOVF   27,W
096A:  MOVWF  00
....................           ok[num]=k; 
096B:  MOVLW  31
096C:  ADDWF  28,W
096D:  MOVWF  04
096E:  BCF    03.7
096F:  MOVF   27,W
0970:  MOVWF  00
....................           num++; 
0971:  INCF   28,F
....................  
.................... } 
0972:  GOTO   154
.................... } 
....................  
....................       if(strstr(subida , clave_subida)){ 
0973:  CLRF   43
0974:  MOVLW  2B
0975:  MOVWF  42
0976:  CLRF   45
0977:  MOVLW  29
0978:  MOVWF  44
0979:  BCF    0A.3
097A:  CALL   20F
097B:  BSF    0A.3
097C:  MOVF   78,W
097D:  IORWF  79,W
097E:  BTFSC  03.2
097F:  GOTO   187
....................             menu=2; 
0980:  MOVLW  02
0981:  MOVWF  3C
....................             delay_ms(100); 
0982:  MOVLW  64
0983:  MOVWF  4C
0984:  BCF    0A.3
0985:  CALL   064
0986:  BSF    0A.3
....................    } 
....................  
....................       if(strstr(bajada , clave_bajada)){ 
0987:  CLRF   43
0988:  MOVLW  2E
0989:  MOVWF  42
098A:  CLRF   45
098B:  MOVLW  2C
098C:  MOVWF  44
098D:  BCF    0A.3
098E:  CALL   20F
098F:  BSF    0A.3
0990:  MOVF   78,W
0991:  IORWF  79,W
0992:  BTFSC  03.2
0993:  GOTO   19A
....................             menu--; 
0994:  DECF   3C,F
....................       delay_ms(100); 
0995:  MOVLW  64
0996:  MOVWF  4C
0997:  BCF    0A.3
0998:  CALL   064
0999:  BSF    0A.3
....................    } 
.................... if(strstr(ok , clave_ok)){ 
099A:  CLRF   43
099B:  MOVLW  31
099C:  MOVWF  42
099D:  CLRF   45
099E:  MOVLW  2F
099F:  MOVWF  44
09A0:  BCF    0A.3
09A1:  CALL   20F
09A2:  BSF    0A.3
09A3:  MOVF   78,W
09A4:  IORWF  79,W
09A5:  BTFSC  03.2
09A6:  GOTO   1C9
....................     lcd_putc('\f'); 
09A7:  MOVLW  0C
09A8:  MOVWF  4B
09A9:  BCF    0A.3
09AA:  CALL   11E
09AB:  BSF    0A.3
....................          lcd_gotoxy(8,1); 
09AC:  MOVLW  08
09AD:  MOVWF  4C
09AE:  MOVLW  01
09AF:  MOVWF  4D
09B0:  BCF    0A.3
09B1:  CALL   10C
09B2:  BSF    0A.3
....................          lcd_putc("capuchino"); 
09B3:  MOVLW  2F
09B4:  BSF    03.6
09B5:  MOVWF  0D
09B6:  MOVLW  00
09B7:  MOVWF  0F
09B8:  BCF    0A.3
09B9:  BCF    03.6
09BA:  CALL   14A
09BB:  BSF    0A.3
.................... delay_ms(200); 
09BC:  MOVLW  C8
09BD:  MOVWF  4C
09BE:  BCF    0A.3
09BF:  CALL   064
09C0:  BSF    0A.3
....................       menu=3; 
09C1:  MOVLW  03
09C2:  MOVWF  3C
....................       capuchino++; 
09C3:  INCF   3A,F
.................... delay_ms(100); 
09C4:  MOVLW  64
09C5:  MOVWF  4C
09C6:  BCF    0A.3
09C7:  CALL   064
09C8:  BSF    0A.3
....................    }   
.................... delay_ms(200); 
09C9:  MOVLW  C8
09CA:  MOVWF  4C
09CB:  BCF    0A.3
09CC:  CALL   064
09CD:  BSF    0A.3
....................        
....................  break; 
09CE:  GOTO   58B
....................  
....................  
....................  
....................  
....................  
.................... case 2:                    //menu 2 parte de seleccion de temperatura o posicion 
....................            
....................            lcd_putc('\f'); 
09CF:  MOVLW  0C
09D0:  MOVWF  4B
09D1:  BCF    0A.3
09D2:  CALL   11E
09D3:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
09D4:  MOVLW  01
09D5:  MOVWF  4C
09D6:  MOVWF  4D
09D7:  BCF    0A.3
09D8:  CALL   10C
09D9:  BSF    0A.3
....................          lcd_putc("expreso"); 
09DA:  MOVLW  34
09DB:  BSF    03.6
09DC:  MOVWF  0D
09DD:  MOVLW  00
09DE:  MOVWF  0F
09DF:  BCF    0A.3
09E0:  BCF    03.6
09E1:  CALL   14A
09E2:  BSF    0A.3
....................             
....................             lcd_gotoxy(10,1); 
09E3:  MOVLW  0A
09E4:  MOVWF  4C
09E5:  MOVLW  01
09E6:  MOVWF  4D
09E7:  BCF    0A.3
09E8:  CALL   10C
09E9:  BSF    0A.3
....................          lcd_putc("<<"); 
09EA:  MOVLW  38
09EB:  BSF    03.6
09EC:  MOVWF  0D
09ED:  MOVLW  00
09EE:  MOVWF  0F
09EF:  BCF    0A.3
09F0:  BCF    03.6
09F1:  CALL   14A
09F2:  BSF    0A.3
....................  
....................  
.................... while(num<1){ 
09F3:  MOVF   28,F
09F4:  BTFSS  03.2
09F5:  GOTO   212
....................    k=kbd_getc(); 
09F6:  BCF    0A.3
09F7:  CALL   1A0
09F8:  BSF    0A.3
09F9:  MOVF   78,W
09FA:  MOVWF  27
....................    if(k != 0){     
09FB:  MOVF   27,F
09FC:  BTFSC  03.2
09FD:  GOTO   211
....................           subida[num]=k; 
09FE:  MOVLW  2B
09FF:  ADDWF  28,W
0A00:  MOVWF  04
0A01:  BCF    03.7
0A02:  MOVF   27,W
0A03:  MOVWF  00
....................           bajada[num]=k; 
0A04:  MOVLW  2E
0A05:  ADDWF  28,W
0A06:  MOVWF  04
0A07:  BCF    03.7
0A08:  MOVF   27,W
0A09:  MOVWF  00
....................           ok[num]=k; 
0A0A:  MOVLW  31
0A0B:  ADDWF  28,W
0A0C:  MOVWF  04
0A0D:  BCF    03.7
0A0E:  MOVF   27,W
0A0F:  MOVWF  00
....................           num++; 
0A10:  INCF   28,F
....................           
....................  
....................    } 
0A11:  GOTO   1F3
.................... } 
....................  
.................... if(strstr(subida , clave_subida)){ 
0A12:  CLRF   43
0A13:  MOVLW  2B
0A14:  MOVWF  42
0A15:  CLRF   45
0A16:  MOVLW  29
0A17:  MOVWF  44
0A18:  BCF    0A.3
0A19:  CALL   20F
0A1A:  BSF    0A.3
0A1B:  MOVF   78,W
0A1C:  IORWF  79,W
0A1D:  BTFSC  03.2
0A1E:  GOTO   225
....................       menu=0; 
0A1F:  CLRF   3C
.................... delay_ms(100); 
0A20:  MOVLW  64
0A21:  MOVWF  4C
0A22:  BCF    0A.3
0A23:  CALL   064
0A24:  BSF    0A.3
....................    } 
....................     
.................... if(strstr(bajada , clave_bajada)){ 
0A25:  CLRF   43
0A26:  MOVLW  2E
0A27:  MOVWF  42
0A28:  CLRF   45
0A29:  MOVLW  2C
0A2A:  MOVWF  44
0A2B:  BCF    0A.3
0A2C:  CALL   20F
0A2D:  BSF    0A.3
0A2E:  MOVF   78,W
0A2F:  IORWF  79,W
0A30:  BTFSC  03.2
0A31:  GOTO   239
....................       menu=1; 
0A32:  MOVLW  01
0A33:  MOVWF  3C
.................... delay_ms(100); 
0A34:  MOVLW  64
0A35:  MOVWF  4C
0A36:  BCF    0A.3
0A37:  CALL   064
0A38:  BSF    0A.3
....................    } 
....................  if(strstr(ok , clave_ok)){ 
0A39:  CLRF   43
0A3A:  MOVLW  31
0A3B:  MOVWF  42
0A3C:  CLRF   45
0A3D:  MOVLW  2F
0A3E:  MOVWF  44
0A3F:  BCF    0A.3
0A40:  CALL   20F
0A41:  BSF    0A.3
0A42:  MOVF   78,W
0A43:  IORWF  79,W
0A44:  BTFSC  03.2
0A45:  GOTO   268
....................     lcd_putc('\f'); 
0A46:  MOVLW  0C
0A47:  MOVWF  4B
0A48:  BCF    0A.3
0A49:  CALL   11E
0A4A:  BSF    0A.3
....................          lcd_gotoxy(8,1); 
0A4B:  MOVLW  08
0A4C:  MOVWF  4C
0A4D:  MOVLW  01
0A4E:  MOVWF  4D
0A4F:  BCF    0A.3
0A50:  CALL   10C
0A51:  BSF    0A.3
....................          lcd_putc("expreso"); 
0A52:  MOVLW  3A
0A53:  BSF    03.6
0A54:  MOVWF  0D
0A55:  MOVLW  00
0A56:  MOVWF  0F
0A57:  BCF    0A.3
0A58:  BCF    03.6
0A59:  CALL   14A
0A5A:  BSF    0A.3
....................          expreso++; 
0A5B:  INCF   3B,F
.................... delay_ms(200); 
0A5C:  MOVLW  C8
0A5D:  MOVWF  4C
0A5E:  BCF    0A.3
0A5F:  CALL   064
0A60:  BSF    0A.3
....................       menu=3; 
0A61:  MOVLW  03
0A62:  MOVWF  3C
.................... delay_ms(100); 
0A63:  MOVLW  64
0A64:  MOVWF  4C
0A65:  BCF    0A.3
0A66:  CALL   064
0A67:  BSF    0A.3
....................    }     
....................  delay_ms(200); 
0A68:  MOVLW  C8
0A69:  MOVWF  4C
0A6A:  BCF    0A.3
0A6B:  CALL   064
0A6C:  BSF    0A.3
....................  
....................  
....................  
....................  
.................... break; 
0A6D:  GOTO   58B
....................  
.................... case 3: 
....................     lcd_putc('\f'); 
0A6E:  MOVLW  0C
0A6F:  MOVWF  4B
0A70:  BCF    0A.3
0A71:  CALL   11E
0A72:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
0A73:  MOVLW  01
0A74:  MOVWF  4C
0A75:  MOVWF  4D
0A76:  BCF    0A.3
0A77:  CALL   10C
0A78:  BSF    0A.3
....................          lcd_putc("7oz = A"); 
0A79:  MOVLW  3E
0A7A:  BSF    03.6
0A7B:  MOVWF  0D
0A7C:  MOVLW  00
0A7D:  MOVWF  0F
0A7E:  BCF    0A.3
0A7F:  BCF    03.6
0A80:  CALL   14A
0A81:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0A82:  MOVLW  01
0A83:  MOVWF  4C
0A84:  MOVLW  02
0A85:  MOVWF  4D
0A86:  BCF    0A.3
0A87:  CALL   10C
0A88:  BSF    0A.3
....................          lcd_putc("12oz = B"); 
0A89:  MOVLW  42
0A8A:  BSF    03.6
0A8B:  MOVWF  0D
0A8C:  MOVLW  00
0A8D:  MOVWF  0F
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   14A
0A91:  BSF    0A.3
.................... delay_ms(200); 
0A92:  MOVLW  C8
0A93:  MOVWF  4C
0A94:  BCF    0A.3
0A95:  CALL   064
0A96:  BSF    0A.3
....................  
....................  
....................  
....................  
....................  
.................... while(num<1){ 
0A97:  MOVF   28,F
0A98:  BTFSS  03.2
0A99:  GOTO   2C2
....................    k=kbd_getc(); 
0A9A:  BCF    0A.3
0A9B:  CALL   1A0
0A9C:  BSF    0A.3
0A9D:  MOVF   78,W
0A9E:  MOVWF  27
....................    if(k != 0){     
0A9F:  MOVF   27,F
0AA0:  BTFSC  03.2
0AA1:  GOTO   2C1
....................           siete[num]=k; 
0AA2:  MOVLW  34
0AA3:  ADDWF  28,W
0AA4:  MOVWF  04
0AA5:  BCF    03.7
0AA6:  MOVF   27,W
0AA7:  MOVWF  00
....................           doce[num]=k; 
0AA8:  MOVLW  37
0AA9:  ADDWF  28,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  MOVF   27,W
0AAD:  MOVWF  00
....................           ok[num]=k; 
0AAE:  MOVLW  31
0AAF:  ADDWF  28,W
0AB0:  MOVWF  04
0AB1:  BCF    03.7
0AB2:  MOVF   27,W
0AB3:  MOVWF  00
....................           num++; 
0AB4:  INCF   28,F
....................          lcd_gotoxy(10,1); 
0AB5:  MOVLW  0A
0AB6:  MOVWF  4C
0AB7:  MOVLW  01
0AB8:  MOVWF  4D
0AB9:  BCF    0A.3
0ABA:  CALL   10C
0ABB:  BSF    0A.3
....................          lcd_putc(k); 
0ABC:  MOVF   27,W
0ABD:  MOVWF  4B
0ABE:  BCF    0A.3
0ABF:  CALL   11E
0AC0:  BSF    0A.3
....................    } 
0AC1:  GOTO   297
.................... } 
.................... if(strstr(siete , clave_siete)){ 
0AC2:  CLRF   43
0AC3:  MOVLW  34
0AC4:  MOVWF  42
0AC5:  CLRF   45
0AC6:  MOVLW  32
0AC7:  MOVWF  44
0AC8:  BCF    0A.3
0AC9:  CALL   20F
0ACA:  BSF    0A.3
0ACB:  MOVF   78,W
0ACC:  IORWF  79,W
0ACD:  BTFSC  03.2
0ACE:  GOTO   2D6
.................... menu=4; 
0ACF:  MOVLW  04
0AD0:  MOVWF  3C
.................... delay_ms(100); 
0AD1:  MOVLW  64
0AD2:  MOVWF  4C
0AD3:  BCF    0A.3
0AD4:  CALL   064
0AD5:  BSF    0A.3
....................    } 
....................  
.................... if(strstr(doce , clave_doce)){ 
0AD6:  CLRF   43
0AD7:  MOVLW  37
0AD8:  MOVWF  42
0AD9:  CLRF   45
0ADA:  MOVLW  35
0ADB:  MOVWF  44
0ADC:  BCF    0A.3
0ADD:  CALL   20F
0ADE:  BSF    0A.3
0ADF:  MOVF   78,W
0AE0:  IORWF  79,W
0AE1:  BTFSC  03.2
0AE2:  GOTO   2EA
.................... menu=5; 
0AE3:  MOVLW  05
0AE4:  MOVWF  3C
.................... delay_ms(100); 
0AE5:  MOVLW  64
0AE6:  MOVWF  4C
0AE7:  BCF    0A.3
0AE8:  CALL   064
0AE9:  BSF    0A.3
....................    } 
.................... break; 
0AEA:  GOTO   58B
....................  
.................... case 4: 
....................           lcd_putc('\f'); 
0AEB:  MOVLW  0C
0AEC:  MOVWF  4B
0AED:  BCF    0A.3
0AEE:  CALL   11E
0AEF:  BSF    0A.3
....................              lcd_gotoxy(1,1); 
0AF0:  MOVLW  01
0AF1:  MOVWF  4C
0AF2:  MOVWF  4D
0AF3:  BCF    0A.3
0AF4:  CALL   10C
0AF5:  BSF    0A.3
....................          lcd_putc("7oz"); 
0AF6:  MOVLW  47
0AF7:  BSF    03.6
0AF8:  MOVWF  0D
0AF9:  MOVLW  00
0AFA:  MOVWF  0F
0AFB:  BCF    0A.3
0AFC:  BCF    03.6
0AFD:  CALL   14A
0AFE:  BSF    0A.3
....................  
....................  
.................... if(late==1){ 
0AFF:  DECFSZ 39,W
0B00:  GOTO   368
....................  
....................  
....................  
....................          lcd_gotoxy(10,1); 
0B01:  MOVLW  0A
0B02:  MOVWF  4C
0B03:  MOVLW  01
0B04:  MOVWF  4D
0B05:  BCF    0A.3
0B06:  CALL   10C
0B07:  BSF    0A.3
....................         lcd_putc("late"); 
0B08:  MOVLW  49
0B09:  BSF    03.6
0B0A:  MOVWF  0D
0B0B:  MOVLW  00
0B0C:  MOVWF  0F
0B0D:  BCF    0A.3
0B0E:  BCF    03.6
0B0F:  CALL   14A
0B10:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0B11:  MOVLW  01
0B12:  MOVWF  4C
0B13:  MOVLW  02
0B14:  MOVWF  4D
0B15:  BCF    0A.3
0B16:  CALL   10C
0B17:  BSF    0A.3
....................          a=read_adc(); 
0B18:  BSF    1F.2
0B19:  BTFSC  1F.2
0B1A:  GOTO   319
0B1B:  BSF    03.5
0B1C:  MOVF   1E,W
0B1D:  BCF    03.5
0B1E:  MOVWF  3D
0B1F:  MOVF   1E,W
0B20:  MOVWF  3E
....................          temp=(a*0.4882); 
0B21:  MOVF   3E,W
0B22:  MOVWF  43
0B23:  MOVF   3D,W
0B24:  MOVWF  42
0B25:  BCF    0A.3
0B26:  CALL   25D
0B27:  BSF    0A.3
0B28:  MOVF   7A,W
0B29:  MOVWF  45
0B2A:  MOVF   79,W
0B2B:  MOVWF  44
0B2C:  MOVF   78,W
0B2D:  MOVWF  43
0B2E:  MOVF   77,W
0B2F:  MOVWF  42
0B30:  MOVLW  5A
0B31:  MOVWF  49
0B32:  MOVLW  F5
0B33:  MOVWF  48
0B34:  MOVLW  79
0B35:  MOVWF  47
0B36:  MOVLW  7D
0B37:  MOVWF  46
0B38:  BCF    0A.3
0B39:  CALL   27A
0B3A:  BSF    0A.3
0B3B:  MOVF   7A,W
0B3C:  MOVWF  45
0B3D:  MOVF   79,W
0B3E:  MOVWF  44
0B3F:  MOVF   78,W
0B40:  MOVWF  43
0B41:  MOVF   77,W
0B42:  MOVWF  42
0B43:  BCF    0A.3
0B44:  CALL   2EF
0B45:  BSF    0A.3
0B46:  MOVF   79,W
0B47:  MOVWF  40
0B48:  MOVF   78,W
0B49:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0B4A:  MOVLW  10
0B4B:  MOVWF  04
0B4C:  MOVF   40,W
0B4D:  MOVWF  43
0B4E:  MOVF   3F,W
0B4F:  MOVWF  42
0B50:  BCF    0A.3
0B51:  CALL   30E
0B52:  BSF    0A.3
0B53:  MOVLW  20
0B54:  MOVWF  4B
0B55:  BCF    0A.3
0B56:  CALL   11E
0B57:  BSF    0A.3
0B58:  MOVLW  43
0B59:  MOVWF  4B
0B5A:  BCF    0A.3
0B5B:  CALL   11E
0B5C:  BSF    0A.3
....................  
....................          electro(); 
0B5D:  BCF    0A.3
0B5E:  CALL   371
0B5F:  BSF    0A.3
....................          lat(); 
0B60:  BCF    0A.3
0B61:  CALL   381
0B62:  BSF    0A.3
....................          delay_ms(200);  
0B63:  MOVLW  C8
0B64:  MOVWF  4C
0B65:  BCF    0A.3
0B66:  CALL   064
0B67:  BSF    0A.3
....................        
.................... } 
....................  
....................  
.................... if(capuchino==1){ 
0B68:  DECFSZ 3A,W
0B69:  GOTO   3D0
....................    late=0; 
0B6A:  CLRF   39
....................  
....................  
....................  
....................         lcd_gotoxy(10,1); 
0B6B:  MOVLW  0A
0B6C:  MOVWF  4C
0B6D:  MOVLW  01
0B6E:  MOVWF  4D
0B6F:  BCF    0A.3
0B70:  CALL   10C
0B71:  BSF    0A.3
....................          lcd_putc("capuchino"); 
0B72:  MOVLW  4C
0B73:  BSF    03.6
0B74:  MOVWF  0D
0B75:  MOVLW  00
0B76:  MOVWF  0F
0B77:  BCF    0A.3
0B78:  BCF    03.6
0B79:  CALL   14A
0B7A:  BSF    0A.3
....................          delay_ms(200); 
0B7B:  MOVLW  C8
0B7C:  MOVWF  4C
0B7D:  BCF    0A.3
0B7E:  CALL   064
0B7F:  BSF    0A.3
....................          a=read_adc(); 
0B80:  BSF    1F.2
0B81:  BTFSC  1F.2
0B82:  GOTO   381
0B83:  BSF    03.5
0B84:  MOVF   1E,W
0B85:  BCF    03.5
0B86:  MOVWF  3D
0B87:  MOVF   1E,W
0B88:  MOVWF  3E
....................          temp=(a*0.4882); 
0B89:  MOVF   3E,W
0B8A:  MOVWF  43
0B8B:  MOVF   3D,W
0B8C:  MOVWF  42
0B8D:  BCF    0A.3
0B8E:  CALL   25D
0B8F:  BSF    0A.3
0B90:  MOVF   7A,W
0B91:  MOVWF  45
0B92:  MOVF   79,W
0B93:  MOVWF  44
0B94:  MOVF   78,W
0B95:  MOVWF  43
0B96:  MOVF   77,W
0B97:  MOVWF  42
0B98:  MOVLW  5A
0B99:  MOVWF  49
0B9A:  MOVLW  F5
0B9B:  MOVWF  48
0B9C:  MOVLW  79
0B9D:  MOVWF  47
0B9E:  MOVLW  7D
0B9F:  MOVWF  46
0BA0:  BCF    0A.3
0BA1:  CALL   27A
0BA2:  BSF    0A.3
0BA3:  MOVF   7A,W
0BA4:  MOVWF  45
0BA5:  MOVF   79,W
0BA6:  MOVWF  44
0BA7:  MOVF   78,W
0BA8:  MOVWF  43
0BA9:  MOVF   77,W
0BAA:  MOVWF  42
0BAB:  BCF    0A.3
0BAC:  CALL   2EF
0BAD:  BSF    0A.3
0BAE:  MOVF   79,W
0BAF:  MOVWF  40
0BB0:  MOVF   78,W
0BB1:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0BB2:  MOVLW  10
0BB3:  MOVWF  04
0BB4:  MOVF   40,W
0BB5:  MOVWF  43
0BB6:  MOVF   3F,W
0BB7:  MOVWF  42
0BB8:  BCF    0A.3
0BB9:  CALL   30E
0BBA:  BSF    0A.3
0BBB:  MOVLW  20
0BBC:  MOVWF  4B
0BBD:  BCF    0A.3
0BBE:  CALL   11E
0BBF:  BSF    0A.3
0BC0:  MOVLW  43
0BC1:  MOVWF  4B
0BC2:  BCF    0A.3
0BC3:  CALL   11E
0BC4:  BSF    0A.3
....................     
....................          electro(); 
0BC5:  BCF    0A.3
0BC6:  CALL   371
0BC7:  BSF    0A.3
....................          capuchi();      delay_ms(200);  
0BC8:  BCF    0A.3
0BC9:  CALL   3A2
0BCA:  BSF    0A.3
0BCB:  MOVLW  C8
0BCC:  MOVWF  4C
0BCD:  BCF    0A.3
0BCE:  CALL   064
0BCF:  BSF    0A.3
.................... } 
....................  
.................... if (expreso==1){ 
0BD0:  DECFSZ 3B,W
0BD1:  GOTO   438
....................  
.................... late=0; 
0BD2:  CLRF   39
....................             lcd_gotoxy(10,1); 
0BD3:  MOVLW  0A
0BD4:  MOVWF  4C
0BD5:  MOVLW  01
0BD6:  MOVWF  4D
0BD7:  BCF    0A.3
0BD8:  CALL   10C
0BD9:  BSF    0A.3
....................          lcd_putc("expreso"); 
0BDA:  MOVLW  51
0BDB:  BSF    03.6
0BDC:  MOVWF  0D
0BDD:  MOVLW  00
0BDE:  MOVWF  0F
0BDF:  BCF    0A.3
0BE0:  BCF    03.6
0BE1:  CALL   14A
0BE2:  BSF    0A.3
....................          delay_ms(200); 
0BE3:  MOVLW  C8
0BE4:  MOVWF  4C
0BE5:  BCF    0A.3
0BE6:  CALL   064
0BE7:  BSF    0A.3
....................          a=read_adc(); 
0BE8:  BSF    1F.2
0BE9:  BTFSC  1F.2
0BEA:  GOTO   3E9
0BEB:  BSF    03.5
0BEC:  MOVF   1E,W
0BED:  BCF    03.5
0BEE:  MOVWF  3D
0BEF:  MOVF   1E,W
0BF0:  MOVWF  3E
....................          temp=(a*0.4882); 
0BF1:  MOVF   3E,W
0BF2:  MOVWF  43
0BF3:  MOVF   3D,W
0BF4:  MOVWF  42
0BF5:  BCF    0A.3
0BF6:  CALL   25D
0BF7:  BSF    0A.3
0BF8:  MOVF   7A,W
0BF9:  MOVWF  45
0BFA:  MOVF   79,W
0BFB:  MOVWF  44
0BFC:  MOVF   78,W
0BFD:  MOVWF  43
0BFE:  MOVF   77,W
0BFF:  MOVWF  42
0C00:  MOVLW  5A
0C01:  MOVWF  49
0C02:  MOVLW  F5
0C03:  MOVWF  48
0C04:  MOVLW  79
0C05:  MOVWF  47
0C06:  MOVLW  7D
0C07:  MOVWF  46
0C08:  BCF    0A.3
0C09:  CALL   27A
0C0A:  BSF    0A.3
0C0B:  MOVF   7A,W
0C0C:  MOVWF  45
0C0D:  MOVF   79,W
0C0E:  MOVWF  44
0C0F:  MOVF   78,W
0C10:  MOVWF  43
0C11:  MOVF   77,W
0C12:  MOVWF  42
0C13:  BCF    0A.3
0C14:  CALL   2EF
0C15:  BSF    0A.3
0C16:  MOVF   79,W
0C17:  MOVWF  40
0C18:  MOVF   78,W
0C19:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0C1A:  MOVLW  10
0C1B:  MOVWF  04
0C1C:  MOVF   40,W
0C1D:  MOVWF  43
0C1E:  MOVF   3F,W
0C1F:  MOVWF  42
0C20:  BCF    0A.3
0C21:  CALL   30E
0C22:  BSF    0A.3
0C23:  MOVLW  20
0C24:  MOVWF  4B
0C25:  BCF    0A.3
0C26:  CALL   11E
0C27:  BSF    0A.3
0C28:  MOVLW  43
0C29:  MOVWF  4B
0C2A:  BCF    0A.3
0C2B:  CALL   11E
0C2C:  BSF    0A.3
....................     
....................          electro(); 
0C2D:  BCF    0A.3
0C2E:  CALL   371
0C2F:  BSF    0A.3
....................          exp(); 
0C30:  BCF    0A.3
0C31:  CALL   3C3
0C32:  BSF    0A.3
....................       delay_ms(200);  
0C33:  MOVLW  C8
0C34:  MOVWF  4C
0C35:  BCF    0A.3
0C36:  CALL   064
0C37:  BSF    0A.3
.................... } 
....................  
....................  
....................  
.................... break; 
0C38:  GOTO   58B
....................  
.................... case 5: 
....................           lcd_putc('\f'); 
0C39:  MOVLW  0C
0C3A:  MOVWF  4B
0C3B:  BCF    0A.3
0C3C:  CALL   11E
0C3D:  BSF    0A.3
....................              lcd_gotoxy(1,1); 
0C3E:  MOVLW  01
0C3F:  MOVWF  4C
0C40:  MOVWF  4D
0C41:  BCF    0A.3
0C42:  CALL   10C
0C43:  BSF    0A.3
....................          lcd_putc("12oz"); 
0C44:  MOVLW  55
0C45:  BSF    03.6
0C46:  MOVWF  0D
0C47:  MOVLW  00
0C48:  MOVWF  0F
0C49:  BCF    0A.3
0C4A:  BCF    03.6
0C4B:  CALL   14A
0C4C:  BSF    0A.3
.................... delay_ms(100); 
0C4D:  MOVLW  64
0C4E:  MOVWF  4C
0C4F:  BCF    0A.3
0C50:  CALL   064
0C51:  BSF    0A.3
....................  
.................... if(late==1){ 
0C52:  DECFSZ 39,W
0C53:  GOTO   4BB
....................  
....................  
....................  
....................          lcd_gotoxy(10,1); 
0C54:  MOVLW  0A
0C55:  MOVWF  4C
0C56:  MOVLW  01
0C57:  MOVWF  4D
0C58:  BCF    0A.3
0C59:  CALL   10C
0C5A:  BSF    0A.3
....................         lcd_putc("late"); 
0C5B:  MOVLW  58
0C5C:  BSF    03.6
0C5D:  MOVWF  0D
0C5E:  MOVLW  00
0C5F:  MOVWF  0F
0C60:  BCF    0A.3
0C61:  BCF    03.6
0C62:  CALL   14A
0C63:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0C64:  MOVLW  01
0C65:  MOVWF  4C
0C66:  MOVLW  02
0C67:  MOVWF  4D
0C68:  BCF    0A.3
0C69:  CALL   10C
0C6A:  BSF    0A.3
....................          a=read_adc(); 
0C6B:  BSF    1F.2
0C6C:  BTFSC  1F.2
0C6D:  GOTO   46C
0C6E:  BSF    03.5
0C6F:  MOVF   1E,W
0C70:  BCF    03.5
0C71:  MOVWF  3D
0C72:  MOVF   1E,W
0C73:  MOVWF  3E
....................          temp=(a*0.4882); 
0C74:  MOVF   3E,W
0C75:  MOVWF  43
0C76:  MOVF   3D,W
0C77:  MOVWF  42
0C78:  BCF    0A.3
0C79:  CALL   25D
0C7A:  BSF    0A.3
0C7B:  MOVF   7A,W
0C7C:  MOVWF  45
0C7D:  MOVF   79,W
0C7E:  MOVWF  44
0C7F:  MOVF   78,W
0C80:  MOVWF  43
0C81:  MOVF   77,W
0C82:  MOVWF  42
0C83:  MOVLW  5A
0C84:  MOVWF  49
0C85:  MOVLW  F5
0C86:  MOVWF  48
0C87:  MOVLW  79
0C88:  MOVWF  47
0C89:  MOVLW  7D
0C8A:  MOVWF  46
0C8B:  BCF    0A.3
0C8C:  CALL   27A
0C8D:  BSF    0A.3
0C8E:  MOVF   7A,W
0C8F:  MOVWF  45
0C90:  MOVF   79,W
0C91:  MOVWF  44
0C92:  MOVF   78,W
0C93:  MOVWF  43
0C94:  MOVF   77,W
0C95:  MOVWF  42
0C96:  BCF    0A.3
0C97:  CALL   2EF
0C98:  BSF    0A.3
0C99:  MOVF   79,W
0C9A:  MOVWF  40
0C9B:  MOVF   78,W
0C9C:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0C9D:  MOVLW  10
0C9E:  MOVWF  04
0C9F:  MOVF   40,W
0CA0:  MOVWF  43
0CA1:  MOVF   3F,W
0CA2:  MOVWF  42
0CA3:  BCF    0A.3
0CA4:  CALL   30E
0CA5:  BSF    0A.3
0CA6:  MOVLW  20
0CA7:  MOVWF  4B
0CA8:  BCF    0A.3
0CA9:  CALL   11E
0CAA:  BSF    0A.3
0CAB:  MOVLW  43
0CAC:  MOVWF  4B
0CAD:  BCF    0A.3
0CAE:  CALL   11E
0CAF:  BSF    0A.3
....................          
....................          electro(); 
0CB0:  BCF    0A.3
0CB1:  CALL   371
0CB2:  BSF    0A.3
....................          lat(); 
0CB3:  BCF    0A.3
0CB4:  CALL   381
0CB5:  BSF    0A.3
....................  delay_ms(200);  
0CB6:  MOVLW  C8
0CB7:  MOVWF  4C
0CB8:  BCF    0A.3
0CB9:  CALL   064
0CBA:  BSF    0A.3
....................        
.................... } 
....................  
....................  
.................... if(capuchino==1){ 
0CBB:  DECFSZ 3A,W
0CBC:  GOTO   523
....................    late=0; 
0CBD:  CLRF   39
....................  
....................  
....................  
....................         lcd_gotoxy(10,1); 
0CBE:  MOVLW  0A
0CBF:  MOVWF  4C
0CC0:  MOVLW  01
0CC1:  MOVWF  4D
0CC2:  BCF    0A.3
0CC3:  CALL   10C
0CC4:  BSF    0A.3
....................          lcd_putc("capuchino"); 
0CC5:  MOVLW  5B
0CC6:  BSF    03.6
0CC7:  MOVWF  0D
0CC8:  MOVLW  00
0CC9:  MOVWF  0F
0CCA:  BCF    0A.3
0CCB:  BCF    03.6
0CCC:  CALL   14A
0CCD:  BSF    0A.3
....................          delay_ms(200); 
0CCE:  MOVLW  C8
0CCF:  MOVWF  4C
0CD0:  BCF    0A.3
0CD1:  CALL   064
0CD2:  BSF    0A.3
....................          a=read_adc(); 
0CD3:  BSF    1F.2
0CD4:  BTFSC  1F.2
0CD5:  GOTO   4D4
0CD6:  BSF    03.5
0CD7:  MOVF   1E,W
0CD8:  BCF    03.5
0CD9:  MOVWF  3D
0CDA:  MOVF   1E,W
0CDB:  MOVWF  3E
....................          temp=(a*0.4882); 
0CDC:  MOVF   3E,W
0CDD:  MOVWF  43
0CDE:  MOVF   3D,W
0CDF:  MOVWF  42
0CE0:  BCF    0A.3
0CE1:  CALL   25D
0CE2:  BSF    0A.3
0CE3:  MOVF   7A,W
0CE4:  MOVWF  45
0CE5:  MOVF   79,W
0CE6:  MOVWF  44
0CE7:  MOVF   78,W
0CE8:  MOVWF  43
0CE9:  MOVF   77,W
0CEA:  MOVWF  42
0CEB:  MOVLW  5A
0CEC:  MOVWF  49
0CED:  MOVLW  F5
0CEE:  MOVWF  48
0CEF:  MOVLW  79
0CF0:  MOVWF  47
0CF1:  MOVLW  7D
0CF2:  MOVWF  46
0CF3:  BCF    0A.3
0CF4:  CALL   27A
0CF5:  BSF    0A.3
0CF6:  MOVF   7A,W
0CF7:  MOVWF  45
0CF8:  MOVF   79,W
0CF9:  MOVWF  44
0CFA:  MOVF   78,W
0CFB:  MOVWF  43
0CFC:  MOVF   77,W
0CFD:  MOVWF  42
0CFE:  BCF    0A.3
0CFF:  CALL   2EF
0D00:  BSF    0A.3
0D01:  MOVF   79,W
0D02:  MOVWF  40
0D03:  MOVF   78,W
0D04:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0D05:  MOVLW  10
0D06:  MOVWF  04
0D07:  MOVF   40,W
0D08:  MOVWF  43
0D09:  MOVF   3F,W
0D0A:  MOVWF  42
0D0B:  BCF    0A.3
0D0C:  CALL   30E
0D0D:  BSF    0A.3
0D0E:  MOVLW  20
0D0F:  MOVWF  4B
0D10:  BCF    0A.3
0D11:  CALL   11E
0D12:  BSF    0A.3
0D13:  MOVLW  43
0D14:  MOVWF  4B
0D15:  BCF    0A.3
0D16:  CALL   11E
0D17:  BSF    0A.3
....................        
....................          electro(); 
0D18:  BCF    0A.3
0D19:  CALL   371
0D1A:  BSF    0A.3
....................          capuchi();   delay_ms(200);  
0D1B:  BCF    0A.3
0D1C:  CALL   3A2
0D1D:  BSF    0A.3
0D1E:  MOVLW  C8
0D1F:  MOVWF  4C
0D20:  BCF    0A.3
0D21:  CALL   064
0D22:  BSF    0A.3
.................... } 
....................  
.................... if (expreso==1){ 
0D23:  DECFSZ 3B,W
0D24:  GOTO   58B
....................  
.................... late=0; 
0D25:  CLRF   39
....................             lcd_gotoxy(10,1); 
0D26:  MOVLW  0A
0D27:  MOVWF  4C
0D28:  MOVLW  01
0D29:  MOVWF  4D
0D2A:  BCF    0A.3
0D2B:  CALL   10C
0D2C:  BSF    0A.3
....................          lcd_putc("expreso"); 
0D2D:  MOVLW  60
0D2E:  BSF    03.6
0D2F:  MOVWF  0D
0D30:  MOVLW  00
0D31:  MOVWF  0F
0D32:  BCF    0A.3
0D33:  BCF    03.6
0D34:  CALL   14A
0D35:  BSF    0A.3
....................          delay_ms(200); 
0D36:  MOVLW  C8
0D37:  MOVWF  4C
0D38:  BCF    0A.3
0D39:  CALL   064
0D3A:  BSF    0A.3
....................          a=read_adc(); 
0D3B:  BSF    1F.2
0D3C:  BTFSC  1F.2
0D3D:  GOTO   53C
0D3E:  BSF    03.5
0D3F:  MOVF   1E,W
0D40:  BCF    03.5
0D41:  MOVWF  3D
0D42:  MOVF   1E,W
0D43:  MOVWF  3E
....................          temp=(a*0.4882); 
0D44:  MOVF   3E,W
0D45:  MOVWF  43
0D46:  MOVF   3D,W
0D47:  MOVWF  42
0D48:  BCF    0A.3
0D49:  CALL   25D
0D4A:  BSF    0A.3
0D4B:  MOVF   7A,W
0D4C:  MOVWF  45
0D4D:  MOVF   79,W
0D4E:  MOVWF  44
0D4F:  MOVF   78,W
0D50:  MOVWF  43
0D51:  MOVF   77,W
0D52:  MOVWF  42
0D53:  MOVLW  5A
0D54:  MOVWF  49
0D55:  MOVLW  F5
0D56:  MOVWF  48
0D57:  MOVLW  79
0D58:  MOVWF  47
0D59:  MOVLW  7D
0D5A:  MOVWF  46
0D5B:  BCF    0A.3
0D5C:  CALL   27A
0D5D:  BSF    0A.3
0D5E:  MOVF   7A,W
0D5F:  MOVWF  45
0D60:  MOVF   79,W
0D61:  MOVWF  44
0D62:  MOVF   78,W
0D63:  MOVWF  43
0D64:  MOVF   77,W
0D65:  MOVWF  42
0D66:  BCF    0A.3
0D67:  CALL   2EF
0D68:  BSF    0A.3
0D69:  MOVF   79,W
0D6A:  MOVWF  40
0D6B:  MOVF   78,W
0D6C:  MOVWF  3F
....................          printf(lcd_putc,"%Lu C",temp); 
0D6D:  MOVLW  10
0D6E:  MOVWF  04
0D6F:  MOVF   40,W
0D70:  MOVWF  43
0D71:  MOVF   3F,W
0D72:  MOVWF  42
0D73:  BCF    0A.3
0D74:  CALL   30E
0D75:  BSF    0A.3
0D76:  MOVLW  20
0D77:  MOVWF  4B
0D78:  BCF    0A.3
0D79:  CALL   11E
0D7A:  BSF    0A.3
0D7B:  MOVLW  43
0D7C:  MOVWF  4B
0D7D:  BCF    0A.3
0D7E:  CALL   11E
0D7F:  BSF    0A.3
....................          
....................          electro(); 
0D80:  BCF    0A.3
0D81:  CALL   371
0D82:  BSF    0A.3
....................          exp(); 
0D83:  BCF    0A.3
0D84:  CALL   3C3
0D85:  BSF    0A.3
....................  delay_ms(200);  
0D86:  MOVLW  C8
0D87:  MOVWF  4C
0D88:  BCF    0A.3
0D89:  CALL   064
0D8A:  BSF    0A.3
.................... } 
....................  
....................  
.................... break; 
....................  
....................  
.................... } 
0D8B:  GOTO   05F
.................... } 
.................... } 
....................  
0D8C:  SLEEP
....................  
....................  
....................  
....................  
....................  
.................... void electro() 
.................... {      
.................... if (temp>=temp_encendido){ 
*
0371:  MOVF   40,F
0372:  BTFSS  03.2
0373:  GOTO   378
0374:  MOVF   41,W
0375:  SUBWF  3F,W
0376:  BTFSS  03.0
0377:  GOTO   37F
....................    SET_TRIS_e(0x00); // como salidas 
0378:  BSF    03.5
0379:  BCF    09.0
037A:  BCF    09.1
037B:  BCF    09.2
....................    output_high(PIN_E0); 
037C:  BCF    03.5
037D:  BSF    09.0
.................... } 
037E:  GOTO   380
.................... else  
....................  output_low(PIN_E0);          
037F:  BCF    09.0
0380:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void lat(){ 
....................     
.................... setup_timer_2(t2_div_by_16,155,1);        //estabiliza timer 2 
0381:  MOVLW  00
0382:  MOVWF  78
0383:  IORLW  06
0384:  MOVWF  12
0385:  MOVLW  9B
0386:  BSF    03.5
0387:  MOVWF  12
.................... setup_ccp1(ccp_pwm);                      // configura pwm 
0388:  BCF    03.5
0389:  BCF    20.2
038A:  MOVF   20,W
038B:  BSF    03.5
038C:  MOVWF  07
038D:  BCF    03.5
038E:  BCF    07.2
038F:  MOVLW  0C
0390:  MOVWF  17
....................  
....................  
....................       set_pwm1_duty(1500); 
0391:  MOVLW  77
0392:  MOVWF  15
0393:  MOVF   17,W
0394:  ANDLW  CF
0395:  MOVWF  17
....................       delay_ms(2000); 
0396:  MOVLW  08
0397:  MOVWF  42
0398:  MOVLW  FA
0399:  MOVWF  4C
039A:  CALL   064
039B:  DECFSZ 42,F
039C:  GOTO   398
....................     
....................       menu=0; 
039D:  CLRF   3C
.................... if(menu==0){ 
039E:  MOVF   3C,F
039F:  BTFSC  03.2
....................  
....................    set_pwm1_duty(0); 
03A0:  CLRF   15
.................... } 
03A1:  RETURN
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void capuchi(){ 
.................... setup_timer_2(t2_div_by_16,155,1);        //estabiliza timer 2 
03A2:  MOVLW  00
03A3:  MOVWF  78
03A4:  IORLW  06
03A5:  MOVWF  12
03A6:  MOVLW  9B
03A7:  BSF    03.5
03A8:  MOVWF  12
.................... setup_ccp1(ccp_pwm);                      // configura pwm 
03A9:  BCF    03.5
03AA:  BCF    20.2
03AB:  MOVF   20,W
03AC:  BSF    03.5
03AD:  MOVWF  07
03AE:  BCF    03.5
03AF:  BCF    07.2
03B0:  MOVLW  0C
03B1:  MOVWF  17
....................  
....................  
....................       set_pwm1_duty(1000); 
03B2:  MOVLW  FA
03B3:  MOVWF  15
03B4:  MOVF   17,W
03B5:  ANDLW  CF
03B6:  MOVWF  17
....................       delay_ms(2000); 
03B7:  MOVLW  08
03B8:  MOVWF  42
03B9:  MOVLW  FA
03BA:  MOVWF  4C
03BB:  CALL   064
03BC:  DECFSZ 42,F
03BD:  GOTO   3B9
....................     
....................       menu=0; 
03BE:  CLRF   3C
.................... if(menu==0){ 
03BF:  MOVF   3C,F
03C0:  BTFSC  03.2
....................  
....................    set_pwm1_duty(0); 
03C1:  CLRF   15
.................... } 
03C2:  RETURN
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void exp(){ 
.................... setup_timer_2(t2_div_by_16,155,1);        //estabiliza timer 2 
03C3:  MOVLW  00
03C4:  MOVWF  78
03C5:  IORLW  06
03C6:  MOVWF  12
03C7:  MOVLW  9B
03C8:  BSF    03.5
03C9:  MOVWF  12
.................... setup_ccp1(ccp_pwm);                      // configura pwm 
03CA:  BCF    03.5
03CB:  BCF    20.2
03CC:  MOVF   20,W
03CD:  BSF    03.5
03CE:  MOVWF  07
03CF:  BCF    03.5
03D0:  BCF    07.2
03D1:  MOVLW  0C
03D2:  MOVWF  17
....................  
....................  
....................       set_pwm1_duty(1300); 
03D3:  MOVLW  45
03D4:  MOVWF  15
03D5:  MOVF   17,W
03D6:  ANDLW  CF
03D7:  MOVWF  17
....................       delay_ms(2000); 
03D8:  MOVLW  08
03D9:  MOVWF  42
03DA:  MOVLW  FA
03DB:  MOVWF  4C
03DC:  CALL   064
03DD:  DECFSZ 42,F
03DE:  GOTO   3DA
....................     
....................       menu=0; 
03DF:  CLRF   3C
.................... if(menu==0){ 
03E0:  MOVF   3C,F
03E1:  BTFSC  03.2
....................  
....................    set_pwm1_duty(0); 
03E2:  CLRF   15
.................... } 
03E3:  RETURN
....................  
.................... } 

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
