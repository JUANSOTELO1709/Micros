CCS PCM C Compiler, Version 5.025, 63725               05-ene.-23 18:47

               Filename:   C:\Users\juand\Desktop\micros\Teclado\clave acceso\main.lst

               ROM used:   756 words (9%)
                           Largest free fragment is 2048
               RAM used:   36 (10%) at main() level
                           46 (12%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   243
0003:  NOP
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  41
000C:  RETLW  34
000D:  RETLW  35
000E:  RETLW  36
000F:  RETLW  42
0010:  RETLW  37
0011:  RETLW  38
0012:  RETLW  39
0013:  RETLW  43
0014:  RETLW  2A
0015:  RETLW  30
0016:  RETLW  23
0017:  RETLW  44
0018:  BCF    0A.0
0019:  BCF    0A.1
001A:  BCF    0A.2
001B:  ADDWF  02,F
001C:  RETLW  28
001D:  RETLW  0C
001E:  RETLW  01
001F:  RETLW  06
0020:  DATA 0C,00
0021:  DATA 49,27
0022:  DATA 47,29
0023:  DATA C5,29
0024:  DATA 41,29
0025:  DATA A0,21
0026:  DATA CC,20
0027:  DATA D6,22
0028:  DATA 00,01
0029:  DATA A0,31
002A:  DATA EC,30
002B:  DATA F6,32
002C:  DATA A0,31
002D:  DATA 6F,39
002E:  DATA F2,32
002F:  DATA 63,3A
0030:  DATA 61,00
0031:  DATA A0,20
0032:  DATA E4,32
0033:  DATA EC,30
0034:  DATA 6E,3A
0035:  DATA E5,10
0036:  DATA 00,01
0037:  DATA 20,10
0038:  DATA 63,36
0039:  DATA 61,3B
003A:  DATA 65,10
003B:  DATA 65,39
003C:  DATA F2,37
003D:  DATA EE,32
003E:  DATA 61,00
003F:  DATA 20,10
0040:  DATA E8,37
0041:  DATA EC,30
0042:  DATA 00,00
*
012C:  MOVF   0B,W
012D:  MOVWF  3D
012E:  BCF    0B.7
012F:  BSF    03.5
0130:  BSF    03.6
0131:  BSF    0C.7
0132:  BSF    0C.0
0133:  NOP
0134:  NOP
0135:  BCF    03.5
0136:  BCF    03.6
0137:  BTFSC  3D.7
0138:  BSF    0B.7
0139:  BSF    03.6
013A:  MOVF   0C,W
013B:  ANDLW  7F
013C:  BTFSC  03.2
013D:  GOTO   180
013E:  BCF    03.6
013F:  MOVWF  3D
0140:  BSF    03.6
0141:  MOVF   0D,W
0142:  BCF    03.6
0143:  MOVWF  3E
0144:  BSF    03.6
0145:  MOVF   0F,W
0146:  BCF    03.6
0147:  MOVWF  3F
0148:  MOVF   3D,W
0149:  MOVWF  40
014A:  CALL   105
014B:  MOVF   3E,W
014C:  BSF    03.6
014D:  MOVWF  0D
014E:  BCF    03.6
014F:  MOVF   3F,W
0150:  BSF    03.6
0151:  MOVWF  0F
0152:  BCF    03.6
0153:  MOVF   0B,W
0154:  MOVWF  40
0155:  BCF    0B.7
0156:  BSF    03.5
0157:  BSF    03.6
0158:  BSF    0C.7
0159:  BSF    0C.0
015A:  NOP
015B:  NOP
015C:  BCF    03.5
015D:  BCF    03.6
015E:  BTFSC  40.7
015F:  BSF    0B.7
0160:  BSF    03.6
0161:  RLF    0C,W
0162:  RLF    0E,W
0163:  ANDLW  7F
0164:  BTFSC  03.2
0165:  GOTO   180
0166:  BCF    03.6
0167:  MOVWF  3D
0168:  BSF    03.6
0169:  MOVF   0D,W
016A:  BCF    03.6
016B:  MOVWF  3E
016C:  BSF    03.6
016D:  MOVF   0F,W
016E:  BCF    03.6
016F:  MOVWF  3F
0170:  MOVF   3D,W
0171:  MOVWF  40
0172:  CALL   105
0173:  MOVF   3E,W
0174:  BSF    03.6
0175:  MOVWF  0D
0176:  BCF    03.6
0177:  MOVF   3F,W
0178:  BSF    03.6
0179:  MOVWF  0F
017A:  INCF   0D,F
017B:  BTFSC  03.2
017C:  INCF   0F,F
017D:  BCF    03.6
017E:  GOTO   12C
017F:  BSF    03.6
0180:  BCF    03.6
0181:  RETURN
*
01EB:  BSF    0A.0
01EC:  BCF    0A.1
01ED:  BCF    0A.2
01EE:  ADDWF  02,F
01EF:  GOTO   18E
01F0:  GOTO   194
01F1:  GOTO   19A
01F2:  GOTO   1A0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
0043:  MOVLW  41
0044:  MOVWF  04
0045:  BCF    03.7
0046:  MOVF   00,W
0047:  BTFSC  03.2
0048:  GOTO   056
0049:  MOVLW  06
004A:  MOVWF  78
004B:  CLRF   77
004C:  DECFSZ 77,F
004D:  GOTO   04C
004E:  DECFSZ 78,F
004F:  GOTO   04B
0050:  MOVLW  7B
0051:  MOVWF  77
0052:  DECFSZ 77,F
0053:  GOTO   052
0054:  DECFSZ 00,F
0055:  GOTO   049
0056:  RETURN
....................  
....................  
.................... #use standard_io(D) 
.................... #use standard_io(B) 
.................... #use fast_io(E) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
01F3:  MOVF   3E,W
01F4:  MOVWF  7A
01F5:  MOVF   3D,W
01F6:  MOVWF  04
01F7:  BCF    03.7
01F8:  BTFSC  7A.0
01F9:  BSF    03.7
01FA:  MOVF   00,F
01FB:  BTFSC  03.2
01FC:  GOTO   23D
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
01FD:  MOVF   3E,W
01FE:  MOVWF  42
01FF:  MOVF   3D,W
0200:  MOVWF  41
0201:  MOVF   40,W
0202:  MOVWF  44
0203:  MOVF   3F,W
0204:  MOVWF  43
0205:  MOVF   44,W
0206:  MOVWF  7A
0207:  MOVF   43,W
0208:  MOVWF  04
0209:  BCF    03.7
020A:  BTFSC  7A.0
020B:  BSF    03.7
020C:  MOVF   00,F
020D:  BTFSC  03.2
020E:  GOTO   22A
020F:  MOVF   42,W
0210:  MOVWF  7A
0211:  MOVF   41,W
0212:  MOVWF  04
0213:  BCF    03.7
0214:  BTFSC  7A.0
0215:  BSF    03.7
0216:  MOVF   00,W
0217:  MOVWF  45
0218:  MOVF   44,W
0219:  MOVWF  7A
021A:  MOVF   43,W
021B:  MOVWF  04
021C:  BCF    03.7
021D:  BTFSC  7A.0
021E:  BSF    03.7
021F:  MOVF   00,W
0220:  SUBWF  45,W
0221:  BTFSS  03.2
0222:  GOTO   22A
0223:  INCF   41,F
0224:  BTFSC  03.2
0225:  INCF   42,F
0226:  INCF   43,F
0227:  BTFSC  03.2
0228:  INCF   44,F
0229:  GOTO   205
....................  
....................       if (*t == '\0') 
022A:  MOVF   44,W
022B:  MOVWF  7A
022C:  MOVF   43,W
022D:  MOVWF  04
022E:  BCF    03.7
022F:  BTFSC  7A.0
0230:  BSF    03.7
0231:  MOVF   00,F
0232:  BTFSS  03.2
0233:  GOTO   239
....................          return s1; 
0234:  MOVF   3D,W
0235:  MOVWF  78
0236:  MOVF   3E,W
0237:  MOVWF  79
0238:  GOTO   240
....................       ++s1; 
0239:  INCF   3D,F
023A:  BTFSC  03.2
023B:  INCF   3E,F
....................       #ifdef FASTER_BUT_MORE_ROM 
023C:  GOTO   1F3
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
023D:  MOVLW  00
023E:  MOVWF  78
023F:  MOVWF  79
0240:  BCF    0A.3
0241:  BCF    0A.4
0242:  GOTO   2A8 (RETURN)
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0250:  BCF    03.5
0251:  CLRF   20
0252:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <kbd4x4.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     KBD_LIB.C by Redraven                         //// 
.................... ////                                                                   //// 
.................... ////                     Derived from KBDD.C                           //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81              // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83              // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                  // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B0) 
....................  
.................... #define COL0 (1 << 0) // PIN_B0 
.................... #define COL1 (1 << 1) // PIN_B1 
.................... #define COL2 (1 << 2) // PIN_B2 
.................... #define COL3 (1 << 3) // PIN_B3 
....................  
.................... #define ROW0 (1 << 4) // PIN_B4 
.................... #define ROW1 (1 << 5) // PIN_B5 
.................... #define ROW2 (1 << 6) // PIN_B6 
.................... #define ROW3 (1 << 7) // PIN_B7 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
.................... void kbd_init() { 
*
00DD:  BCF    0A.3
00DE:  BCF    0A.4
00DF:  GOTO   266 (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static byte kbd_call_count; 
*
0253:  CLRF   22
....................    static short int kbd_down; 
0254:  BCF    23.0
....................    static char last_key; 
0255:  CLRF   24
....................    static byte col; 
0256:  CLRF   25
....................  
....................    byte kchar; 
....................    byte row; 
....................  
....................    kchar='\0'; 
*
0182:  CLRF   3D
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0183:  INCF   22,F
0184:  MOVF   22,W
0185:  SUBLW  21
0186:  BTFSC  03.0
0187:  GOTO   1E2
....................        switch (col) { 
0188:  MOVF   25,W
0189:  ADDLW  FC
018A:  BTFSC  03.0
018B:  GOTO   1A5
018C:  ADDLW  04
018D:  GOTO   1EB
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
018E:  MOVLW  FE
018F:  BSF    03.5
0190:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
0191:  BCF    03.5
0192:  MOVWF  06
....................                     break; 
0193:  GOTO   1A5
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
0194:  MOVLW  FD
0195:  BSF    03.5
0196:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
0197:  BCF    03.5
0198:  MOVWF  06
....................                     break; 
0199:  GOTO   1A5
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
019A:  MOVLW  FB
019B:  BSF    03.5
019C:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
019D:  BCF    03.5
019E:  MOVWF  06
....................                     break; 
019F:  GOTO   1A5
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3); 
01A0:  MOVLW  F7
01A1:  BSF    03.5
01A2:  MOVWF  06
....................                     kbd=~COL3&ALL_PINS; 
01A3:  BCF    03.5
01A4:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
01A5:  BTFSS  23.0
01A6:  GOTO   1B1
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
01A7:  MOVF   06,W
01A8:  ANDLW  F0
01A9:  SUBLW  F0
01AA:  BTFSS  03.2
01AB:  GOTO   1B0
....................            kbd_down=false; 
01AC:  BCF    23.0
....................            kchar=last_key; 
01AD:  MOVF   24,W
01AE:  MOVWF  3D
....................            last_key='\0'; 
01AF:  CLRF   24
....................          } 
....................        } else { 
01B0:  GOTO   1E1
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
01B1:  MOVF   06,W
01B2:  ANDLW  F0
01B3:  SUBLW  F0
01B4:  BTFSC  03.2
01B5:  GOTO   1DC
....................              if((kbd & ROW0)==0) 
01B6:  MOVF   06,W
01B7:  ANDLW  10
01B8:  BTFSS  03.2
01B9:  GOTO   1BC
....................                row=0; 
01BA:  CLRF   3E
01BB:  GOTO   1D0
....................              else if((kbd & ROW1)==0) 
01BC:  MOVF   06,W
01BD:  ANDLW  20
01BE:  BTFSS  03.2
01BF:  GOTO   1C3
....................                row=1; 
01C0:  MOVLW  01
01C1:  MOVWF  3E
01C2:  GOTO   1D0
....................              else if((kbd & ROW2)==0) 
01C3:  MOVF   06,W
01C4:  ANDLW  40
01C5:  BTFSS  03.2
01C6:  GOTO   1CA
....................                row=2; 
01C7:  MOVLW  02
01C8:  MOVWF  3E
01C9:  GOTO   1D0
....................              else if((kbd & ROW3)==0) 
01CA:  MOVF   06,W
01CB:  ANDLW  80
01CC:  BTFSS  03.2
01CD:  GOTO   1D0
....................                row=3; 
01CE:  MOVLW  03
01CF:  MOVWF  3E
....................              last_key =KEYS[row][col]; 
01D0:  RLF    3E,W
01D1:  MOVWF  77
01D2:  RLF    77,F
01D3:  MOVLW  FC
01D4:  ANDWF  77,F
01D5:  MOVF   77,W
01D6:  ADDWF  25,W
01D7:  CALL   004
01D8:  MOVWF  78
01D9:  MOVWF  24
....................              kbd_down = true; 
01DA:  BSF    23.0
....................           } else { 
01DB:  GOTO   1E1
....................              ++col; 
01DC:  INCF   25,F
....................              if(col==4) 
01DD:  MOVF   25,W
01DE:  SUBLW  04
01DF:  BTFSC  03.2
....................                col=0; 
01E0:  CLRF   25
....................           } 
....................        } 
....................       kbd_call_count=0; 
01E1:  CLRF   22
....................    } 
....................   set_tris_kbd(ALL_PINS); 
01E2:  MOVLW  FF
01E3:  BSF    03.5
01E4:  MOVWF  06
....................   return(kchar); 
01E5:  BCF    03.5
01E6:  MOVF   3D,W
01E7:  MOVWF  78
01E8:  BCF    0A.3
01E9:  BCF    0A.4
01EA:  GOTO   283 (RETURN)
.................... } 
....................  
....................  
.................... #define LCD_DB4  PIN_D4                     // Pines de la pantalla LCD 2004 
.................... #define LCD_DB5  PIN_D5 
.................... #define LCD_DB6  PIN_D6 
.................... #define LCD_DB7  PIN_D7 
.................... #define LCD_RS   PIN_D2 
.................... #define LCD_E    PIN_D3 
....................  
....................  
.................... #include <LCD_20X4.c>      
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... //#define USE_RW_PIN   1 
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0057:  BTFSC  48.0
0058:  GOTO   05B
0059:  BCF    08.4
005A:  GOTO   05C
005B:  BSF    08.4
005C:  BSF    03.5
005D:  BCF    08.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
005E:  BCF    03.5
005F:  BTFSC  48.1
0060:  GOTO   063
0061:  BCF    08.5
0062:  GOTO   064
0063:  BSF    08.5
0064:  BSF    03.5
0065:  BCF    08.5
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0066:  BCF    03.5
0067:  BTFSC  48.2
0068:  GOTO   06B
0069:  BCF    08.6
006A:  GOTO   06C
006B:  BSF    08.6
006C:  BSF    03.5
006D:  BCF    08.6
....................  output_bit(LCD_DB7, !!(nibble & 8));     
006E:  BCF    03.5
006F:  BTFSC  48.3
0070:  GOTO   073
0071:  BCF    08.7
0072:  GOTO   074
0073:  BSF    08.7
0074:  BSF    03.5
0075:  BCF    08.7
....................  
....................  delay_cycles(1);  
0076:  NOP
....................  output_high(LCD_E);  
0077:  BCF    08.3
0078:  BCF    03.5
0079:  BSF    08.3
....................  delay_us(2);  
007A:  MOVLW  02
007B:  MOVWF  77
007C:  DECFSZ 77,F
007D:  GOTO   07C
007E:  GOTO   07F
007F:  NOP
....................  output_low(LCD_E);  
0080:  BSF    03.5
0081:  BCF    08.3
0082:  BCF    03.5
0083:  BCF    08.3
0084:  RETURN
.................... }  
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0085:  BSF    03.5
0086:  BCF    08.2
0087:  BCF    03.5
0088:  BCF    08.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0089:  MOVLW  63
008A:  MOVWF  77
008B:  DECFSZ 77,F
008C:  GOTO   08B
008D:  GOTO   08E
.................... #endif  
....................  
.................... if(address)  
008E:  MOVF   45,F
008F:  BTFSC  03.2
0090:  GOTO   096
....................    output_high(LCD_RS);  
0091:  BSF    03.5
0092:  BCF    08.2
0093:  BCF    03.5
0094:  BSF    08.2
0095:  GOTO   09A
.................... else  
....................    output_low(LCD_RS);  
0096:  BSF    03.5
0097:  BCF    08.2
0098:  BCF    03.5
0099:  BCF    08.2
....................        
....................  delay_cycles(1);  
009A:  NOP
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
009B:  BSF    03.5
009C:  BCF    08.3
009D:  BCF    03.5
009E:  BCF    08.3
....................  
.................... lcd_send_nibble(n >> 4);  
009F:  SWAPF  46,W
00A0:  MOVWF  47
00A1:  MOVLW  0F
00A2:  ANDWF  47,F
00A3:  MOVF   47,W
00A4:  MOVWF  48
00A5:  CALL   057
.................... lcd_send_nibble(n & 0xf);  
00A6:  MOVF   46,W
00A7:  ANDLW  0F
00A8:  MOVWF  47
00A9:  MOVWF  48
00AA:  CALL   057
00AB:  RETURN
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... lcd_line = 1;  
00AC:  MOVLW  01
00AD:  MOVWF  26
....................  
.................... output_low(LCD_RS);  
00AE:  BSF    03.5
00AF:  BCF    08.2
00B0:  BCF    03.5
00B1:  BCF    08.2
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
00B2:  BSF    03.5
00B3:  BCF    08.3
00B4:  BCF    03.5
00B5:  BCF    08.3
....................  
.................... // Some LCDs require 15 ms minimum delay after  
.................... // power-up.  Others require 30 ms.  I'm going  
.................... // to set it to 35 ms, so it should work with  
.................... // all of them.  
.................... delay_ms(35);           
00B6:  MOVLW  23
00B7:  MOVWF  41
00B8:  CALL   043
....................  
.................... for(i=0 ;i < 3; i++)  
00B9:  CLRF   3D
00BA:  MOVF   3D,W
00BB:  SUBLW  02
00BC:  BTFSS  03.0
00BD:  GOTO   0C6
....................    {  
....................     lcd_send_nibble(0x03);  
00BE:  MOVLW  03
00BF:  MOVWF  48
00C0:  CALL   057
....................     delay_ms(5);  
00C1:  MOVLW  05
00C2:  MOVWF  41
00C3:  CALL   043
00C4:  INCF   3D,F
00C5:  GOTO   0BA
....................    }  
....................  
.................... lcd_send_nibble(0x02);  
00C6:  MOVLW  02
00C7:  MOVWF  48
00C8:  CALL   057
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00C9:  CLRF   3D
00CA:  MOVF   3D,W
00CB:  SUBLW  03
00CC:  BTFSS  03.0
00CD:  GOTO   0DA
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
00CE:  MOVF   3D,W
00CF:  CALL   018
00D0:  MOVWF  3E
00D1:  CLRF   45
00D2:  MOVF   3E,W
00D3:  MOVWF  46
00D4:  CALL   085
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 50 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_RW_PIN  
....................     delay_ms(5);  
00D5:  MOVLW  05
00D6:  MOVWF  41
00D7:  CALL   043
....................     #endif  
00D8:  INCF   3D,F
00D9:  GOTO   0CA
....................    }  
00DA:  BCF    0A.3
00DB:  BCF    0A.4
00DC:  GOTO   265 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
00E0:  MOVF   42,W
00E1:  XORLW  01
00E2:  BTFSC  03.2
00E3:  GOTO   0EE
00E4:  XORLW  03
00E5:  BTFSC  03.2
00E6:  GOTO   0F0
00E7:  XORLW  01
00E8:  BTFSC  03.2
00E9:  GOTO   0F3
00EA:  XORLW  07
00EB:  BTFSC  03.2
00EC:  GOTO   0F6
00ED:  GOTO   0F9
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
00EE:  CLRF   43
....................      break;  
00EF:  GOTO   0FA
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
00F0:  MOVLW  40
00F1:  MOVWF  43
....................      break;  
00F2:  GOTO   0FA
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
00F3:  MOVLW  14
00F4:  MOVWF  43
....................      break;  
00F5:  GOTO   0FA
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
00F6:  MOVLW  54
00F7:  MOVWF  43
....................      break;  
00F8:  GOTO   0FA
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
00F9:  CLRF   43
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
00FA:  MOVLW  01
00FB:  SUBWF  41,W
00FC:  ADDWF  43,F
.................... lcd_send_byte(0, 0x80 | address);  
00FD:  MOVF   43,W
00FE:  IORLW  80
00FF:  MOVWF  44
0100:  CLRF   45
0101:  MOVF   44,W
0102:  MOVWF  46
0103:  CALL   085
0104:  RETURN
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0105:  MOVF   40,W
0106:  XORLW  0C
0107:  BTFSC  03.2
0108:  GOTO   110
0109:  XORLW  06
010A:  BTFSC  03.2
010B:  GOTO   11A
010C:  XORLW  02
010D:  BTFSC  03.2
010E:  GOTO   121
010F:  GOTO   126
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0110:  CLRF   45
0111:  MOVLW  01
0112:  MOVWF  46
0113:  CALL   085
....................       lcd_line = 1;  
0114:  MOVLW  01
0115:  MOVWF  26
....................       delay_ms(2);  
0116:  MOVLW  02
0117:  MOVWF  41
0118:  CALL   043
....................       break;  
0119:  GOTO   12B
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
011A:  INCF   26,F
011B:  MOVLW  01
011C:  MOVWF  41
011D:  MOVF   26,W
011E:  MOVWF  42
011F:  CALL   0E0
....................        break;  
0120:  GOTO   12B
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0121:  CLRF   45
0122:  MOVLW  10
0123:  MOVWF  46
0124:  CALL   085
....................        break;  
0125:  GOTO   12B
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
0126:  MOVLW  01
0127:  MOVWF  45
0128:  MOVF   40,W
0129:  MOVWF  46
012A:  CALL   085
....................        break;  
....................    }  
012B:  RETURN
.................... } 
....................  
.................... void lcd_clear() 
.................... { 
....................    lcd_putc("\f"); 
.................... } 
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... void send_D7_D4(int8 address_lcd,int8 nibble_lcd) 
.................... {   
....................   if((nibble_lcd & 1)==1) output_high(LCD_DB4); else output_low(LCD_DB4); 
....................   if((nibble_lcd & 2)==2) output_high(LCD_DB5); else output_low(LCD_DB5); 
....................   if((nibble_lcd & 4)==4) output_high(LCD_DB6); else output_low(LCD_DB6); 
....................   if((nibble_lcd & 8)==8) output_high(LCD_DB7); else output_low(LCD_DB7); 
....................    delay_us(60); 
....................    if(address_lcd) 
....................      output_high(LCD_RS); 
....................        
....................    else 
....................      output_low(LCD_RS);  
....................        
....................  output_high(LCD_E); 
....................  delay_us(2); 
....................  output_low(LCD_E); 
.................... } 
....................  
.................... void send_byte_data(int8 address_lcd, int8 n) 
.................... { 
....................    send_D7_D4(address_lcd,n >> 4); 
....................    send_D7_D4(address_lcd,n & 0xf); 
.................... } 
....................  
.................... void CGRAM_putc(int8 n) 
.................... { 
....................    send_byte_data(1,n); 
.................... } 
....................  
.................... void CGRAM_position(int p) 
.................... { 
....................   send_byte_data(0,0x40+p*8); 
.................... } 
....................  
.................... void CGRAM_create_char(char* new_char) 
.................... { 
....................   for(int cg=0; cg<=7;cg++) 
....................   { 
....................     send_byte_data(1,new_char[cg]); 
....................   } 
.................... } 
....................  
.................... char k; 
....................  
....................  
.................... int num=0; 
.................... char clave_entrada[] = "#000000000"; 
*
0257:  MOVLW  23
0258:  MOVWF  29
0259:  MOVLW  30
025A:  MOVWF  2A
025B:  MOVWF  2B
025C:  MOVWF  2C
025D:  MOVWF  2D
025E:  MOVWF  2E
025F:  MOVWF  2F
0260:  MOVWF  30
0261:  MOVWF  31
0262:  MOVWF  32
0263:  CLRF   33
.................... char clave [8]; 
....................  
.................... int menu=0; 
....................  
.................... void main() 
*
0243:  MOVF   03,W
0244:  ANDLW  1F
0245:  MOVWF  03
0246:  CLRF   28
0247:  CLRF   3C
0248:  BSF    03.5
0249:  BSF    1F.0
024A:  BSF    1F.1
024B:  BSF    1F.2
024C:  BCF    1F.3
024D:  MOVLW  07
024E:  MOVWF  1C
024F:  BCF    03.7
.................... { 
....................    lcd_init(); 
*
0264:  GOTO   0AC
....................    kbd_init(); 
0265:  GOTO   0DD
....................    port_b_pullups(true); 
0266:  BSF    03.5
0267:  BCF    01.7
....................  
....................        
....................  
....................    while(TRUE) 
....................    { 
....................  
.................... switch (menu){ 
0268:  BCF    03.5
0269:  MOVF   3C,W
026A:  BTFSC  03.2
026B:  GOTO   270
026C:  XORLW  01
026D:  BTFSC  03.2
026E:  GOTO   2E4
026F:  GOTO   2F2
.................... case 0: 
....................       lcd_putc('\f'); 
0270:  MOVLW  0C
0271:  MOVWF  40
0272:  CALL   105
....................       lcd_gotoxy(1,1); 
0273:  MOVLW  01
0274:  MOVWF  41
0275:  MOVWF  42
0276:  CALL   0E0
....................       lcd_putc("INGRESAR CLAVE"); 
0277:  MOVLW  21
0278:  BSF    03.6
0279:  MOVWF  0D
027A:  MOVLW  00
027B:  MOVWF  0F
027C:  BCF    03.6
027D:  CALL   12C
.................... num = 0; 
027E:  CLRF   28
....................        
.................... while(num<1){ 
027F:  MOVF   28,F
0280:  BTFSS  03.2
0281:  GOTO   29A
....................          k=kbd_getc(); 
0282:  GOTO   182
0283:  MOVF   78,W
0284:  MOVWF  27
....................          if(k != 0){ 
0285:  MOVF   27,F
0286:  BTFSC  03.2
0287:  GOTO   299
....................             
....................           clave[num]=k; 
0288:  MOVLW  34
0289:  ADDWF  28,W
028A:  MOVWF  04
028B:  BCF    03.7
028C:  MOVF   27,W
028D:  MOVWF  00
....................            num++; 
028E:  INCF   28,F
....................           lcd_gotoxy(num+1,2); 
028F:  MOVLW  01
0290:  ADDWF  28,W
0291:  MOVWF  3D
0292:  MOVWF  41
0293:  MOVLW  02
0294:  MOVWF  42
0295:  CALL   0E0
....................           lcd_putc(k); 
0296:  MOVF   27,W
0297:  MOVWF  40
0298:  CALL   105
....................                 
....................             } 
0299:  GOTO   27F
....................          } 
....................       delay_ms(1500); 
029A:  MOVLW  06
029B:  MOVWF  3D
029C:  MOVLW  FA
029D:  MOVWF  41
029E:  CALL   043
029F:  DECFSZ 3D,F
02A0:  GOTO   29C
....................  
....................  
.................... if(strstr(clave , clave_entrada)){ 
02A1:  CLRF   3E
02A2:  MOVLW  34
02A3:  MOVWF  3D
02A4:  CLRF   40
02A5:  MOVLW  29
02A6:  MOVWF  3F
02A7:  GOTO   1F3
02A8:  MOVF   78,W
02A9:  IORWF  79,W
02AA:  BTFSC  03.2
02AB:  GOTO   2D0
....................       output_high(PIN_E0); 
02AC:  BSF    09.0
....................       output_low(PIN_E1); 
02AD:  BCF    09.1
....................       lcd_putc('\f'); 
02AE:  MOVLW  0C
02AF:  MOVWF  40
02B0:  CALL   105
....................       lcd_gotoxy(1,1); 
02B1:  MOVLW  01
02B2:  MOVWF  41
02B3:  MOVWF  42
02B4:  CALL   0E0
....................       lcd_putc(" clave correcta"); 
02B5:  MOVLW  29
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  00
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   12C
....................       menu++; 
02BC:  INCF   3C,F
....................  
....................   delay_ms(100); 
02BD:  MOVLW  64
02BE:  MOVWF  41
02BF:  CALL   043
....................       lcd_gotoxy(1,2); 
02C0:  MOVLW  01
02C1:  MOVWF  41
02C2:  MOVLW  02
02C3:  MOVWF  42
02C4:  CALL   0E0
....................       lcd_putc(" Adelante!"); 
02C5:  MOVLW  31
02C6:  BSF    03.6
02C7:  MOVWF  0D
02C8:  MOVLW  00
02C9:  MOVWF  0F
02CA:  BCF    03.6
02CB:  CALL   12C
.................... delay_ms(150); 
02CC:  MOVLW  96
02CD:  MOVWF  41
02CE:  CALL   043
.................... } 
02CF:  GOTO   2E3
.................... else { 
....................       output_high(PIN_E1); 
02D0:  BSF    09.1
....................       output_low(PIN_E0); 
02D1:  BCF    09.0
....................       lcd_putc('\f'); 
02D2:  MOVLW  0C
02D3:  MOVWF  40
02D4:  CALL   105
....................       lcd_gotoxy(1,1); 
02D5:  MOVLW  01
02D6:  MOVWF  41
02D7:  MOVWF  42
02D8:  CALL   0E0
....................       lcd_putc("  clave erronea"); 
02D9:  MOVLW  37
02DA:  BSF    03.6
02DB:  MOVWF  0D
02DC:  MOVLW  00
02DD:  MOVWF  0F
02DE:  BCF    03.6
02DF:  CALL   12C
....................   delay_ms(150); 
02E0:  MOVLW  96
02E1:  MOVWF  41
02E2:  CALL   043
....................  
.................... } 
.................... break; 
02E3:  GOTO   2F2
.................... case 1: 
....................       lcd_putc('\f'); 
02E4:  MOVLW  0C
02E5:  MOVWF  40
02E6:  CALL   105
.................... lcd_gotoxy(1,1); 
02E7:  MOVLW  01
02E8:  MOVWF  41
02E9:  MOVWF  42
02EA:  CALL   0E0
....................       lcd_putc("  hola"); 
02EB:  MOVLW  3F
02EC:  BSF    03.6
02ED:  MOVWF  0D
02EE:  MOVLW  00
02EF:  MOVWF  0F
02F0:  BCF    03.6
02F1:  CALL   12C
....................  
....................        
.................... } 
02F2:  GOTO   269
....................    }} 
02F3:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
